"------------------------------------------------------"

				python 数据结构与算法

"-----------------------------------------------------"

算法概念：

	算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。
	
	算法是独立存在的一种解决问题的方法和思想。


	算法的五大特性
	
		1、输入: 算法具有0个或多个输入
		2、输出: 算法至少有1个或多个输出
		3、有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成
		4、确定性：算法中的每一步都有确定的含义，不会出现二义性
		5、可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成
		

算法效率衡量：

	实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。
	单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！

时间复杂度与“大O记法”：

	对于算法的时间效率，我们可以用“大O记法”来表示。
	
	“大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c>0，
	使得对于充分大的n总有f(n)<=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。
	也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。

	时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，
	则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)

	
	最坏时间复杂度:

		算法完成工作最少需要多少基本操作，即最优时间复杂度
		算法完成工作最多需要多少基本操作，即最坏时间复杂度
		算法完成工作平均需要多少基本操作，即平均时间复杂度


	时间复杂度的几条基本计算规则：
		
		1、基本操作，即只有常数项，认为其时间复杂度为O(1)
		2、顺序结构，时间复杂度按加法进行计算
		3、循环结构，时间复杂度按乘法进行计算
		4、分支结构，时间复杂度取最大值
		5、判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略
		6、在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度
		
	算法分析：

		for a in range(0, 1001):
			for b in range(0, 1001):
				for c in range(0, 1001):
					if a**2 + b**2 == c**2 and a+b+c == 1000:
						print("a, b, c: %d, %d, %d" % (a, b, c))

		时间复杂度：T(n) = O(n*n*n) = O(n3)


		for a in range(0, 1001):
			for b in range(0, 1001-a):
				c = 1000 - a - b
				if a**2 + b**2 == c**2:
					print("a, b, c: %d, %d, %d" % (a, b, c))

		时间复杂度：T(n) = O(n*n*(1+1)) = O(n*n) = O(n2)


	常见时间复杂度:

		
	执行次数函数举例	   阶	                  非正式术语
	12	                  O(1)                   	常数阶
	2n+3	              O(n)                    	线性阶
	3n2+2n+1	          O(n2)	                    平方阶
	5log2n+20	          O(logn)	                对数阶
	2n+3nlog2n+19         O(nlogn)	                nlogn阶
	6n3+2n2+3n+4	      O(n3)	                    立方阶
	2^n	                  O(2^n)	                指数阶


	所消耗的时间从小到大

	O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!) < O(nn)



Python内置类型性能分析:


timeit模块:

	timeit模块可以用来测试一小段Python代码的执行速度。	

	class timeit.Timer(stmt='pass', setup='pass', timer=<timer function>)

		Timer是测量小段代码执行速度的类。
		stmt参数是要测试的代码语句（statment）；
		setup参数是运行代码时需要的设置；
		timer参数是一个定时器函数，与平台有关。
	
	timeit.Timer.timeit(number=1000000)

	Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。
	方法返回执行代码的平均耗时，一个float类型的秒数。

	from timeit import Timer
	def test1():
		l = []
		for i in range(1000):
			l = l + [i]

	t1 = Timer("test1()", "from __main__ import test1")
	print("concat ",t1.timeit(number=1000), "seconds")




数据结构：

	1、概念：

		数据是一个抽象的概念，将其进行分类后得到程序设计语言中的基本类型。如：int，float，char等。
		数据元素之间不是独立的，存在特定的关系，这些关系便是结构。数据结构指数据对象中数据元素之间的关系。

		Python给我们提供了很多现成的数据结构类型，这些系统自己定义好的，不需要我们自己去定义的数据结构叫
		做Python的内置数据结构，比如列表、元组、字典。而有些数据组织方式，Python系统里面没有直接定义，
		需要我们自己去定义实现这些数据的组织方式，这些数据组织方式称之为Python的扩展数据结构，比如栈，队列等。

	
	2、算法与数据结构的区别：

		数据结构只是静态的描述了数据元素之间的关系。	
		高效的程序需要在数据结构的基础上设计和选择算法。
		程序 = 数据结构 + 算法
		总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体。

	3、抽象数据类型(Abstract Data Type)：

		抽象数据类型(ADT)的含义是指一个数学模型以及定义在此数学模型上的一组操作。
		即把数据类型和数据类型上的运算捆在一起，进行封装。
		引入抽象数据类型的目的是把数据类型的表示和数据类型上运算的实现与这些数据类型和
		运算在程序中的引用隔开，使它们相互独立。

		最常用的数据运算有五种：

			插入
			删除
			修改
			查找
			排序

	
顺序表：

	根据线性表的实际存储方式，分为两种实现模型：

	顺序表，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。
	链表，将元素存放在通过链接构造起来的一系列存储块中。

	顺序表的结构与实现:

		一个顺序表的完整信息包括两部分，一部分是表中的元素集合，
		另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，
		这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。


	顺序表的两种基本实现方式:

		一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，
		两部分数据的整体形成一个完整的顺序表对象。

		分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），
		实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。


	元素存储区替换:

		一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，
		即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。

		分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。

	元素存储区扩充:

		采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，
		则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。
		只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。
		人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。

		扩充的两种策略:

			每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。

			特点：节省空间，但是扩充操作频繁，操作次数多。

			每次扩充容量加倍，如每次扩充增加一倍存储空间。

			特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。

Python中的顺序表:

	Python中的list和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。

	tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似

	在Python的官方实现中，list就是一种采用分离式技术实现的动态顺序表。

	list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；
	在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。
	但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。
	引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。


链表：

	顺序表的构建需要预先知道数据大小来申请连续的存储空间，而在进行扩充时又需要进行数据的搬迁，
	所以使用起来并不是很灵活。
	
	链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。

	链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储数据，
	而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）。



栈(stack)：

	栈(stack):
	
		又可以称为堆栈，是一种容器，可存入数据元素，访问数据，删除数据。特点在于只能允许
		在容器的一端（栈顶top）进行加入数据(push)和输出数据(pop)的运算。
		没有了位置概念，保证任何时候可以访问、删除的元素都是此前最后存入的那个元素，确定
		了一种默认的访问顺序。

		由于栈数据结构只允许在一端进行操作，因而按照后进先出(Last in First Out)的原理运行。


	栈结构实现：

		栈可以用顺序表实现，也可以用链表实现。

		class Stack(object):
			"""栈"""
			def __init__(self):
				self.items = []

			def is_empty(self):
				"""判断是否为空"""
				return self.items == []

			def push(self, item):
				"""加入元素"""
				self.items.append(item)

			def pop(self):
				"""弹出元素"""
				return self.items.pop()

			def peek(self):
				"""返回栈顶元素"""
				return self.items[len(self.items)-1]

			def size(self):
				"""返回栈的大小"""
				return len(self.items)

if __name__ == "__main__":
	stack = Stack()
	stack.push("hello")
	stack.push("world")
	stack.push("itcast")
	print stack.size()
	print stack.peek()
	print stack.pop()
	print stack.pop()
	print stack.pop()




队列：

	队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

	队列是一种先进先出的(First In First Out)的线性表,简称FIFO。
	允许插入的一端为对尾，允许删除的一端为队头。队列不允许中间部位进行操作
	假设队列是q=(a1,a2,...,an),那么a1就是队头元素，而an是队尾元素。


	队列的实现：

		同栈一样，队列也可以用顺序表或者链表实现。


		class Queue(object):
			"""队列"""
			def __init__(self):
				self.items = []

			def is_empty(self):
				return self.items == []

			def enqueue(self, item):
				"""进队列"""
				self.items.insert(0,item)

			def dequeue(self):
				"""出队列"""
				return self.items.pop()

			def size(self):
				"""返回大小"""
				return len(self.items)

	if __name__ == "__main__":
		q = Queue()
		q.enqueue("hello")
		q.enqueue("world")
		q.enqueue("itcast")
		print q.size()
		print q.dequeue()
		print q.dequeue()
		print q.dequeue()


双端队列：

	双端队列(deque,double-ended queue),是一种具有队列和栈的性质的数据结构

	双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行，双端
	队列可以在任意一端入队出队。


	class Deque(object):
		"""双端队列"""
		def __init__(self):
			self.items = []

		def is_empty(self):
		"""判断队列是否为空"""
			return self.items == []

		def add_front(self, item):
		"""在队头添加元素"""
			self.items.insert(0,item)

		def add_rear(self, item):
		"""在队尾添加元素"""
			self.items.append(item)

		def remove_front(self):
		"""从队头删除元素"""
			return self.items.pop(0)

		def remove_rear(self):
		"""从队尾删除元素"""
			return self.items.pop()

		def size(self):
		"""返回队列大小"""
			return len(self.items)


	if __name__ == "__main__":
		deque = Deque()
		deque.add_front(1)
		deque.add_front(2)
		deque.add_rear(3)
		deque.add_rear(4)
		print deque.size()
		print deque.remove_front()
		print deque.remove_front()
		print deque.remove_rear()
		print deque.remove_rear()


排序与搜索:

	排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。

	排序算法的稳定性:

		稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。
		也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，
		在排序过的列表中R也将会是在S之前。

		当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。
		然而，假设以下的数对将要以他们的第一个数字来排序。

		(4, 1)  (3, 1)  (3, 7)（5, 6）
		在这个状况下，有可能产生两种不同的结果，一个是让相等键值的纪录维持相对的次序，而另外一个则没有：

		(3, 1)  (3, 7)  (4, 1)  (5, 6)  （维持次序）
		(3, 7)  (3, 1)  (4, 1)  (5, 6)  （次序被改变）

		不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。

冒泡排序：

	冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，
	如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
	这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

	冒泡排序算法的运作如下：
		
		比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。
		对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
		针对所有的元素重复以上的步骤，除了最后一个。
		持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

	第一种方式：

		def bubble_sort(alist):
			for j in range(len(alist)-1,0,-1):
				# j表示每次遍历需要比较的次数，是逐渐减小的
			
				for i in range(j):
					if alist[i] > alist[i+1]:
						alist[i], alist[i+1] = alist[i+1], alist[i]

		li = [54,26,93,17,77,31,44,55,20]
		bubble_sort(li)
		print(li)


	第二种方式：

		def bubble_sort(alist):
			for i in range(len(alist)):
				for j in range(i+1,len(alist)):
					if alist[i] > alist[j]:
						alist[i],alist[j] = alist[j],alist[i]

		li = [54,26,93,17,77,44,55,20]
		bubble_sort(li)
		print(li)



	时间复杂度

	最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）
	最坏时间复杂度：O(n2)
	稳定性：稳定


选择排序:

	选择排序（Selection sort)是一种简单直观的排序算法。它的工作原理如下。
	首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，
	然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
	以此类推，直到所有元素均排序完毕。



		

		

		

























