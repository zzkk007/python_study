
"-----------------------------------------------------------------------------"

				学习手册

"-----------------------------------------------------------------------------"

Python 解释器简介：

	我们大多数时候都是讲Python作为一门编程语言来介绍，但是，从目前的实现来讲，
	Python 也是一个名为解释器的软件包。

	解释器是一种将其他程序运行起来的程序，当你编写了一段Python程序，Python解释器
	将读取程序，并按照其中的命令执行，得出结果。实际上，解释器是代码和机器的计算机
	硬件之间的软件逻辑层。


	1、程序执行：

		编写或运行Python脚本的意义是什么呢？这取决于你是一个程序员还是Python解释器的
		角度去看待这个问题。

		程序员角度：一个Python程序仅是一个包含Python语句的文本文件。

		Python的视角：当Python运行脚本时，在代码开始进行处理之前，
		Python还会执行一些步骤，确切的说，第一步是编译成所谓的"字节码"，
		之后将其转发到所谓的"虚拟机"中。

		a. 字节码编译:

			当程序执行时，Python内部（对于大多数用户是完全隐藏的）会先将源代码
			编译成所谓的字节码形式。编译是一个简单的翻译步骤，而且字节码是源代码
			底层的，与平台无关的表现形式。
			概括的说，Python通过把每一条源语句分解为单一步骤来将这些源语句翻译
			成一组字节码指令。这些字节码可以提高执行速度。

			如果Python进程在机器上拥有写入权限，那么它将把程序的字节码保存为一个
			以.pyc为扩展名的文件名。

		b. Python虚拟机(PVM)：

			一旦程序编写成字节码，之后的字节码发送到通常称为Python虚拟机上来执行。
			实际上，PVM不是一个独立的程序，不需要安装。
			事实上，PVM就是迭代运行字节码指令的一个大循环，一个接一个的完成操作。
			PVM是Python的运行引擎，它时常表现为Python系统的一部分，并且它是实际
			运行脚本的组件，从技术上讲，它才是所谓"Python解释器"的最后一步。

		c. Python 语言的三种实现方式(CPython,Jython,IronPython)


	2、全局解释器锁(英语：Global Interpreter Lock，缩写GIL):

		是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。
		即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程。
		常见的使用 GIL 的解释器有CPython与Ruby MRI。

		a. Python的GIL:

			CPython的线程是操作系统的原生线程。在Linux上为pthread，
			在Windows上为Win thread，完全由操作系统调度线程的执行。
			一个Python解释器进程内有一个主线程，以及多个用户程序的执行线程。即便使用多核心CPU平台，
			由于GIL的存在，也将禁止多线程的并行执行。
		
			Python解释器进程内的多线程是以协作多任务方式执行。
			当一个线程遇到I/O任务时，将释放GIL。
			计算密集型（CPU-bound）的线程在执行大约100次解释器的计步（ticks）时，将释放GIL。
			计步（ticks）可粗略看作Python虚拟机的指令。计步实际上与时间片长度无关。
			可以通过sys.setcheckinterval()设置计步长度。
			
			在单核CPU上，数百次的间隔检查才会导致一次线程切换。
			在多核CPU上，存在严重的线程颠簸（thrashing）。
			
			Python 3.2开始使用新的GIL。新的GIL实现中用一个固定的超时时间来指示当前的线程放弃全局锁。
			在当前线程保持这个锁，且其他线程请求这个锁时，当前线程就会在5毫秒后被强制释放该锁。

			可以创建独立的进程来实现并行化。Python 2.6引进了多进程包multiprocessing。
			或者将关键组件用C/C++编写为Python扩展，
			通过ctypes使Python程序直接调用C语言编译的动态链接库的导出函数。

"----------------------------------------------------------------------------------------"  

					第四章   python 对象类型  
					
"----------------------------------------------------------------------------------------"

1、import 和 from :

	import 语句将模块作为一个整体载入，并使用模块名后跟一个属性名来获取使用。
	内置的dir函数，可以使用它获得模块内部的可用的变量名列表。
	import os
	dir(os)

	from 和import 很相似，只不过增加了对载入组件的变量名的额外的赋值，从技术上讲，from复制了模块的属性，以便属性能够成为接收者的直接变量。

	from语句从某种意义上来说战胜了模块的名称空间分隔的目的，以为from把变量从一个文件复制到另一个文件，
	这可能导致在导入的文件中相同名称的变量被覆盖（不会警告）。这根本上回导致名称空间重叠在一起，至少会在复制变量上回重叠。



2、核心类型:

	python内置对象：数字、字符串、列表、字典、元组、文件、集合。

	其他类型(类型、None、布尔型)、编程单元类型(函数、模块、类)、与现实相关的类型（编译的代码堆栈跟踪）

	核心类型中，数字、字符串和元组是不可变的，列表和字典可以自由改变，字符串，列表、元组是序列，字典是映射。

	集合:集合是最近增添到python语言中的类型，它不是映射也不是序列，相反他是唯一的不可变的无序集合，
	集合可以通过内置对象set函数而创建或使用python3中集合常量和表达式创建，集合更像是一个无值的字典的键。


字典：
	
	字典不是队列，而是一种映射。映射是一个其他对象的集合，但是他们是通过键而不是相对位置来存储的。
	字典是python核心对象中唯一的一种映射类型，也具有可变性。

文件：

	文件对象是python代码对电脑上外部文件的主要接口。虽然文件是核心类型，但是它有些特殊：没有特定的常量语法创建文件。
	要创建一个文件对象，需要调用内置的open函数一字符串的形式传递给它一个外部的文件名以及一个处理模式的字符串。

	Python还有额外的类文件工具:管道、先进先出队列（FIFO）、套接字、通过键访问文件、对象持久、基于描述符的文件、关系数据库和
	面向对象数据库接口等。例如，描述符文件支持文件锁定和其他的底层工具，问套接字提供网络和进程间通信接口。
	
	Python3中类型已经和类结合起来了。

python中允许编写代码来检验它所处理的对象的类型，

python中至少有三种方法可以做到:

	1:
		if type(L) == type([]):   
			print('yes')

	2:       
		if type(L) == list:  
			print('yes')

	3:
		if isinstance(L,list):  
			print('yes')


核心python概念(可能是唯一一个)：

	在代码中检验了特定的类型，实际上是破坏了它的灵活性，即限制它使用一种类型工作。没有这样的检测，代码也许能使用整个范围的类型工作。

	这与多太思想有些关联，它是由Python没有类型声明而发展出来的。在python中，我们编写对象接口而不是类型。
	不关注于特定的类型意味着代码会自动地适应它们中的很多类型：任何具有兼容接口的对象均能够工作,而不管它是什么对象类型。
	尽管支持类型检测（极少情况下，是必要的），但是它并不是一个“python式”的思维方法。事实上，多态也是使用Python的一个关键思想。

	"多态"意味着一个操作符的意义取决于被操作的对象。这将变成使用好Python的关键思想之一：
	不要把代码限制在特定的类型上，使代码自动适应多种类型。


	我们学的这些数字、字符串、列表、字典、集合类型，是对象仅是对象而已，并不一定是面向对象。
	面向对象是一种往往要求有继承和python类声明的概念。


"----------------------------------------------------------------------------------------------------------"

						第五章  数字    

"----------------------------------------------------------------------------------------------------------"

在python中数字并不是一个真正的对象类型，而是一组类似类型的分类。

	yield x                    生成器函数发送协议

	lambda args:expression     生产匿名函数

	x if y else z              三元选择表达式

	x or y                     逻辑或（只有x 为假，才会计算y）

	x and y                    逻辑与（只有x 为真，才会计算y）

	not x                      逻辑非

	x in y , x not in y        成员关系（可迭代对象、集合）

	x is y , x is not y        对象实体测试

	x | y                      位或

	x ^ y                      位异或

	x // y                     真除法

	x[i:j:k]                   分片

	x(...)                     调用（函数、方法、类及其他调用）

	(...)                      元组、表达式、生成器表达式

	[...]                      列表、列表解析

	{...}                      字典、集合、集合和字典解析


列表解析：
	
	根据已有的列表，高效创建新列表的方式。列表解析是python迭代机制的一种应用。
	
	语法：
	
	[expression for iter_val in interable]
	
	[expression for iter_val in interable if cond_expr]

	例如：
	L = [ i**2 for i in range(1,11) if i >= 4 ]
	
	print L
	
	[16,25,36,49,64,81,100]



协程：

	协程是一种用户级的轻量级线程。协程拥有自己的寄存器上下文和栈。
	协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。
	因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，
	就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。
	在并发编程中，协程与线程类似，每个协程表示一个执行单元，有自己的本地数据，与其它协程共享全局数据和其它资源。
	目前主流语言基本上都选择了多线程作为并发设施，与线程相关的概念是抢占式多任务（Preemptive multitasking），
	而与协程相关的是协作式多任务。



yield与send实现协程操作:

	在函数内部含有yield语句即称为生成器。

	def foo():

		while True:
	
			x = yield
			
			print("value:",x)

	g = foo()        #g 是一个生产器

	next(g)          #程序运行到yield就停住了，等待下一个next

	g.send(1)        #我们给yield 发送值1，然后这个值就被赋值给了x,并且打印出来，然后继续下一次循环停在yield处

	g.send(2)        #同上

	next(g)          #没有给赋值，执行print语句，打印None,继续循环停在yield处


	我们都知道，程序一旦执行到yield就会停在该处,并且将其返回值进行返回.上面的例子中，我们并没有设置返回值，

	所有默认程序返回的是None。我们通过打印语句来查看一下第一次next的返回值：

	print(next(g))

	####输出结果#####
	
		None

	正如我们所说的，程序返回None。接着程序往下执行，但是并没有看到next()方法。
	为什么还会继续执行yield语句后面的代码呢？这是因为，send()方法具有两种功能：
	第一，传值，send()方法，将其携带的值传递给yield，注意，是传递给yield，而不是x,然后再将其赋值给x；
	第二，send()方法具有和next()方法一样的功能，也就是说，传值完毕后，会接着上次执行的结果继续执行，
	知道遇到yield停止。这也就为什么在调用g.send()方法后，还会打印出x的数值。
	有了上述的分析，我们可以总结出send()的两个功能：1.传值；2.next()。
	既然send()方法有和next一样的作用，那么我们可不可以这样做：

	def foo():
	    
		while True:
		        
			x = yield
		
			print("value:",x)
		   
	g = foo()
	
	g.send(1) #执行给yield传值,这样行不行呢?

	执行结果：TypeError: can not send non-None value to a just-started generator
	错误提示:不能传递一个非空值给一个未启动的生成器。
	也就是说，在一个生成器函数未启动之前，是不能传递数值进去。必须先传递一个None进去或者调用一次next(g)方法，
	才能进行传值操作。至于为什么要先传递一个None进去，可以看一下官方说法。

	Because generator-iterators begin execution at the top of the
	generator function body, there is no yield expression to receive
	a value when the generator has just been created.  Therefore,
	calling send() with a non-None argument is prohibited when the
	generator iterator has just started, and a TypeError is raised if
	this occurs (presumably due to a logic error of some kind).  Thus,
	before you can communicate with a coroutine you must first call
	next() or send(None) to advance its execution to the first yield
	expression.

	问题就来，既然在给yield传值过程中，会调用next()方法，那么是不是在调用一次函数的时候，

	是不是每次都要给它传递一个空值？有没有什么简便方法来解决這个问题呢？答案，装饰器！！看下面代码:

	def deco(func):  # 装饰器:用来开启协程
	
		def wrapper():

			res = func()

			next(res)

			return res    #返回一个已经执行了next的函数对象

		return wrapper

	@deco

	def foo():

		food_list = []

		while True:
		
			food = yield food_list    #返回添加food的列表

			food_list.append(food)

			print("elements in foodlist are:",food)

	g = foo()

	print(g.send('苹果'))

	print(g.send('香蕉'))

	print(g.send('菠萝'))

	###########输出结果为######

	elements in foodlist are: 苹果

	['苹果']

	elements in foodlist are: 香蕉
	
	['苹果', '香蕉']

	elements in foodlist are: 菠萝

	['苹果', '香蕉', '菠萝']


	这里我们要明确一点，yield的返回值和传给yield的值是两码事！！
	yield的返回值就相当于return的返回值，这个值是要被传递出去的,而send()传递的值，是要被yield接受，
	供函数内部使用的的，明确这一点很重要的。那么上面的打印，就应该打印出yield的返回值，
	而传递进去的值则本保存在一个列表中。






装饰器：


	装饰器本质上是一个Python函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外的功能，
	装饰器的返回值也是一个函数或类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、
	缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计。
	有了装饰器，我们可以抽离大量与函数功能本身无关的雷同代码到装饰器中并继续使用。概括的将，装饰器的作用
	就是为已经存在的对象添加额外的功能。


例子： 定义一个函数专门处理日志，日志处理完之后执行代码

	def use_logging(func):
	
		logging.warn("%s is running"% func.__name__)
	
		func()

	def foo():

		print('i am foo')

	use_logging(foo)


	这样做的逻辑没有问题，功能实现了，但是我们调用的时候不再试调用真正的业务逻辑函数foo，而是变成了use_logging函数
	破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个 foo 函数作为参数传递给 use_logging 函数，
	那么有没有更好的方式的呢？当然有，答案就是装饰器。


	def use_logging(func):

		def wrapper():

			logging.warn("%s is running"% func.__name__)

			return func()

		return wrapper

	def foo():
		print('i am foo')


	foo = use_logging(foo) #因为装饰器use_logging(foo)返回的函数对象wrapper,这条语句相当于foo = wrapper

	foo()                  # 执行foo()就相当于执行 wrapper()


	@语法糖

	@ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。

	def use_logging(func):

		def wrapper():
	
			logging.warn("%s is running" % func.__name__)
		
			return func()
		return wrapper
							 

	@use_logging
	def foo():	
		print("i am foo")										 
	foo()

	如上所示，有了@，我们就可以省去foo = use_logging(foo)这一句了，直接调用 foo() 即可得到想要的结果。
	装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，
	可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。



	*args、**kwargs:

	可能有人问，如果我的业务逻辑函数 foo 需要参数怎么办？比如：
	def foo(name):
	print("i am %s" % name)

	我们可以在定义 wrapper 函数的时候指定参数：

	def wrapper(name):
	        
		logging.warn("%s is running" % func.__name__)
			    
		return func(name)

	return wrapper


	这样 foo 函数定义的参数就可以定义在 wrapper 函数中。这时，又有人要问了，如果 foo 函数接收两个参数呢？

	三个参数呢？更有甚者，我可能传很多个。当装饰器不知道 foo 到底有多少个参数时，我们可以用 *args 来代替：

	def wrapper(*args):
	
		logging.warn("%s is running" % func.__name__)
			        
		return func(*args)

	return wrapper





类装饰器：

	没错，装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。

	使用类装饰器主要依靠类的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。


	class Foo(object):
		def __init__(self, func):
			self._func = func
			def __call__(self):
				print ('class decorator runing')					        
				self._func()
				print ('class decorator ending')
											 
	@Foo
	def bar():
		print ('bar')
													 
	bar()




	在python中变量不需要声明，但是使用之前必须赋值，在混合类型的表达式中，python首先将被操作

	的对象转换成其中最复杂的操作对象的类型，然后再对相同的类型的操作对象进行数字运算。

	在python3中有3种方法计算平方根：使用一个模块函数、一个表达式或一个内置函数。

	import math
	math.sprt(144)

	144**.5

	pow(144,.5)

	模块是外部组件，而内置函数位于一个隐形的命名空间内，python会自动搜索程序的变量名。

	这个命名空间对应Python3中为builtins模块（python2.6中的__builtin__）。


小数：

	from decimal import Decimal 

	printf(Decimal('0.1') + Decimal('0.1') + Decimal('0.1') -Decimal('0.3'))

	Decimal('0.0')


	decimal.getcontext().prec = 4 (设置精度，小数点后4位)


分数：

	from fractions  import Fraction

	x = Fraction(1,3)

	y = Fraction(4,6)

	printf(x + y)

	Fraction(1,1)


	print(x - y)

	Fraction(-1,3)


	print(x * y)

	Fraction(2,9)




集合：

	集合(set)，这是一些唯一的，不可变的对象的一个无序集合（collection）.


	集合对象支持与数学集合理论相对应的操作。

	要创建一个集合对象，向内置的set函数传递一个序列或其他的可迭代的对象：

	集合通过表达式操作符支持一般的数学集合运算。注意，不能在一般序列上应用这些表达式，

	必须通过序列创建集合后才能使用。

	x = set('abcde')

	y = set('bdxyz')

	print(x)

		set(['a', 'c', 'b', 'e', 'd'])

	'e' in  x
	
		True

	x - y
	
		set(['a','c','e'])

	x | y

		set(['a','c','b','d','y','x','z'])

	x & y
	
		set(['b','d'])

	x ^ y

		set(['a','c','e','y','x','z'])

	x > y ,x < y
	
		(False,False)


	除了表达式，集合对象还提供了对应这些操作的方法。


"----------------------------------------------------------------------"

					第六章   动态类型简介
	
"----------------------------------------------------------------------"

动态类型以及它提供的多态性是python语言简洁性和灵活性的基础。


静态编译类型语言：C、C++、Java，Python是动态类型模型的领域，在python中，类型是在运行过程中自动决定的，

而不是通过代码声明。这意味着没有比要声明变量，这个概念实质上对变量、对象和他们之间的关系都适用。


变量、对象和引用：

当在Python中运行赋值语句a = 3 时，即使没有告诉Python将a作为一个变量来使用，或者没有告诉a应该作为一个整数类型

对象，但一样能工作，在python语言中，这些都会以一种非常自然的方式完成，就像下面这样：

变量创建：

	一个变量（也就是变量名），就像a，当代码第一次给它赋值时就创建了它。之后的赋值将会改变已创建的比变量名的值。

	从技术上讲，Python在代码运行之前先检查变量名，可以当成是最初的赋值创建变量。

变量类型：

	变量永远不会有任何的和它关联的类型信息或约束。类型的概念是存在于对象中而不是变量名中。变量原本是通用的，它只是

	在一个特定的时间点，简单地引用了一个特定的对象而已。

变量使用：

	当变量出现在表达式中时，它会马上被当前引用的对象所代替，无论这个对象是什么类型。此外，所有的变量必须在使用前明确地

	赋值，使用未赋值的变量会产生错误。

总而言之，变量在赋值的时候才创建，它可以引用任何类型的对象，并且必须在引用之前赋值。这意味着，不需要通过脚本声明所要

使用的名字，但是，必须初始化名字然后才能更新他们，例如：必须把计数器初始化为0，然后才能增加它。


对于动态类型应清楚的将变量名和对象划分开来

	例如： a = 3

	Python 将会执行三个不同步骤去完成这个请求，这个步骤反映了Python语言中的所有赋值操作：

	1、创建一个对象来代表值3
	
	2、创建一个比变量a,如果它还没有创建的话

	3、将变量与新的对象3相连接

变量和对象保存在内存中不同的部分，并通过连接相关联，变量总是链接到对象。

在运行a = 3后，变量a变成对象3的一个引用。在内部，比变量事实上是到对象内存空间的一个指针。

在python中从变量到对象的连接称为引用，也就是说，引用是一种关系，以内存中的指针的形式实现。

一旦变量被使用，Python自动跟随这个变量到对象的连接。
	
	变量是一个系统表的元素，拥有指向对象的连接的空间。

	对象是分配的一块内存，有足够的空间去代表它们所代表的值。

	引用是自动形成的从变量到对象的指针。

每一个对象都有两个标准的头部信息：一个类型标志符去标识这个对象的类型，以及一个引用的计数器，用来决定是不是

可以回收这个对象。


类型属于对象，而不是变量：

共享引用：

	a = 3
	b = a
	变量a和b都引用了相同的对象（也就是指向了相同的内存空间）。在python中叫共享引用，多个变量名引用了同一个对象。

	a = 3
	b = a
	a = 'spam'

	变量a引用了由常量表达式'spam'所创建的新对象，但是变量b仍然引用原始对象3.
	因为这个赋值运算改变的不是对象3，仅仅是变量a的引用。
	
	a = 3
	b = a 
	a = a + 2

	给一个变量赋一个新的值，并不是替换了原始的对象，而是让这个变量去引用完全不同的一个对象。
	实际的效果就是对一个变量赋值。仅仅是影响那个被赋值的变量。

共享引用和相等：
	
	由于Python的引用模型，在Python中有两种不同的方法去检查是否相等，例如：
	
	L = [1,2,3]
	M = L
	pirnt(L == M)
		True
	print(L is M)
		True

	第一种技术"==操作符"，测试两个被引用的对象是否有相同的值。这种方法往往在python中用作相等的检查。
	第二种方法"is操作符"，是检查对象的统一性。如果两个变量名精确地指向同一个对象，它会返回True,这是一种更严格形式的相等测试。

	实际上，is只是比较实现引用的指针，所以如果必要的话是代码中检测共享引用的一种办法。如果变量名引用值相等，
	但是是不同的对象，它的返回值将是Flase

	L = [1,2,3]
	M = [1,2,3]
	pirnt(L == M)
		True
	print(L is M)
		False

在sys模块中getrefcount函数返回对象引用的次数。例如查询整数对象1时：
	
	import sys
	sys.getrefcount(1)


"-----------------------------------------------------------------------------"

				第七章          字符串
		
"-----------------------------------------------------------------------------"

在python中，字符串变成了一个强大的处理工具集，没有单个字符的这种类型。

单双引号字符串是一样的：

	在python字符串中，单引号和双引号可以互换。两种形式能够使用是因为你不使用反斜杠转义字符就可以实现在
	一个字符串中包含其余种类的引号，即是你可以在一个双引号中嵌入一个单引号，反之亦然
	str1 = 'knight"s'
	str2 = "knight's"

	此外，python自动在任意的表达式中合并相邻的字符串常量，尽管可以简单的在他们之间增加"+"操作符来明确的表示这是一个合并操作。
	（这种形式放在园括号中，就可以允许跨越多行）

在Python中，零（空）字符不会像C语言那样去结束一个字符串。相反，Python在内存中保持了整个字符串的长度和文本。

	title = "Meaning "  'of ' "Life "	
	print(title)
		'Meaning of Life'
	
	注意，在这些字符串中间增加逗号会创建一个元组，而不是一个字符串。
	事实上，Python中没有字符会结束一个字符串。


raw字符抑制转义：

	如果字母r(大写或小写)出现在字符串的第一个引号前面，它将关闭转义机制。
	注意：尽管有用，但一个raw字符串也不能以单个的反斜杠结尾，因为，反斜杠会转义后续引用的字符，仍然必须转义外围引号
	字符以将其嵌入到该字符串中，也就是说，r"...\" 不是一个有效的字符串常量，一个raw字符串不能以奇数个反斜杠结束。


三重引号编写多行字符串块：

	python 把所有在三重引号之内的文本收集到一个单独的多行字符串中，并在代码折行处嵌入了换行字符(\n).
	三重引号字符串常用于文档字符串，当它出现在文件的特定地点时，被当作注释一样的字符串常量。

基本操作：

	与C字符数组不同的是，使用python字符串时，不用分配或管理存储数组，只要在需要时创建字符串对象，
	让python去管理底层的内存空间。
	pyhton在执行"+","*"操作符是能根据数字和字符串正确的执行时因为它知道操作对象的类型。
	python不允许你在"+"表达式中混数字和字符串：例如"abc" + 9 
	字符串定义为字符的有序集合，所以我们能够通过其位置获得他们的元素。

索引和分片：
	
	与C语言一样，Python偏移量从0开始的，并比字符串的长度小1.与c语言不同，
	python支持类似在字符串中使用负偏移这样的方法从序列中获取元素。
	一个负偏移与这个字符串的长度相加后得到这个字符串的正的偏移量。
	
	当使用一对以冒号的偏移量来索引字符串的序列对象时，Python将返回一个新的对象，其中包含了以这对偏移
	所标识的连续的内容。左边的偏移为下边界（包含下边界在内），而右边的为上边界（不包含上边界在内）的所有元素的新的对象。
	如果被省略，上、下边界的默认值分别为0和分片的对象的长度。


扩展分片：第三个限制值

	X[I:J:K]表示：索引X对象中的元素，从偏移为I直到偏移为J-1,每隔K元素索引一次。
	第三个限制为-K，默认为1，这就是通常一个切片中从左至右提取每一个元素的原因。

	负数作为步进。例如分片表达式"Hello" [::-1]返回新的字符串"olleH",
	步进-1表示分片将从右至左进行而不是从左到右。实际效果就是讲序列进行反转。

	通过一个负数步进，两个边界的意义实际上进行了反转。也就是说，
	分片s[5:1:-1]以反转的顺序取从2到5的元素。



字符串转换工具：

	Python的设计座右铭之一就是：拒绝猜的诱惑。
	int函数将字符串转换成数字，而str函数将数字转换成字符串表达形式。float把字符串转换成浮点数。
	int,float只能对数字字符串进行转换。


字符串代码转换：

	单个字符串通过内置ord函数转换成对应的ASCII码，这个函数实际返回是这个字符在内存中对应的字符的二进制。
	而chr函数将会执行相反的操作，获取的ASCII码转化为对应的字符：

	>>> ord('s')
		115
	>>>chr(115)
		's'

字符串方法实例：修改字符串：

	内置list函数（或一个对象构造函数调用）以任意序列中的元素创立一个新的列表。

	>>>s = 'spammy'
	>>>list(s)
		['s','p','a','m','m','y']

	修改列表之后，需要将其变回一个字符串，可以用字符串方法join将列表"合成"一个字符串。
	>>>s = ''.join(l)
	spammy


	字符串方法实例：文本解析
	>>> line='aaa bbb ccc'
	>>>cols = line.split()
		['aaa','bbb','ccc']
	字符串的split方法将一个字符串分割为一个子字符串的列表，以分割符字符串为标准。

字符串格式化表达式，python中的字符串格式化可以两种形式实现：
	
	字符串格式化表达式：
		基于c语言的"printf"模型。

	字符串格式化方法调用：
		python中独有的方法，和字符串格式化表达式功能很大重叠。

	python在对字符串操作的时候定义了%二进制操作符（%在数字中是除法取余数的操作符），
	当应用到字符串上，%提供了简单的方法对字符串的值进行格式化，这一操作取决于格式化定义的字符串。
	
	格式化字符串：
		1.在%操作符的左侧放置一个需要进行格式化的字符串，这个字符串带有一个或多个嵌入的转换目标，都以%开头（例如%d）

		2.在%操作符的右侧放置一个（或多个，嵌入到元组中）对象，这些对象将会插入到左侧想让python
		  进行格式化字符串的一个（或多个）转换目标的位置上。
	例如：
		>>> 'That is %d %s bird!' % (1,'dead')
		   	That is 1 dead bird!
		     
		>>> exclamation = "Ni"
		>>> "The knights who say %s!" % exclamation
			The knights who say Ni!

		>>> "%s ---%s---%s" %(42,3.14159,[1,2,3])
			'42 ---3.14.159---[1,2,3]'

	一个整数，一个浮点数和一个列表对象，但是目标左侧都是%s,这就表示要把他们转换成字符串。
	由于每一个对象的每个类型都可以转换为字符串，每一个与%s一同参与操作的对象类型都可以转换代码。
	另外，格式化总会返回一个新的字符串作为结果而不是对左侧的字符串进行修改。


基于字典的字符串格式化：

	字符串的格式化同时也允许左边的转换目标来引用右边字典中的键来提取对应的值。

	>>>"%(n)d %(x)s" %{"n":1,"x":"spam"}
		'1 spam'

字符串格式化调用方法：format方法

	字符串对象的format方法使用主体字符串作为模板，并且接受任意多个表示将要根据模板替换的值的参数。
	在主体字符串中，花括号通过位置（例如{1}）或关键字指出替换目标及将要插入的参数。

	例如：
	>>> template = '{0},{1} and {2}'
	>>> template.format('spam','ham','eggs')	
		'spam,ham and eggs'

	>>>template = '{motto},{pork} and {food}'
	>>>template.format(motto='spam',pork='ham',food='eggs')
		'spam,ham and eggs'

	就像%表达式和其他字符串方法一样，format创建并返回一个新的字符串对象。

添加键、属性和偏移量：
	
	像%格式化表达式一样，格式化调用可以变的更复杂以支持更多高级用途。
	>>>import sys
	>>> 'My {config[spam]} runs {sys.platform}'.format(sys=sys,config={'spam':'laptop'})
		'My laptop runs linux'

	添加具体格式化：
	
	对于格式化方法，我们在替换目标的标识之后使用一个冒号，后面跟着可以指定字段大小，
	对齐方式和一个特定类型编码的格式化声明。如下是可以在一个格式字符串中作为替代目标出现的形式化结构：

	{fieldanme!conversionflag:formatspec}
	
	在这个替代目标语法中:
		
		fieldname是指定参数的一个数字或关键字，后面跟着可选的".name"或"[index]"成分引用。
		conversionflag可以是r、s、或者a分别是在该值上对repr、str或ascii内置函数的一次调用。
		formatspec指定了如何表示该值，包括字段宽度、对齐方式、补零、小数点精度等
	例子：
	>>>'{0:10} = {1:10}'.format('spam',123.4567)
		'spam       =   123.4567'
	>>>'{0:.2f}'.format(1/3.0)
		'0.33'
通常意义下的类型分类：
	
	数字（整数、浮点数、二进制、分数等）
		支持加法和乘法等。

	序列（字符串、列表、元组）
		支持索引、分片和合并等
		
		对于任意的序列对象X 和 Y：
		X + Y : 将会创建一个包含了两个操作对象的新的序列对象。
		X * N : 将会创建一个包含操作对象X内容N份拷贝的新的序列对象。
		
	映射(字典)
		支持通过键的索引等。


	可变类型（列表、字典、可变集合），支持原处修改
	不可变类型（数字、字符串、元组、不可变集合），不支持在原处修改。


字符串find方法能用于搜索列表吗？

	不行，因为方法是类型特定的，只能用于单一数据类型上。
	像X+Y这样的表达式和len(X)这样的内置函数是通用的，可以用在多种类型上。


在python，怎么修改字符串？
	
	字符串无法被修改，字符串是不可改变的。但是可以通过切片运算、合并、格式化、方法调用创建新的字符串，
	将结果赋值给最初的变量名，从而达到相似的效果。





"---------------------------------------------------------------------------------------------------"

				 第八章 列表与字典

"---------------------------------------------------------------------------------------------------"

python 列表：

	任意对象的有序集合
	通过偏移读取
	可变长度、异构以及任意嵌套（异构：可以包含任何类型的对象而不仅仅是包含单个字符串。嵌套：创建列表的子列表的子列表）
	属于可变序列的分类
	对象引用数组(从技术上来讲，Python列表包含了零个或多个其他对象的引用)


常用列表常量和操作：

	操作：           解释

	L = []           一个空的列表
	
	L = [0,1,2,3]    四项：索引为0到3

	L = ['abc',['def','ghi']]   嵌套子列表


	L = list('spam')     可迭代项目的列表

	L = list(range(-4,4)) 连续整数的列表

	L[i]              索引

	L[i][j]           索引的索引

	L[i:j]            分片

	len(L)            求长度

	L1 + L2           合并(同种类型)

	L * 3             重复

	for x in L:print(x) 迭代

	3 in  L           成员关系


方法

	L.append(4)       增长

	L.extend([5,6,7]) 扩展

	L.insert(I,X)     插入

	L.index(1)        搜索

	L.count(X)        元素个数

	L.sort()          排序（从小到大）

	L.reverse()       反转


语句

	del L[k]          删除

	del L[i:j]        删除

方法：

	L.pop()           删除（最后一个元素）

	L.remove(2)       删除

	L[i:j] =[]        删除

	L[i] = 1          索引赋值

	L[i:j] =[4,5,6]   赋值

	L = [x**2 for x in range(5)]  列表解析

	list(map(ord,'spam'))


	我们这里讨论的原处修改操作适用于可变对象：无论如何也不能在字符串、元组上修改。

	可变性是每个对象类型的固有属性。



字典(dictionary)：

	字典也许是Python之中最灵活的内置数据结构类型。如果列表看做是有序的对象集合，那么字典就是无序的对象集合。

	他们主要区别是：字典当中的元素是通过键来存取，而不是通过偏移存取。


python字典的主要属性：

	通过键而不是偏移量来读取：（字典有时叫关联数组或者散列表(hash),通过键将一系列值联系起来）

	任意对象的无序集合:(与列表不同，保存在字典中的项并没有特定的顺序，各项随机排序，键提供了字典项的象征性位置)

	可变长、异构、任意嵌套：

	属于可变映射类型：

	对象引用表（散列表）：字典和列表一样，字典存储的是对象引用。


常见字典常量和操作：

	操作                         解释

	D = {}                      空字典

	D = {'spam':2,'eggs':2}     两项目字典

		D['eggs']

	D = {'food':{'ham':1,'egg':2}} 嵌套

		D['food']['ham']

	D = dict.fromkeys(['a','b']) 其他构造技术

	D = dict(zip(keyslist,valslist)) 关键字、对应的对、键列表

	D = dict(name = 'Bob',age = 42) 创建字典
	
		{'name': 'Bob', 'age': 42}

	'eggs' in D                  成员关系：键存在测试
	
		False

	D.keys()                     获取字典的键

		dict_keys(['name', 'age'])

	D.values()                   获取字典的值

		dict_values(['Bob', 42])

	D.items()                    获取键+值

		dict_items([('name', 'Bob'), ('age', 42)])

	D.copy()                      副本

	D.get(key)                 获取某个键的值

	D.update(D2)               合并

	D.pop(key)                 删除

	len(D)                     长度（存储的元素的数目）

	D[key] = 42                新增/修改键

	del D[key]                 根据键删除条目

	list(D.keys())             字典视图(返回键组成的列表,python3.0)

	D1.keys()&D2.keys()        查询相同的键

	D = {x : x*2 for x in range(10)} 字典解析（python3.0）


	注意：字典内键由左至右的次序几乎总是和原先输入的顺序不同。
	这样设计目的是快速执行键查找（散列查找），键在内存中随机设定。

	与列表相同，字典中已存在的索引赋值改变索引关联值，不同的是，每当对新字典键赋值（之前不存在的键），
	会在字典中生成一个新的元素，但是列表不允许，python将会超出列表末尾的偏移视为越界并报错。想扩充列表
	可以用append方法或分片赋值实现。


	字典并非序列，你无法像字符串和列表那样直接通过一个for语句迭代他们，但是，如果需要遍历各项内容：调用字典的
	keys方法，返回经过排列之后所有键的列表，再用for循环进行迭代。

	实际上，python也可以遍历字典的键列表，而并不是多数for循环调用keys方法。就任何字典而言，写成for key in D:
	和写成key in D.keys():效果是一样的。这其实是迭代器能够允许in成缘关系操作符用于字典的另一个实例。


字典用法注意事项：

	序列运算无效：字典是映射不是序列。

	对新索引赋值会添加项： 会生产新键

	键不一定总是字符串：任何不可变对象都可以做键（数字、字符串、元组）
		
		Matrix = {(2,3,4):88,(7,8,9):99}
	

创建字典的方法：

	1、D = {'name':'mel','age':45}

	2、D = {}
		D['name'] ='mel'
		D['age'] = 45

	3、D = dict(name = 'mel',age = 45)

	4、D = dict([('name','mel'),('age',45)])


	这四种形式都会创建相同的两键字典，但是不同的条件下使用：

		如果你可以事先拼出整个字典，那么第一种方便

		如果你需要一次动态的建立字典的一个字段，第二种合适

		第三种关键字所需的代码比常量少，但是键必须都是字符串才行

		如果你需要在程序运行时把键和值逐步建成序列，最后一种比较有用。

	如果所有键的值都相同，你可以用特殊形式对字典初始化---简单地传入一个键列表，以及初始值。

	5、D = dict.fromkeys(['a','b'],0)
			{'a':0,'b':0}

	6、字典解析表达式（python3）


Python3.0 中字典变化：

	1、支持字典解析表达式，这是列表和集合解析的"近亲"

	2、对于D.key、D.values和D.items方法，返回可迭代的视图，而不是列表

		如果想要应用列表操作或显示他们的值，必须通过内置函数list来运行这3个方法：

		D= dict(a=1,b=2,c=3)
		
			{'a': 1, 'b': 2, 'c': 3}

		K = D.keys()

			dict_keys(['a', 'b', 'c'])
		
		K[0]
			TypeError: 'dict_keys' object does not support indexing

		list(K)
			['a', 'b', 'c']




	3、由于前面一点，需要新的编码方式通过排序键来遍历
	
		D = {'a':1,'b':2,'c':3}
		
		不可以：
		Ks = D.keys()
		ks.sort()  出错 AttributeError:'dict_keys' object has no attribute 'sort'

		可以：
		Ks = list(Ks)
		Ks.sort()

		可以：
		Ks = D.keys()
		for k in sorted(Ks):print(k,D[k])   
		
		可以：
		for k in sorted(D):print(k,D[k])


	4、不再直接支持相对大小比较，取而代之的是手动比较

		通过手动比较排序后的键列表来比较

		sorted(D1.items()) < sorted(D2.items)

		python3中字典相等性测试仍然有效。


	5、不再有D.has_key方法，相反，使用in成员关系测试




	
"--------------------------------------------------------------------------"

					第九章 元组、文件及其他

"-------------------------------------------------------------------------"

元组：

元组属性：

	任意对象的有序集合

	通过偏移存取

	属性不可变序列类型

	固定长度、异构、任意嵌套

	对象引用的数组


常见元组常量和运算：

	运算                         解释

	()                          空元组

	T=(0,)                      单个元素的元组（非表达式）
	
		因为圆括号也可以把表达式括起来，如果圆括号里是单一对象是元组对象而不是简单表达式需特别说明
		如果想得到一个元组，只要在一个元素后，关闭括号之前加一个逗号就可以了。

	x = (40)	
		40
	
	y = (40,)
		(40,)


	T=(0,'Ni',1.2,3)            四个元素的元组

	T= 0,'Ni',1,2,3             四个元素的元组（和前列相同）
	
	在不会引起语法冲突的情况下，Python允许忽略元组的圆括号。


	T=('abc',('def','ghi'))     嵌套元组

	T=tuple('spam')             一个可迭代对象的项的元组
		('s', 'p', 'a', 'm')


	T[i]                        索引

	T[i][j]                     索引的索引

	T[i:j]                      分片

	len(T)                      长度

	T1 + T2                     合并

	T*3                         重复

	for x in T:print(x)         迭代

	'spam' in T                 成员关系

	T.index('Ni')               搜索，元素所在元组中的位置

	T.count('Ni')               计数


	元组操作和字符串以及列表是一致的，值得注意的"+","*"以及分片操作应用元组时返回一个新元组
	元组不提供字符串、列表、字典中的方法。如果想对元组排序，通常先转换其他类型。或者使用新的
	sorted内置方法，它接受任何序列对象：

	T =('cc','aa','dd','bb')
	temp = list(T)
	temp.sort()
	T = tuple(temp)

	sorted(T)


	为什么有了列表还要元组：

		元组是不可变类型提供了某种完整性，这样可以确保元组在程序中不会被另一个引用修改，而列表没有这个的保证。
		列表是定序集合的选择工具，可能需要进行修改，而元组能够处理其他固定关系的情况。


文件：

	我们讲文件主要是内置对象类型提供了一种可以存取python程序内部文件的方法。简而言之，内置open函数会创建
	一个python文件对象，可以作为计算机上一个文件链接。调用open之后，你可以通过返回的文件对象的方法来读写
	相关外部文件。


常见文件运算

	操作                                    解释
	
	这里的输入输出是相对程序而言的，而不是外部文件。
	
	
	output = open(r'C:\spam','w')           创建输出文件（'w'是指写入）
	input = open('data','r')		创建输入文件('r'是指读写)           
	input = open('data')                    与上一行相同（'r'是默认值）
	open('f.txt',encoding='latin-1')        python3.0 Unicode文本文件（str字符串）
	open('f.bin','rb')                      python3.0 二进制byte文件  (byte字符串)

	aString = input.read()                  把整个文件读进单一字符串
	aString = input.read(N)			读取之后N个字节到一个字符串
	aString = input.readline()              读取下一行（包括行末标识符）到一个字符串
	aList   = input.readlines()             读取正个文件到字符串列表
	
	output.write(aString)                   写入字节字符串到文件
	output.writelines(aList)                把列表内的所有字符串写入文件

	output.close()                          手动关闭（当文件收集完成时会替你关闭文件）

	output.flush()                          把输出缓冲区刷到硬盘中，但不会关闭文件

	anyFile.seek(N)                         修改文件位置到偏移量N处以便进行下一步操作

	for line in open('data'):use line       文件迭代器一行一行读取

打开文件：

	处理模式：

		'r':代表输入打开文件（默认值） 
		'w'：输出生成并打开文件（文件不存在生成一个文件）
		'a'：代表在文件尾部追加内容而打开文件。

	b:在处理模式字符串尾部加上b可以进行二进制数据处理
	+:加上"+"意味着同时为输入和输出打开文件

	要打开的两个参数必须是python字符串，第三个参数是可选的，它能够控制输出缓存“传入"0"输出无缓存。


使用文件：

	python程序中的文本文件都采用字符串形式。读取文件时返回字符串形式的文本，文本作为字符串传递给write方法。

基础用法提示：

	文件迭代器是最好用的读取行工具

	内容是字符串，不是对象

	close是通常选项

	文件是缓冲的并且是可查找的


实际应用中的文件:

	注意：readline如果调用返回一个空字符串。这是python文件方法告诉我们已经达到文件底部。
	文件的空行是含有换行符字符串（'\n'）,而不是空字符串。看一下交互模式会话：

	myfile = open('/home/zhangkun/myfile.txt','w')
	myfile.write('hello text file\n')
	myfile.write('\n')
	myfile.write('\n')
	myfile.write('aaaaaaaaaaaaaaa\n')
	myfile.close()


	myfile = open('/home/zhangkun/myfile.txt','r')
	myfile.readline()
		'hello text file\n'
	myfile.readline()
		'\n'
	myfile.readline()
		'\n'
	myfile.readline()
		'aaaaaaaaaaaaaaa\n'
	myfile.readline()
		''
	注意：写入方法不会为我们添加行终止符('\n'),所以写入的时候程序必须包含它来严格地终止行。


python 3.0 中的文本和二进制文件：

	文件类型有open的第二个参数决定，模式字符串包含一个"b"表示二进制。python支持文本和二进制,
	但python3中，二者有区别：

		文本文件把内容表示为常规的str字符串，自动执行Unicode编码和解码，并且默认执行行末行转换。

		二进制文件把内容表示为一个特殊的bytes字符串类型，并且允许程序不修改地访问文件内容。


在文件中存储并解析python对象：

	注意：我们必须在写入的时候把对象转换成字符串，写入方法不会自动地替我们做任何像字符串格式转换的工作。

	x,y,z = 43,44,45
	s = 'spam'
	D = {'a':1,'b':2}
	L = [1,2,3]
	
	F = open('/home/zhangkun/myfile.txt','w')
	F.write(s+'\n')
	F.write('%s,%s,%s\n'%(x,y,z))
	F.write(str(L) + '$' +str(D)+'\n')
	F.close()


	chars = open('/home/zhangkun/myfile.txt','r').read()
		"spam\n43,44,45\n[1, 2, 3]${'a': 1, 'b': 2}\n"
	
	我们不得不使用转换工具，把文本文件中的字符串转换成真正的python对象。

	F = open('/home/zhangkun/myfile.txt','r')
	line = F.readline()
		'spam\n'
	line.rstrip() 
		'spam'
	
	使用字符串rstrip方法去掉多余的行终止符。

	想转换文件第三行所存储的列表和字典，可以使用eval内置函数，eval能够吧字符串当作可执行程序代码。

	line = F.readline()
		"[1, 2, 3]${'a': 1, 'b': 2}\n"
	parts = line.split('$')
		['[1, 2, 3]', "{'a': 1, 'b': 2}\n"]
	eval[parts[0]]
		[1, 2, 3]
	eval(parts[1])
		{'a': 1, 'b': 2}
	objects = [eval(p) for p in parts]
	objects
		[[1, 2, 3], {'a': 1, 'b': 2}]


用pickle存储python的原生对象

	pickle模块能够让我们直接在文件中存储几乎任何python对象的高级工具，也并不要求我们把字符串转换来转换去。
	它就像是超级通用的数据格式化和解析工具。例如，想在文件中存储字典

	存:
	D = {'a':1,'b':2}
	F = open('/home/zhangkun/myfile.pkl','wb')
	import pickle
	pickle.dump(D,F)
	F.close()

	
	取：
	F = open('/home/zhangkun/myfile.pkl','rb')
	E = pickle.load(F)
		{'a': 1, 'b': 2}

	pickle模块执行所谓的对象序列化，也就是对象和字节字符串之间的相互转换。
	open('/home/zhangkun/myfile.pkl','rb').read()
		b'\x80\x03}q\x00(X\x01\x00\x00\x00aq\x01K\x01X\x01\x00\x00\x00bq\x02K\x02u.'
	
	我们以二进制模式打开用来存储pickle化的对象的文件，二进制模式是必须的，因为pickle程序创建和使用一个
	bytes字符串对象，这些对象意味着二进制文件。

	F = open('/home/zhangkun/myfile.pkl','w')
	pickle.dump(D,F)
		TypeError: write() argument must be str, not bytes



文件山下文管理器：

	文件的上下文管理器比文件自身多了一个异常处理功能，它允许我们把文件代码包装到一个逻辑层，以确保退出后
	可自动关闭文件，而不是依赖垃圾收集。

	with open(r'C:\misc\data.txt') as myfile:
		for line in myfile:
			...use line here...

	
	myfile = open(r'C:\misc\data.txt')
	try:
		for line in myfile:
			...use line here...
	finally:
		myfile.close()


其他文件工具:

	标准流

	os 模块中的描述文件

	sockets 、pipes和FIFO文件

	通过键来存取的文件

	shell 命令流




重访类型分类:

	python 核心内置类型，共有的一些属性，牢记下面几点：

	对象根据分类来共享操作：例如，字符串、列表、元组都共享诸如合并、长度和索引等序列操作。

	只有可变对象（列表，字典，集合）可以原处修改，不能修改数字、字符串、元组

	文件导出的唯一方法，因此可变性并不真的适用于它们--当处理文件的时候。它们的状态可能会修改，但是这与
	python的核心类型可变性限制不完全相同。

	"数字"包含了所有数字类型:整数、浮点数、复数、小数、分数。

	集合类似域一个无值的字典的键，但是，它们不能映射值，并且没有顺序；因此，集合不是一个映射类型或序列类型、
	frozenset是集合的一个不可变的版本。

	除了类型分类操作。所有的类型都有课调用的方法，这些方法通常特定于它们的类型。


	对象类型      分类        是否可变
	数字          数值          否
	字符串        序列          否
	列表          序列          是
	字典          映射          是
	元组          序列          否
	文件          扩展          N/A
	sets          集合          是
	frozenset     集合          否
	bytearray     序列          是


	

引用和拷贝：

	你可以在程序范围内任何地方传递大型对象而不必在途中产生拷贝，然而，如果需要拷贝，那么可以明确要求：

	没有限制条件的分片表达式(L[:])能够复制序列。

	字典copy方法（X.copy()）能够复制字典。

	有些内置函数（list）能够生成拷贝（list(L)）
	
	copy标准库模块能够生成完整拷贝。

	拷贝需要注意的是：无条件值的分片以及字典copy方法只能做顶层复制，也就是说。不能够复制嵌套的数据结构（如果有）
	如果需要深层拷贝，使用标准copy模块，包括import copy语句，并编辑X = copy.deepcopy(Y)对任意嵌套对象Y做完整复制。
	
	
比较、相等性和真值：

一般来说，python中不同的类型的比较方法如下：
	
	数字通过相对大小进行比较。
	字符串是按照字典顺序，换一个字符接一个字符的对比进行比较("abc"<"ac")
	列表和元组从左到右对每部分的内容进行比较。
	字典通过排序之后的(键、值)列表进行比较。


python 中的真和假的含义：

	真和假的概念是python中每个对象的固有属性：每个对象不是真就是假：
	
		数字如果非零，则为真
		其他对象如果非空，则为真

	对象	     	值	
	"spam"  	True

	""       	False

	[]       	False

	{}       	False

	1        	True

	0.0      	False

	None     	False


None 对象：

	python还有一个特殊对象：None，总是被认为假，这是python中一种特殊数据类型的唯一值，
	一般都起到一个空的占位符作用，与C语言的NULL指针类似。

	记住：None不是意味着"未定义"，也就是说，None是某些内容，而不是没有内容（尽管起名字没有内容），
	他是一个真正的对象，并且有一块内存，有python给定的一个内置名称。


bool类型：

	python的布尔类型bool，只不过是扩展了python中真、假的概念。这样设计是为了让真值更为明显。
	当明确地用在真值测试时，Ture和False这些文字就变成1和0，但它们使得程序员意图更明确。
	交互模式下的布尔测试的结果打印成True和Flase的字样，而不是0和1，以使得程序的结果更明确。

Type 对象:

	python系统中的任何东西都是对象类型，而且可以有python程序来处理。
	事实上，即使是类型本身在python中也是对象类型。
	严格来说，内置函数type(x)能够返回对象X的类型对象。
	有关类型名称需要提醒一下：python 2.2的每个核心类型都有个新的内置名来支持面向对象子类的类型定制：
	dict、list、str、tuple、int、float、complex、byte、set和file。
	调用这些名称事实上是对这些对象构造函数调用，而不仅仅是转换函数。

	目前，python的类型也可以再分为子类，一般都建议使用isinstance


赋值生成引用，而不是拷贝：如下列：

	L = [1,2,3]
	M = ['X',L,'Y']
		['X', [1, 2, 3], 'Y']

	L[1] = 0

	M
		['X', [1, 0, 3], 'Y']

	如果不是这样，你可以明确地对它们进行拷贝以避免对象共享。就列表而言，你总能使用无限制条件的分片生产一个高级拷贝。
	
	L = [1,2,3]
	M = ['X',L[:],'Y']

	L[1]=0

	L
		[1,0,3]
	M:
		['X',L[1,2,3],'Y']


重复能够增加层次深度：

序列重复就好像多次将一个序列加到自己身上。下面例子中X赋值给重复四次的L,而Y赋值给包含重复四次的L的列表：

	L = [4,5,6]

	X = L * 4
		[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]

	Y = [L]*4
		[[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]

	L[1] = 0

	X
		[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]

	Y
		[[4, 0, 6], [4, 0, 6], [4, 0, 6], [4, 0, 6]]
	

留意循环数据结构：

	如果遇到一个复合对象包含指向自身的引用，就称之为循环对象。无论何时python在对象中检查到循环，
	都会打印成[...],而不会无限循环

	L = ['grail']
	L.append(L)
	
	L
	['grail',[...]]

	除了要了解方括号括起来的三个点代表对象中带有循环之外，循环结构可能导致程序陷入无法预期的循环当中。



不可变类型不可以在原处修改

	不可以在实地改变不可变对象，如果需要的话，你得通过分片、合并等操作来创建一个新对象，再向后赋值给原引用。
	T = (1,2,3)

	T[2]  = 4      error

	T = T[:2] + (4,)

	因为无法修改，就不会产生列表那种副作用。


本章小结：

	内置len函数会回传python中任何容器对象的长度(所含元素的数目)，这个是内置函数，而不是方法。
	内置函数和表达式可以跨越多种对象类型，方法特定于一种单一的对象类型，尽管通过某些方式可以
	在多种类型上使用(例如：索引在列表和元组中都有效)。

	pickle模块可以用于把python对象储存在文件中，而不用刻意转成字符串。struct模块也是相关的，但是，
	那是要把数据打包成为二进制格式，从而保存在文件中。

	分号用作语句分隔符，以把多条语句压缩成单独一行，表达式之间的逗号通常用来构建元组，即便没有包围圆括号。




"=============================================================="

			第三部分   语句和语法

"=============================================================="


"--------------------------------------------------------------"
	
			第十章 Python 语法简介					

"--------------------------------------------------------------"

	1、程序由模块构成
	2、模块包含语句
	3、语句包含表达式
	4、表达式建立并处理对象

python的语法实质上是由语句和表达式组成的。表达式处理对象并嵌套在语句中。语句编码实现程序操作中更大的逻辑关系。
此外语句还是对象生产的地方。

	python 语句：
		语句                    角色                              例子
		nonlocal              namespaces(3.0+命名空间)         def function():
										nonlocal x;x ='new'
		raise                 触发异常                         raise EndSearch(location)
		assert                调试检查                         assert x>y,'x too small'
		with/as               环境管理器                       with open('data') as myfile:
		del                   删除引用                         del data[k]


	从技术上讲：python3.0中 print 不是一个保留字，也不是一个语句，而是一个内置函数调用；
	由于它几乎总是作为一条表达式语句运行，通常看作是一条语句类型。

	yield 实际上是一个表达式，而不是一条语句。

python语法增加了什么：

	python中新的语法成分是冒号(:) 所有的python复合语句都要相同的一般形式，也就是以冒号结尾，
	首行下一行的代码往往按缩进格式书写。

python语法删除了什么：
	
	虽然python需要额外的分号(;)，但是你必须在类C语言程序中加入，而通常不需要在python中加入的语法成分却有三项。
	
	1、括号是可选的
		if x < y
	2、终止行就是终止语句
		不会出现在python中第二个重要的语法成分是分号。
		x = 1
	3、缩进的结束就是代码块的结束
		也就是你不要刻意在程序代码中输入任何语法上用来标明嵌套代码块的开头和结尾的东西。
		在python中，我们一致把嵌套块里的语句向右缩进相同的距离，python能够使用语句的实际缩进来确定代码块的开头和结尾。
		
		if x > y:
			x = 1
			y = 2
		
		所谓的缩进，是指这里的两个嵌套语句至左侧的所有空白。
		语法规则是给定的嵌套块中，所有语句必须缩进相同的距离。


为什么使用缩进语法：
	
	缩进语法使python程序员写出统一，整齐并具有可读性的主要方式之一。具备了重用性和可维护性。

几个特殊实例：

在python的语法模型中：

	一行的结束就是终止该行语句
	嵌套语句是代码块并且与实际的缩进相关（没有大括号）

语句规则的特殊情况：

	虽然语句一般都是一行一个，但是python中也有可能出现一行挤进多个语句的情况，这时它们有分号隔开：
	a = 1; b = 2;print(a+b)
	这是python中唯一需要分号的地方--作为语句定位符，不过，只有当摆在一起的语句本身不是复合语句才行。
	
	语句的另一个特殊规则基本上是相反的--可以让一个语句的范围横跨多行。为了实现这个操作，你只需要
	用一对括号把语句括起来：括号(),方括号：[],或者字典大括号{}.任何括在符号里的程序代码都可以跨好几行。
	语句一直运行，知道python遇到包含闭和括号那一行。
		mlist = [111,
			 222,
			 333]
			 
		x = (a + b +
			c + d)
			
	复合语句的主体可以出现在python的首行冒号之后
		if x > y : print(x)
	这样我们能编译单行if语句、单行循环等。不过，只有当复合语句本身不包含任何复合语句的时候，才能这样做。

		
用try语句处理错误：
	
	while True:
		reply = input('Enter text:')
		if reply == 'stop':break
		try:
			num = int(reply)
		except:
			print('Bad'*8)
		else:
			print(int(reply)**2)
	print('Bye')



"----------------------------------------------------------------------"

			赋值、表达式和打印
	
"----------------------------------------------------------------------"

赋值语句：
	
	Python的赋值语句把对象赋给一个名称。赋值语句有如下特性：

	1、赋值语句建立对象引用值。
		python赋值语句会把对象引用值存储在变量名或数据结构的元素内，赋值语句总是建立对象的引用，而不是赋值对象。
		因此，python对象更像是指针，而不是数据存储区域。
	
	2、变量名在首次赋值时会被创建。
		一旦赋值了，每当这个变量名出现在表达式时，就会被其所引用值取代。

	3、变量名在引用前必须先赋值。
	
	4、执行隐式赋值的一些操作。
		python中赋值语句会在许多情况下使用，例如：模块导入、函数和类定义for循环变量以及函数参数全都是隐式赋值运算。
		因为，赋值语句在任何出现的地方的工作原理都相同，所有的这些环境都是在运行时把变量名和对象的引用值绑定起来而已。


	赋值语句的形式：

	运算                                   解释
	spam = "Spam"                        基本形式
	spam,ham = 'yum','YUM'               元组赋值运算（位置性）
	[spam,ham] = ['yum','YUM']           列表赋值运算（位置性）
	a,b,c,d = 'apam'                     序列赋值运算，通用性
		a = 'a',b='p',c='a',d='m'
		a,b,c,d ='apamaa'
			ValueError: too many values to unpack (expected 4)
	a,*b = 'apam'                        扩展的序列解包
		a='a',b = ['p', 'a', 'm']
	spam = ham = 'lunch'                 多目标赋值运算
	spams += 42                          增强赋值运算(相当于spams=spams+42)


	Python3.0中的保留字：

	False      class          finally    is         return

	None       continue       for        lambda     try

	True       def            from       nonlocal   while

	and        del            global     not        with

	as         elif           if         or         yield

	assert     else           import     pass

	break      except         in         raise



命名惯例，以下是Python遵循的一些惯例：
	
	1、以单一下划线开头的变量名（_X）不会被from module import *语句导入

	2、前后有下划线的变量名（_X_）是系统定义的变量名，对解释器有特殊意义。

	3、以两个下划线开头，但结尾没有两个下划线的变量名（__X）是类的本地（压缩）变量
	
	4、通过交互模式运行时，只有单个下划线的变量名（_）会保存最后表达式的结果。


	变量名（变量）没有类型只是对象的引用，但是对象有类型。

表达式语句：

	通常两种情况下表达式用作语句：
	
		1、调用函数和方法
	
		2、在交互模式提示符下打印值

常见python表达式语句：

	运算                       解释
   	spam(eggs,ham)            函数调用
   	spam.ham(eggs)            方法调用
  	 spam                      在交互模式解释器内打印变量
   	print(a,b,c,sep='')       python3.0中打印操作
   	yield x**2                产生表达式的语句


打印操作：

	在python中,ptint语句可以实现打印--只是对程序员友好的标准输出流的接口而已。


打印流重定向：

	通常来说，print 和sys.stdout的关系如下：
		print(X,Y)
		等价于：
		import sys
		sys.stdout.write(str(X)+''+str(Y)+'\n')

	可以让print语句将文字传送到其他地方：

		import sys
		temp = sys.stdout
		sys.stdout = open('log.txt','a')
		...
		print(x,y,z)  打印到文件

		sys.stdout.close()
		sys.stdout = temp

		print("back here") 打印是输出流

	像上面这样手动保存和恢复原始的输出流包含了相当多的额外工作。一个print的扩展功能就可以实现。
	在python3.0中，file关键字允许一个单个的print调用将其文件发送给一个文件的write方法，
	而不用真正的重设sys.stdout。

		log = open('log.txt','a')
		print(x,y,z,file=log)
		log.close()


本章习题：

	1、将三个变量赋值给可变对象时，你可能需要注意什么？：
		这三个变量都引用相同的对象，其他一个对象在原处修改，也会影响其他变量名，例如列表、字典。
	
	2、L= L.sort()有什么错误：
		列表sort（排序）方法就像append方法，也是对主体列表进行原处修改：返回None，而不是其修改的列表。
		赋值给L,会把L设置为None，而不是排序后的列表。

	3、怎么使用print语句向外部文件发送文本？：

		使用python3.0扩展 print(a,b,z,file=F)
		print >> file
		sys.stdout = open('log.txt','a')


"-----------------------------------------------------------------------"

			if测试和语法规则

"-----------------------------------------------------------------------"

if 测试：

	python中不存在switch或case语句，可以根据变量值选择动作，然而在python,多路分支写成一系列的if/elif测试
	或者对字典进行索引或搜索列表。因为字典和列表可在运行时创建，有时会比硬编码的if逻辑更有灵活性。

	choice = 'ham'
	print({'spam':1.25,
			'ham':1.99,
			'egg':0.99
			'bacon':1.1}[choice])
	branch = {
		'spam':1.25,
		'ham':1.99,
		'egg':0.99
		'bacon':1.12}

	choice = 'bacon'
	if choice in branch:
		print(branch[choice])
	else:
		print('Bad choice')



Python 语法规则：
	
	1、语句是逐个运行的，除非你不这样编写。
	2、块和语句的边界会自动检测。
	3、复合语句 = 首行+ ":" + 缩进语句。
	4、空白行、空格以及注释通常会忽略。
	5、文档字符串会忽略，但会保存并由工具显示。
	python支持的另一种注释，叫做文档字符串（docstring）。和注释不同，文档字符串会在运行时保留下来以便查看。

代码块分隔符：

	1、python会自动以行缩进检测块的边界，就是程序代码左侧的空白空间。缩进至右侧相同的距离的所有语句属于同一块代码。
	2、在python中，空白的一种主要的用途就是用于代码左侧作为缩进。
	3、避免混合使用制表符和空格：Python 3.0中的新的错误检查

语句分隔符：

	Python的语句一般都是在其所在的行的末尾结束的。不过，当语句太长，难以放在一行时，特殊的规则可以位于多行之中。
	1、如果使用语法括号对，语句就可以横跨数行。[],{},()
	2、如果语句以反斜杠结尾，就可横跨数行，很少使用，容易导致错误
	3、字符串常量有特殊规则，三重字符串块可以横跨数行。
	4、其他规则
		以分号终止语句：这种惯例用于一个以上的简单语句挤进单个的行中。
		让每条语句都在自身的行上，除了最简单的块外，全都要缩进。


真值测试：

	布尔and和or运算符会返回真或假的操作对象。
	
	简而言之，布尔运算符是用于结合其他测试的结果。python中有三种布尔表达式运算符：

	X and Y :如果X 和Y都是真，就是真
	X or Y  :如果X 或Y为真，就是真
	not X: 如果X为假，那就是真

	此外，布尔and和or运算符在python中返回真或假对象，而不是值Ture或False

	2 < 3   True
	2 > 3   False

	and 和 or运算总是返回对象，不是运算符左侧的对象,就是右则的对象，再者，
	python会在其找到真值的操作数的地方停止，这叫做短路计算。

	2 or 3    2
	3 or 2    3
	0 or 3    3
	
	3 and 4   4
	2 and 1   1
	4 and 0   0



if/else三元表达式：

	A = Y if X else Z
	
	这个语句等效，只有当X为真，才会执行表达式Y,而只有当X为假，才会执行表达式Z。

	例子：
	A = 't' if 'spam' else 'f'
		
		't'
	
	A = 't' if '' else 'f'
		
		'f'

	
	

"--------------------------------------------------------------------------------"

			第13章  while 和 for循环

"--------------------------------------------------------------------------------"

while 语句，提供了编写通用循环的一种方法；

for语句，用来遍历序列对象内的元素，并对每一个元素运行一个代码块。

while循环：
	
	while语句是python语言中最通用的迭代结构。简而言之，只有顶端测试为真，就重复执行代码块。
	称为循环是因为控制权持续返回到语句的开头部分，知道测试为假，为假时控制权传给while块后的语句。
	
	迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结构，每次对过程的重复称为一次"迭代"，
	而每一次迭代得到的结果会作为下一次迭代的初始值。重复执行一系列运算步骤，从前面的量依次求出后面的量的过程。

一般格式：

	while  <test>:
		<statements1>
	else:
		<statements2>

	
	例子:
		x = 'spam'
		while x:
			print(x,end=' ') 
			x = x[1:]

		spam pam am m >>>

	注意：这里使用end = ' '关键参数，使所有输出都出现在同一行，之间用空格隔开；


python中并没有"do until" 循环语句。

break、continue、pass 和循环else：

在python中:
	
	break     : 跳出最近所在的循环（跳出整个循环语句）
	continue  : 跳到最近所在循环的开头处（来到循环的首行）
	pass      : 什么事也不做，只是空占位语句
	循环else块：只有当循环正常离开时才会执行（也就是没有碰到break语句）。

	python 3.0 允许在可以使用表达式的任何地方使用...（三个连续的点号）来省略代码。由于省略号什么也不做，
	可以当做pass语句的一种替代方案。
		def func1():
			...

循环else:

	和循环else字句结合时，break语句通常可以忽略其他语言中所需的搜索状态标志位。
	
	x = y // 2
	while x > 1:
		if y % x == 0:
			print(y,'has factor',x)
			break
		x -= 1
	else:
		print(y,'is prime')

	13 is prime

	循环else分句是python特有的，简而言之，循环else分句提供了常见的编写代码的明确语法：这是编写代码的结构，
	让你捕捉循环的“另一条”出路，而不通过设定和检查标志位或条件。

	注意：循环else是循环结构体中的一部分，while主体内的break会离开循环并跳过else语句。


为什么要在意"模拟C语言的while循环"：

	python不允许赋值这类语句出现在应该是表达式出现的场合。也就是说，常见的C语言编码样式在python中行不通：
	while((x = next())!=NULL)
		{
			...process x...
		}
		
	C赋值运算会返回赋值后的值，但是python赋值语句只是语句，不是表达式。如果你需要类似的行为，只少有三种方式可以
	在python while循环中达到相同的效果。

	你可以配合break，把赋值语句移到循环主体中来。
	while True:
		x = next()
		if not x:break
			...process x...

	或者把赋值语句移进循环中再配合测试
	x = True
	while x:
		x = next()
		if x:
			...process x...
	
	或者把第一个赋值语句移出循环外：
	x = next()
	while x:
		...pricess x...
		x = next()
	


for 循环:

	for 循环是python中是一个通用的序列迭代器：可以遍历任何有序的序列对象内的元素。

	一般格式:
	python for循环的首行定义了一个赋值目标，以及你想遍历的对象。首行后面是你想重复的语句块。

		for <target> in <object>:
			<statements>
		else:
			<statements>

	当python运行for循环时，会逐个将序列对象中的元素赋值给目标，然后为每个元素执行循环主体。
	循环主体一般使用赋值的目标来引用序列中的元素，就好像那是遍历序列的游标。


编写循环技巧：
	
	for循环包括多数计数器式的循环，一般而言，for比while容易写，执行时也比较快。

	在python提供了两个内置函数，在for循环内定制迭代:
		
		1、内置range函数返回一系列增加的整数，可作为for中的索引。
	
		2、内置zip函数返回并行元素的元组的列表，可用于在for中内遍历数个序列。

	并行遍历：zip 和 map：
	
		zip会取得一个或多个序列为参数，然后返回元组的列表，这些序列中的并排的元素配成对。
		例如，假设我们使用两个列表：
	
		L1 = [1,2,3,4]
		L2 = [5,6,7,8]

	要合并这些列表中的元素，可以使用zip来创建一个元组对的列表（和rang一样，zip在python3.0中也是一个可迭代对象，
	我们必须将其包含在一个list调用中以便一次性显示所有结果）

	zip(L1,L2)
		<zip object at 0x7f1289872148>
	
	list(zip(L1,L2))
		[(1, 5), (2, 6), (3, 7), (4, 8)]

	
	for (x,y) in zip(L1,L2):
		print(x,y,'--',x+y)

		1 5 -- 6
		2 6 -- 8
		3 7 -- 10
		4 8 -- 12
	

	当参数不同时，zip会以最短的序列的长度为准来截取所得到的元组。

	S1 = 'abc'
	S2 = 'xyz123'
	list(zip(S1,S2))
		[('a', 'x'), ('b', 'y'), ('c', 'z')]

	在python2.X中，内置map函数，用类似的方式把序列的元素配对起来，如果参数不同，则会为较短的序列用None补齐：

	S1 = 'abc'
	S2 = 'xyz123'
	map(None,S1,S2)
		[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None, '3')]
	
	map是python3.0中的一个值生成器。
	
	list(map(ord,'spam'))
		[115, 112, 97, 109]
	
	
使用zip构造字典：

	keys  = ['spam','eggs','toast']
	vals = [1,3,5]

	list(zip(keys,vals))
		[('spam', 1), ('eggs', 3), ('toast', 5)]
	
	D2 = {}
	for (k,v) in zip(keys,vals):
		D2[k] = v
	
	D2
		{'toast': 5, 'eggs': 3, 'spam': 1}
	
	不过在python2.2后续版本中，可以跳过for循环，直接把zip过的键/值列表传给内置的dict构造函数。
	keys  = ['spam','eggs','toast']
	vals = [1,3,5]

	D3 = dict(zip(keys,vals))
	D3
		{'toast': 5, 'eggs': 3, 'spam': 1}

	内置变量名dict其实是Python中的类型名称，对他进行调用时，可以得到类似列表到字典的转换
	但这其实是一个对象构造的请求。


产生偏移和元素：enumerate：

	S = 'spam'
	for (offset,item) in enumerate(S):
		print(item,'appears at offset',offset)
	
		('s', 'appears at offset', 0)
		('p', 'appears at offset', 1)
		('a', 'appears at offset', 2)
		('m', 'appears at offset', 3)

	enumerate函数返回一个生成器对象。
	E = enumerate(S)
		<enumerate object at 0x7f39a63c8460>
	E.next()
		(0, 's')
	E.next()
		(1, 'p')
	E.next()
		(2, 'a')
	E.next()
		(3, 'm')

	
本章习题：
	
	1、while 和 for之间的主要功能区别是什么？
	
		while循环是一条通用的循环语句，for循环设计来在一个序列中遍历各项（序列需要是真正可迭代的）
		尽管while可以用计数器循环来模拟for循环，但需要更多代码，运行更慢。

	2、一个循环的else分句何时执行？
	
		while或for循环中的else分句在循环离开时执行一次，但前提是正常离开（没有运行break语句）。
		如果运行break会立刻离开循环，跳过else部分。





"--------------------------------------------------------------------------------------------"

				迭代器和解析，第一部分

"--------------------------------------------------------------------------------------------"

迭代器：初探：

	在python的数据结构时，容器(container)、可迭代对象(tierable)、迭代器(iterator)

	生成器(generator)、list、set、dict、comprehension众多概念掺杂一起，下面看图

	
	一个生成器表达式()
						(is)-->一个生成器(always is)--一个迭代器 (next)-->lazily produce next value
	一个生成器函数(yield)



	{list，set,dict}												
			(procues)--->一个容器(通常是)-->可迭代的-->(iter)-->一个迭代器
	comprehension 

	
	
容器(container):

	容器是一种多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，
	可以用in,not in 判断关键字元素是否包含在容器中，通常这类数据结构把所有
	的元素存储在内存中，在python中常见的容器有：

		list、deque、...
		set、frozensets、...
		dict、defaultdict、OrderedDict、Counter，...
		tuple、namedtuple，...
		str

		
		询问某substring是否在string中：

		>>> s = 'foobar'
		>>> assert 'b' in s
		>>> assert 'x' not in s
		>>> assert 'foo' in s

		如果正确什么都不做，如果不对报异常，可以主要显示异常信息如下：
		assert x>y,'x too small'
			
		如果出错，则会打印出异常,异常信息:

			Traceback (most recent call last):
			File "<stdin>", line 1, in <module>
			AssertionError: 3 too small""
		
	容器比较容易理解，因为你就可以把它看作是一个盒子、一栋房子、一个柜子，里面可以塞任何东西。
	从技术角度来说，当它可以用来询问某个元素是否包含在其中时，那么这个对象就可以认为是一个容器，
	比如 list，set，tuples都是容器对象：

	尽管绝大多数的容器都提供了某种方式来获取其中么某一个元素，但这并不是容器本身所提供的能力。
	而可迭代对象赋予了容器这种能力，当然并不是所有的容器都是可迭代的。
	比如Bloom filter，虽然Bloom filter可以用来检测某个元素是否包含在容器中，
	但是并不能从容器中获取其中的每一个值，因为Bloom filter压根就没把元素存储在容器中，
	而是通过一个散列函数映射成一个值保存在数组中。
	
	容器是一系列元素的集合，str、list、set、dict、file、sockets对象都可以看作是容器，
	容器都可以被迭代（用在for，while等语句中），因此他们被称为可迭代对象。


可迭代对象(iterable)

	凡是可以返回一个迭代器的对象都可以称为可迭代对象。

		x = [1,2,3]
		y = iter(x)
		z = iter(x)

		next(y)
			1
		next(z)
			1

		type(x)
			<class 'list'>
		type(y)
			<class 'list_iterator'>

	这里x是一个可迭代对象，可迭代对象和容器一样是一个通俗的叫法，
	并不是指某种具体的数据类型，list是可迭代对象，set也是可迭代对象。

	y,z是两个独立的迭代器，迭代器内部持有一个状态，该状态用于记录当前
	迭代所在的位置，以方便下一次迭代的时候获取正确的元素。迭代器有
	一种具体的迭代器类型，比如list_iterator,set_iterator。
	可迭代对象实现了_iter_方法，该方法返回一个迭代器对象。

	当运行代码：

		x = [1,2,3]

		for elem in x:
			print elem

	实际执行情况是：

		x[1,2,3](the iterable)-->(iter)-->iterator(the iterator)--->next()
	
	反编译该段代码，你可以看到解释器显示地调用GET_ITER指令，
	相当于调用iter(x),FOR_ITER指令就是调用next()方法，
	不断地获取迭代器中的下一个元素，但是你没办法直接从指令中
	看出来，因为他被解释器优化过了

		import dis
		x = [1,2,3]

		dis.dis('for _ in x:pass')
		
		1       0 SETUP_LOOP              12 (to 14)
	              2 LOAD_NAME                0 (x)
	              4 GET_ITER
			>>    6 FOR_ITER                 4 (to 12)
	              8 STORE_NAME               1 (_)
	             10 JUMP_ABSOLUTE            6
			>>   12 POP_BLOCK
			>>   14 LOAD_CONST               0 (None)
	             16 RETURN_VALUE
	
	可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。

迭代器(iterator):
	
	它是一个带状态的对象，能在你调用next()方法的时候
	返回容器中的下一个值，任何实现了__iter__和__next__()
	方法的对象都是迭代器，__iter__返回迭代器自身，
	__next__()返回容器中的下一个值，如果容器中没有更多
	的元素了，则抛出异常StopIteration异常，至于到底
	如何实现并不太重要。


	生成无限序列：
		>>> from itertools import count
		>>> counter = count(start=13)
		>>> next(counter)
			13
		>>> next(counter)
			14

	
	从一个有限序列中生成无限序列：

		>>> from itertools import cycle
		>>> colors = cycle(['red', 'white', 'blue'])
		>>> next(colors)
			'red'
		>>> next(colors)
			'white'
		>>> next(colors)
			'blue'
		>>> next(colors)
			'red'

	从无限的序列中生成有限序列：

		>>> from itertools import islice
		>>> colors = cycle(['red', 'white', 'blue'])  # infinite
		>>> limited = islice(colors, 0, 4)            # finite
		>>> for x in limited:                         
		...     print(x)
			
		red
		white
		blue
		red

	为了更直观地感受迭代器内部的执行过程，我们自定义一个迭代器，
	以斐波那契数列为例：

		class Fib:
			def __init__(self):
				self.prev = 0
				self.curr = 1

			def __iter__(self):
				return self

			def __next__(self):
				
				value = self.curr
				self.curr += self.prev
				self.prev = value
				return value

		f = Fib()
		list(islice(f, 0, 10))
			[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

	Fib既是一个可迭代对象（因为它实现了__iter__方法），
	又是一个迭代器（因为实现了__next__方法）。
	实例变量prev和curr用户维护迭代器内部的状态。
	每次调用next()方法的时候做两件事：
		
		为下一次调用next()方法修改状态
		为当前这次调用生成返回结果

	迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，
	没调用的时候就处于休眠状态等待下一次调用。
	
	迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了__next__和__iter__方法，
	迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。
		

生成器（generator）:

	1、生成器函数：

		生成器算得上Python语言中最吸引人的特性之一，生成器其实是一种特殊的迭代器
		不过这种迭代器更优雅，它不需要像上面的类一样，写__iter__()和__next__()方法
		只需要一个加一个yield关键字，生成器一定是迭代器(反之不成立)因为任何生成器
		也是以一种懒加载模式生成值。用生成器实现斐波那契数列的例子是：
	
			def fib():
				prev, curr = 0, 1
				while True:
					yield curr
					prev, curr = curr, curr + prev
				    
			>>> f = fib()
			>>> list(islice(f, 0, 10))
				[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
		
		fib就是一个普通的python函数，它特殊的地方在于函数体中没有return关键字，
		函数的返回值是一个生成器对象。当执行f=fib()返回的是一个生成器对象，
		此时函数体中的代码并不会执行，
		只有显示或隐示地调用next的时候才会真正执行里面的代码。

		生成器在Python中是一个非常强大的编程结构，可以用更少第中间
		变量写流式代码，此外，相比其它容器对象它更能节省内存和CPU，
		当然它可以用更少的代码来实现相似的功能。现在就可以动手重构你的代码了，
		但凡看到类似：

			def something():
				result = []
				for ... in ...:
					result.append(x)
				return result

		都可以用生成器替换：

			def iter_something():
				for ...in ...:
					yield x

	2、生成器表达式(generator expression)

		生成器表达式是列表推倒式的生成器版本，看起来像列表推导式，
		但是它返回的是一个生成器对象而不是列表对象。
		
			>>> a = (x*x for x in range(10))
			>>> a
				<generator object <genexpr> at 0x401f08>
			>>> sum(a)
				285

	生成器是一种特殊的迭代器，它的返回值不是通过return而是用yield。



可迭代对象与迭代器：
	
	1、可迭代对象包含迭代器
	
	2、如果一个对象拥有__iter__方法，就是可迭代对象；如果一个对象拥有next方法，就是迭代器
	
	3、定义可迭代对象，必须实现__iter__方法；定义迭代器，必须实现__iter__和next方法。
	
__iter__():
	
	该方法返回的是当前对象的迭代器类的实例。因为迭代对象和迭代器都实现这个方法，因此有两种写法。
	
	写法一：用于可迭代对象类的写法，返回该可迭代对象的迭代器类的实例。
	
	写法二：用于迭代器类的写法，直接返回self(即自己本身)，表示自身即是自身的迭代器。

next():
	
	返回迭代的每一步，实现该方法时注意要最后超出边界要抛出StopIteration异常。


	
文件迭代器：
	
	了解迭代器的最简单的方式之一就是，看一看它是如何与内置类型一起工作的。
	
	例如： 
	f = open('script1.py')
	f.readline()
		'import sys\n'
	f.readline()
		'pirnt(sys.path)\n'
	f.readline()
		'x=2\n'
	f.readline()
		''

	如今，文件也有一个方法，名为__next__,差不多有相同的效果：每次调用时，就会返回文件的下一行，唯一
	的区别是，达到文件末尾时，__next__会引发内置的StopIteration异常，而不是返回空字符串。

	f = open('script1.py')
	f.__next__()
		'import sys\n'
	f.__next__()
		'pirnt(sys.path)\n'
	f.__next__()
		'x=2\n'
	f.__next__()
		Traceback (most recent call last):
			File "<stdin>", line 1, in <module>
		StopIteration

	这个接口就是python中所谓的迭代协议：有__next__方法的对象会前进到下一个结果，而在一系列结果的末尾时	
	则会引发StopIteration。


手动迭代：
	
	为了支持迭代代码，python3.0还提供了一个内置函数next,它会自动调用一个对象的__next__方法。
	
	给定一个可迭代对象X,调用next(X)等同于X.__next__().
	
	f = open('script1.py')
	next(f)
		'import sys\n'
	next(f)
		'pirnt(sys.path)\n'
	next(f)
		'x=2\n'
	next(f)
		Traceback (most recent call last):
			File "<stdin>", line 1, in <module>
		StopIteration

	从技术角度来讲，迭代协议还有一点可以注意。当for循环开始时，会通过它传给iter内置函数，以便从迭代对象中
	获得一个迭代器，返回的对象含有需要的next方法。如果我们看for循环内部如何处理列表这类内置序列的话，就会一目了然。

	这是python 2.X存在next,python3.0不存在next(),而是__next__()
	
	L = [1,2,3]
	I = iter(L)
	I.next()
		1
	I.next()
		2
	I.netxt()
		3
	I.next()
		Traceback (most recent call last):
			File "<stdin>", line 1, in <module>
		StopIteration

	最初的一步对于文件来说是不需要的，因为文件对象是自己的迭代器。也就是文件有自己的__next__方法。

	f = open('/home/zhangkun/222.txt')
	iter(f) is f
		True

	列表以及其他的内置对象，不是自身的迭代器，因它们支持多次打开迭代器。对于这样的对象，我们必须调用iter来启动迭代。

	L= [1,2,3]
	iter(L) is L
		False

	L.__next__()
		Traceback (most recent call last):
			File "<stdin>", line 1, in <module>
		AttributeError: 'list' object has no attribute '__next__'

	I = iter(L) 
	I.__next__()
		1
	I.__next__()
		2
	next(I)
		3
	I.__next__()
		Traceback (most recent call last):
			File "<stdin>", line 1, in <module>
		StopIteration


	
python3中列表iter(L)生成的是list_iterator，这个类中不存在next方法，只有__next__()

python2中类别iter(L)生产的是listiterator，这个类中不存__next__()方法，只有next方法。

	从技术上讲，for循环调用内部等价的I.__next__,而不是next(I)
	
	L = [1,2,3]
	for x in L:
		pirnt(x**2,end=' ')
	

	I = iter(L) 
		while True:
			try:
				x = next(I)
			except StopIteration:
				break;		
			print(x**2,end=' ')

其他内置类型迭代器：

字典：
	
	D = {'a':1,'b':2,'c':3}
	for key in D.keys():
			print(key,D[key])

		a 1
		b 2
		c 3
	
	I = iter(D)
	next(I)
		'a'
	next(I)
		'b'
	next(I)
		'c'
	next(I)
		Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
		StopIteration

直接效果是，不需要调用keys方法来遍历字典键-for循环将使用迭代协议在每次迭代的时候获取一个键。
	
	for key in D:
		print(key,D[key])

		a 1
		b 2
		c 3
	

	
列表解析：初探：

	与for循环一起使用，列表解析是最常应用迭代协议的环境之一。

列表解析基础知识:	
	
	L = [x +10 for x in L]

	列表解析写在一个方括号中，因为他们最终是构建一个新的列表的一种方式。


在文件上使用列表解析：
	
	f = open('/home/zhangkun/222.txt')
	lines = f.readlines()
	lines
		['dfasf\n', 'f\n', 'd\n', 'sa\n', 'f\n', 'sa\n', 'f\n', 'sa\n', 'df\n', '\n']

	如下代码通过对列表中的每一行运行字符串rstrip方法，去移除右端的空白。
	
	lines = [line.rstrip() for line in lines]
	
	lines
		['dfasf', 'f', 'd', 'sa', 'f', 'sa', 'f', 'sa', 'df', '']


其他迭代环境：

	在对象中从左到右扫描的每种工具都使用了迭代协议。
	
	列表解析、in成员测试、map内置函数、以及像sorted和zip调用这样的内置函数也都使用了迭代协议。



Python 3.0中的新的可迭代对象：
	
	python3一个基本改变是比Python2更强调迭代。字典方法keys,values和items都是可迭代对象。
	内置函数：range、map、zip和filter


range迭代器：

	在python3中，range返回一个迭代器，该迭代器根据需要产生范围中的数字，而不是一个内存中构建一个结果列表。
	python3:
		R = range(10)
		R
			range(0, 10)
		I = iter(R)
		next(I)
			0
		next(I)
			1
		...


		list(range(10))
			[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	
	python2中:
		R = range(10)
		R
			[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

	python3中的range对象支持迭代、索引以及len函数，不支持任何其他序列操作（可使用list(...)）


map、zip和filter迭代器：

	和range类似，map、zip、以及filter内置函数，在python3中也转变成迭代器以节约内存空间，而不再内存中一次性生产结果类表。
	和range不同，他们都有自己的迭代器。
	
	map:
		M = map(abs,(-1,0,1))
		M
			<map object at 0x7f3fab5ed470>
		M.__next__()
			1
		next(M)
			0
		next(M)
			1
		next(M)
			Traceback (most recent call last):
				File "<stdin>", line 1, in <module>
			StopIteration


	zip：
		z = zip((1,2,3),(4,5,6))
		z
			<zip object at 0x7f3fab5e7248>
		next(z)
			(1, 4)
		next(z)
			(2, 5)
		next(z)
			(3, 6)
		next(z)
			Traceback (most recent call last):
				File "<stdin>", line 1, in <module>
			StopIteration


	filter：
		filter内置函数，对于传入的函数返回True的可迭代对象中的每一项（非空对象）
		
		filter(bool,['spam','','ni'])
		
		list(filter(bool,['spam','','ni']))
		
			['spam','ni']


多个迭代器VS单个迭代器：

	range对象与map、zip、filter内置函数不同，range支持len和索引，他不是自己的迭代器（手动迭代时，使用iter产生一个迭代器）。
		

字典视图迭代器：
	
	在python3中，字典的keys、values和items方法返回可迭代的视图对象，它们一次产生一个结果项，而不是在内存中
	一次产生全部结果列表。

	和所有迭代器一样，把python3字典视图传递给list内置函数中，从而强制构建一个真正的列表。
	
	D = dict(a=1,b=2,c=3)
	K = D.keys()
	list(K)
		['a','b','c']


其他迭代器主体：

	1、使用yield语句，用户定义的函数可以转换成为可迭代的生成器函数。
	
	2、当编写在圆括号中的时候，列表解析转变为可迭代的生成器表达式。

	3、用户定义的类通过__iter__ 或__getitem__运算符重载变得可迭代。




本章小结：

1、for循环和迭代器之间有什么关系？
	
	for循环使用迭代协议来遍历迭代对象中的每一个项，for循环在每次迭代中调用该对象的__next__方法
	（有next内置函数运行），而且会捕捉StopIteration异常，从而决定何时终止循环。


2、for循环和列表解析直接有什么关系？

	两支都是迭代工具，列表解析是执行常见for循环任务的简明并且高效的方法:对可迭代对象内所有元素应用一个
	表达式，并收集其结果。

3、举出python中的四种迭代环境？

	python中的迭代环境包括for循环、列表解析、map内置函数、in成员关系测试表达式以及内置函数sorted、sum、any和all.
	这个分类也包括了内置函数list和tuple、字符串join方法以及序列赋值运算。所有这些都使用了迭代协议(next方法)来
	一次一次元素逐个遍历可迭代对象。


4、如今从一个文本文件中逐行读取行的最好方法是什么？
	
	在迭代环境中打开文件，如for循环，列表解析，然后，让迭代工具在每次迭代中执行该文件的next方法，
	自动一次扫描一次。




"------------------------------------------------------------------------------------------------"
	
					第15章   文档	

"------------------------------------------------------------------------------------------------"

python 文档资源：

	形式                    角色
	#注释                 文件中的文档

	dir函数              对象中的可用属性的列表

	文档字符串：__doc__  附加在对象上的文件中的文档

	pyDoc：help函数      对象的交互帮助

	pyDoc：HTML报表      浏览器中的模块文档

	标准手册             正式的语言和库的说明

	网站资源             在线教程，例子等

	出版书籍             商业参考书


常见的编写代码的陷阱：

	1、别忘记冒号。复合语句首行末尾输入":"

	2、空白行在交互模式提示符下很重要。

	3、缩进要一致

	4、不要在python中写C代码。

	5、使用简单的for循环，而不是while或range。

	6、要注意赋值语句中的可变对象
		列表、字典，引用会改变。

	7、不要期待在原处修改对象的函数会返回结果。
		例如：list.append和list.sort方法这种修改运算，并不会有返回值（而是None）

	8、一定要使用括号调用函数。

	9、不要在导入和重载中使用扩展名或路径。
		例如:要写import mod，而不是import mod.py


本章习题：

1、什么时候应该使用文档字符串而不是#注释？:
	
	文档字符串被认为最适用于较大、功能性的文档，用了描述程序中的模块、函数、类以及方法的使用。
	#注释只限于关于费解的表达式或语句的微型文档。


	

"===================================================================================="

					第四部分 函数

"====================================================================================="


"--------------------------------------------------------------------------------------"
									
				 第16章  函数基础

"---------------------------------------------------------------------------------------"

函数是python为了代码最大程度的重用和最小化代码冗余而提供的最基本的程序结构。

函数相关的语句和表达式：

	语句                          例子
	calls                     myfunc("spam","eggs",meat=ham)

	def                       def adder(a,b=1,*c)

	return                    return  a+b+c[0]

	global                    def changer():
					global x;x='new'

	nonlocal                  def changer():
					nonlocal x;x = 'new'

	yield                     def squarers(x):
					for i in ranger(x):yield i**2

	lambda                    Funcs = [lambda x: X**2,lambda x:x*3]



为何使用函数：

	函数主要扮演两种角色：

	1、最大化的代码重用和最小化的代码冗余

	2、流程分解



编写函数：

	1、def 是可执行的代码。
		
		Python的函数是有一个新的语句编写的，即def。不像C这样的编译语言，def是一个可执行语句---函数并不存在，
		直到python运行了def后才存在。
		在典型的操作中，def语句在模块文件中编写，并自然而然的在模块文件第一次被导入的时候生产定义的函数。

	2、def 创建了一个对象并将其赋值给某一变量名。
		
		当python运行到def语句时，它将会生产一个新的函数对象并将其赋值给这个函数名。就像所有的赋值一样，函数
		名变成了某一个函数的引用。

	3、lambda 创建一个对象但将其作为结果返回。

	4、return 将一个结果对象发送给调用者。

	5、yield 向调用者发回一个结果对象，但是记住它离开的地方。

	6、global 声明了一个模块级的变量并被赋值。
		
	7、nonlocal 声明了将要赋值的一个封闭的函数变量。
		
		nonlocal语句允许一个函数来赋值一条语法封闭的def语句的作用域中已有的名称。
		这就允许封闭的函数作为保留状态的一个地方--当一个函数调用的时候，信息被记住了，而不必使用共享的全局名称。

	8、函数是通过赋值（对象引用）传递的。

	9、参数、返回值以及变量并不是声明。
	
		就像在python中所有的一样，在函数中并没有类型约束。实际上，从一开始函数就不需要声明：可以传递任意类型的参数
		给函数，函数也可以返回任意类型的对象。


def 语句:
	
	def语句将创建一个函数对象并将其赋值给一个变量名。Def语句一般的格式如下所示:

	def <name> (arg1,arg2,...argN):
		<statements>

		 retrun <value>

	就像所有的多行python语句一样，def包含了首行并有一个代码块跟随在后边，这个代码块通常会缩进。而代码块就是函数
	的主体--也就是每当调用函数时python所执行的语句。
	
	python的return语句可以在函数主体中的任何地方出现，它表示函数调用的结束，并将结果返回至函数调用处。
	return语句包含一个对象表达式，这个对象给出的函数的结果。
	如果它没有出现，那么函数将会在控制流执行完函数主体时结束。
	从技术角度上讲，一个没有返回值的函数会自动返回none对象，但这个值往往被忽略。


	def语句是实时执行的：
	python中的所有的语句都是实时运行的，没有像独立的编译时间这样的流程。
	

本章小结：

	什么时候python将会创建函数？

		当python运行到def语句时，函数就会被创建。这个语句会创建函数对象，并将其赋值给函数名。



"----------------------------------------------------------------------------------------"

				第17章                   作用域

"----------------------------------------------------------------------------------------"
	
python作用域基础:

	python 中变量名的含义：当你在一个程序中使用变量名时，python创建，改变或查找变量名都是在所谓的
		命名空间（一个保存变量名的地方）中进行的。作用域这个术语指的就是命名空间。

	python 将一个变量名被赋值的地点关联为(绑定给)一个特定的命名空间。换句话说，在代码中给一个变量赋值的地方决定了
		这个变量将存在于那个命名空间。

一个函数的所有变量名都是与函数的命名空间向关联的这意味着:

	1、一个在def内定义的变量名能够被def内的代码使用。不能在函数的外部引用这样的变量名。

	2、def之中的变量名于def之外的变量名并不冲突，即是使用在别处的相同的变量名。
		一个在def之外被赋值的变量x与在这个def之内的赋值的变量x是完全不同的变量。

一个变量的作用域总是由在代码中被赋值的地方所决定，并且与函数调用完全没有关系。
	
	1、如果一个变量在def内赋值，它被定位在这个函数之内。

	2、如果一个变量在一个嵌套的def中赋值，对于嵌套的函数来说，它是给非本地的

	3、如果在def之外赋值，它就是整个文件全局的。



作用域法则:
	
	函数定义了本地作用域，模块定义是全局作用域。

	1、内嵌的模块是全局作用域。

	2、全局作用域的作用范围仅限于单个文件。

	3、每次对函数的调用都会创建了一个新的本地作用域。

	4、赋值的变量名除非什么为全局变量或非本地变量，否则均为本地变量。

	5、所有其他的变量名都可以归纳为本地、全局或者内置的。


变量名解析：LEGB原则:

	对于一个def语句：
	
	1、变量名引用分为三个作用域进行查找:首先是本地、之后是函数内（如果有的话），之后是全局，最后是内置。

	2、默认情况下，变量名赋值会创建或者改变本地变量。

	3、全局声明和非本地声明将赋值的变量名映射到模块文件内部的作用域。


python的变量名解析机制有时也称为LEGB法则，这也是由作用域的命名而来的。
	
	1、当函数中使用未认证的变量名时，Python搜索4个作用域[本地作用域(L),之后是上一层结构中的def或lambda的本地
		作用域（E）,之后是全局作用域(G),最后是内置作用域(B)]并且在第一处能够找到这个变量名的地方停下来。
		如果变量名在这次搜索中没有找到，python会报错。

	2、当函数中给一个变量赋值时python总是创建或改变本地作用域的变量名，除非它已经在那个函数中声明为全局变量。

	3、当在函数之外给一个变量名赋值时，本地作用域和全局作用域是相同的。



内置作用域：

	内置作用域仅仅是一个名为__builtin__的内置模块，但是必须要import __builtin__之后才能使用内置作用域。

	内置作用域通过一个名为__builtin————的标准库模块来实现，这个变量名自身并没有发到内置作用域内，所有必须导入这个文件才能使用它。
	
	import builtins
	dir(builtins) 
	['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']

	这个列表中的变量名组成了python中的内置作用域，前一半是内置异常，而后一半是内置函数。
	由于LEGB法则python最后将自动搜索这个模块，将会自动得到这个列表中的所有变量名。也就是说，你能够使用这些变量名
	而不需要导入任何模块。


global语句：
	
	global语句是python中唯一看起来像声明语句的语句。但是它并不是一个类型或大小声明，它是一个命名空间的声明。
	它告诉python函数，打算生成一个或多个全局变量名。也是存在整个作用域的变量名。

	1、全局变量是位于模块文件内部的顶层变量名。

	2、全局变量如果是在函数内被赋值的话，必须经过声明。

	3、全局变量名在函数内部不经过声明也可以被引用。
	



作用域和嵌套函数:

	嵌套作用域的细节：
	
	1、一个引用(X)首先在本地(函数内)作用域查找变量名X;之后会在代码的语法上嵌套了的函数中的本地作用域，从内到外查找
	  之后查找当前的全局作用域；最后再内置作用域。全局声明将会直接从全局作用域进行搜索。

	2、默认情况下，一个赋值(X =value)创建或改变了变量名X的当前作用域。如果X在函数内部声明为全局变量，他将会创建或
	改变变量名X为整个模块的作用域。另一方面，如果X在函数内部声明为nonlocal，赋值会修改最近的嵌套函数的本地作用域中的
	名称X。

例子:

	X = 99
	def f1():
		X = 88
		def f2():
			print(X)
		f2()
	
	f1()
		88
	
	---------------------------------
	
	X = 99
	def f1():
		def f2():
			print(X)
		f2()
	f1()
		99
		
	def是一个简单的可执行语句，可以出现在任意其他语句能够出现的地方，包括嵌套在另一个def之中。这里，嵌套的def在函数
	f1调用时运行；这个def生产了一个函数，并将其赋值给变量名f2,f2是f1的本地作用域内的一个本地变量。在此情况下，f2是
	一个临时函数，仅在f1内部执行过程中存在（并且只对f1中的代码可见）

	当打印变量X时，x引用了存在函数f1整个本地作用域内的变量X的值。因为函数能够在整个def声明内获取变量名，通过LEGB
	查找法则，f2内想x自动映射到f1的x。



工厂函数：
	
	根据要求的对象，这种行为有时也叫做闭合或者工厂函数--一个能够记住嵌套作用域的变量值的函数，尽管那个作用域或许
	已经不存在了。
	例如：

	def maker(N):
		def action(X):
			return X**N
		return action

	这定义了一个外部的函数，这个函数简单地生成并返回了一个嵌套的函数，却并不调用这个内嵌的函数。如果我们调用外部的函数：
	
	f = maker(2)
	f
		<function maker.<locals>.action at 0x7f0d62511158>
	
	我们得到的是生产的内嵌函数的一个引用。这个内嵌函数是通过运行内嵌的def而创建的，如果现在调用从外部得到那个函数：
	
	f(3)
		9
	f(4)
		16

	
嵌套作用域和lambda:
	
	lambda是一个表达式，将会生成后面调用的一个新的函数。

	def func():
		x = 4
		action = (lambda n :x ** n)
		return action
	x = func()
	print(x(2))





nonlocal语句：

	nonlocal语句是global的近亲，声明将要在一个嵌套的作用域中修改的名称。
	和global不同在于，nonlocal应用于一个嵌套的函数的作用域的一个名称，而不是所有def之外的全局模块作用域。
	而且在声明nonlocal名称的时候，它必须已经存在于该嵌套函数的作用域中---它们可能只存在于一个嵌套的函数中，
	并且不能有一个嵌套的def中的第一次赋值创建。

	nonlocal即允许对嵌套的函数作用域中的名称赋值，并且把这样的名称的作用域查找限制在嵌套的def。

nonlocal基础:
	
	def func():
		nonlocal name1,name2,...
	这条语句允许一个嵌套函数来修改在一个语法嵌套函数的作用域中定义的一个或多个名称。
	当执行到nonlocal语句的时候，nonlocal中列出的名称必须在一个嵌套的def中提前定义过，否则，将会产生一个错误。
	直接效果和global很相似：global意味着名称位于一个嵌套的模块中，nonlocal意味着他们位于一个嵌套的def中。

	nonlocal的添加并没有改变通用的名称引用作用域规则；他们仍然像以前一样工作，即前面多描绘每条"LEGB"规则。
	nonlocal语句主要作用是允许嵌套的作用域中的名被修改，而不只是被引用。
	然而，当一个函数中使用的时候，global和nonlocal语句在某种程度上限制了查找规则：

	1、global使得作用域查找从嵌套的模块的作用域开始，并且允许对那里的名称赋值。

	2、nonlocal限制作用域查找只是嵌套的def，要求名称已经存在于那里，并且允许对它们赋值。

	def tester(start):
		state = start
		def nested(label):
			print(label,state)
		return nested
	
	F = tester(0)
	F('spam')
		spam 0
	F('ham')
		ham 0

	
	def tester(start):
		state = start
		def nested(label):
			print(label,state)
			state += 1
		return nested
	F = tester(0)
	F('spam')

		Traceback (most recent call last):
		UnboundLocalError: local variable 'state' referenced before assignment
	
	使用nonlocal进行修改：
	def tester(start):
		state = start
		def nested(label):
				nonlocal state
				print(label,state)
				state += 1
		return nested

	F = tester(0)
	F('spam')
		spam 0
	F('spamw')
		spamw 1
	F('spamw')
		spamw 2


边界情况:
	
	当执行nonlocal语句时，nonlocal名称必须已经在一个嵌套的def作用域中赋值过，否则将会得到一个错误---不能通过
	在嵌套的作用域中赋值给它们一个新值来创建它们：
		
		def tester(start):
			def nested(label):
				nonlocal state
				state = 0
				print(label,state)
			return nested

		SyntaxError:no binding for nonlocal 'state' found

	
	其次,nonlocal限制作用域查找仅为嵌套的def，nonlocal不会在嵌套的模块的全局作用域或所有def之外的内置作用域
	中查找，即便已经有了这些作用域：

		spam = 99
		def tester():
			def nested():
				nonlocal spam
				print('Current=',spam)
				spam += 1
			return nested
	
		SyntaxError:no binding for nonlocal 'spam' found

	
为什么使用nonlocal:

	在python中，有各种不同的方法来"记住"跨函数和方法的信息。尽量都有利弊，对于嵌套作用域引用，
	nonlocal确实起到了改进作用--nonlocal语句允许在内存中保持可变的多个副本，并且解决了类无法保证的情况下的简单的状态保持。

	def tester(start):
		state = start
		def nested(label):
			nonlocal state
			print(label,state)
			state += 1
		return nested
	
	F = tester(0)
	F('spam')


	与全局共享状态：
	在python2.6实现nonlocal效果的一种通用的方法，就是直接把状态移出全局作用域(嵌套的模块)

	def	tester(start):
		global state
		state = start
		def nested(label):
			global state
			print(label,state)
			state += 1
		return nested

	F = tester(0)
	F('spam')
		spam 0
	F('spama')
		spama 1
	F('spama')
		spama 2


	使用类的状态
		改变信息，另一种较早的方法是使用带有属性的类，从而让状态信息的方法比隐式的范围查找规则更明确。
		
	class tester:
		def __init__(self,start):
			self.state = start
		def nested(self,label):
			print(label,self.state)
			self.state += 1

	F = tester(0)
	F.nested('spam')
		spam 0
	F.nested('spam')
		spam 1
	
	G =  tester(32)
	G.nested('egg')
		egg 32
	G.nested('egg') 
		egg 33

	

	我们也可以使用运算符重载让类看上去像是一个可调用函数。__call__获取了一个实例上的直接调用，因此，
	不需要指定一个指定的方法：
	
	class tester:
		def __init__(self,start):
			self.state = start
		def __call__(self,label):
			print(label,self.state)
			self.state += 1
	
	H = tester(99)
	H('juice')
		juice 99
	H('juice')
		juice 100
		
	
	全局、非本地、类都提供了状态保持的选项。


本章小结：
	
	下面代码会输出什么? 为什么？

	X = 'Spam'
	def func():
		print(X)

	func()
		'Spam'

	因为函数引用的是所在模块中的全局变量。


Python的作用域背后的细节---即定义和查找变量的位置。在代码中定义名称的位置决定了它大部分的含义。


"----------------------------------------------------------------------------------------"


				第18章     参数

"----------------------------------------------------------------------------------------"

python参数传递的概念，即对象作为输入发送给函数的方式。

参数：赋值给一个函数中的名称，但是，它们更多地与对象引用相关，而不是与变量作用域相关。

python提供的额外工具：关键字、默认值、任意参数收集器，它们为参数发送给函数的方式提供了广泛的灵活性。


传递参数：
	
	1、参数的传递是通过自动将对象赋值给本地变量名来实现的。
	
		函数参数[调用者发送的共享对象引用值]在实际中至是python赋值的另一个实例而已。	

	2、在函数内部的参数名的赋值不会影响调用者。
	
		在函数运行时，在函数头部的参数名是一个新的、本地的变量名，这个变量名是在函数的本地作用域内。
		函数参数名和调用者作用域中的变量名是没有别名的。

	3、改变函数的可变对象参数的值也许会对调用者有影响。
		
		因为参数是简单地赋值给传入的对象，函数能够就地改变传入的可变对象，结果会影响调用者。

	4、不变参数"通过值"进行传递。
		
		像整数和字符串这样的对象是通过对象引用而不是拷贝进行传递，但是因为你无论怎样都不能在
		原处修改不可变对象，实际的效果就很像创建看一份拷贝。
		
	5、可变对象是通过"指针"进行传递的。
		
		列表和字典这样的对象也是通过对象引用进行传递的，可变对象能够在函数内部进行原处的改变，
		这点和C数组很像。


参数和共享引用：

	def f(a):
		a = 99
	
	b = 88
	f(b)
	print(b)
		88

	在上面的例子中，使用f(b)调用函数的时候，变量a赋值了对象88，但是，a只是存在于调用的函数中。
	在函数中修改a对于调用的地方没有任何影响，它直接把本地变量a重置为一个完全不同的对象。

	对函数中参数名的赋值（a=99）,a 是一个引用，重新赋值，只是把引用a指向了新的对象，
	b这个引用指向的对象没有改变。


	def changer(a,b):
		a = 2
		b[0] = 'spam'


	X = 1
	L = [1,2]
	changer(X,L)
	print(X,L)

	上面代码中，changer函数给参数a赋值，并给参数b所引用的一个对象元素赋值。
	这两个函数内赋值语法相同但结构大相径庭

		1、因为a是在函数作用域内的本地变量名，第一个赋值对函数调用者没有影响，仅仅把本地变量a修改
		为引用一个完全不同的对象，并没有改变调用者作用域中的名称X的绑定。

		2、b也是一个本地变量，但是它被传给的是一个可变对象。第二个赋值时在原处发生的对象的改变，
		结果会影响L值。

	引用：参数。因为参数是通过赋值传递的，函数中的参数名可以在调用时通过变量实现共享对象。
	因为，函数中的可变对象参数的在原处修改能够影响到调用者。


避免可变参数的修改：

	在python中，默认通过引用(也就是指针)进行函数的参数传递：这就意味着不需要多个拷贝就可以在我们
	的程序中传递很大的对象，并且能够按照需要方便的更新这些对象。

	如果不想要函数内部在原处修改影响传递给它的对象，那么可以创建一个明确的可变对象的拷贝，对应函数参数
	我们总是能够在调用时对列表进行拷贝

	L=[1,2]
	changer(X,L[:])

	如果不想改变传入的对象，无论函数如果调用的，我们同样可以在函数内部进行拷贝。

	def changer(a,b):
		b = b[:]
		a = 2
		b[0] = 'spam'

	这两种拷贝机制都不会阻止函数改变对象：这样做仅仅是防止改变影响调用者。
	为了真正意义上的防止这些改变，我们讲可变对象转换为不可变对象，例如元组。

	L = [1,2]
	changer(X,tuple(L))
	这种原理会是内置函数tuple函数，将一个序列（可以任意可迭代对象）中的所有元素为基础创建一个新的元组。
	这种方式过于极端：强制函数写成不可改变传入参数的样子，对函数更多限制。


对参数输出进行模拟：

	return 能够返回任意中类的对象，所有能够返回多个值，如果这些值封装一个元组或其他的集合类型。

	def multiple(x,y):
		x = 2
		y = [3,4]
		return x,y

	X = 1
	L =[1,2]
	X,L = multiple(X,L)
	X,L
		(2, [3, 4])
	X
		2
	L
		[3, 4]

	M = multiple(X,L) 
	M
		(2, [3, 4])

	看起来代码好像返回了两个值，实际上只有一个，一个包含2个元素的元组，她的圆括号是可选的。
	在调用返回之后，我们能够使用元组赋值去分解这个返回元组的组成部分。

	X,Y,Z=(1,"aaaa",[2,3,4])
	X
		1
	Y
		"aaaa"
	Z
		[2, 3, 4]


特定的参数匹配模型：

	默认情况下，参数是通过位置进行匹配的，从左至右，而且必须精确地传递和函数头部参数名一样多的参数。
	还能通过定义变量名进行匹配，默认参数值，以及对额外参数的容器。

基础知识：

	位置：从左至右进行匹配

	关键字参数：通过参数名进行匹配
		调用者可以定义哪一个函数接受这个值，通过在调用时使用参数的变量名，使用name=value这种语法。
	
	默认参数：为没有传入值的参数定义参数值

	可变参数：收集任意多基于位置或关键字的参数
		函数能够使用特定的参数，它们是以字符*开头，收集任意多的额外参数（可变参数）

	可变参数解包：传递任意多的基于位置或关键字的参数
		调用者能够再使用*语法去将参数集合打散，分成参数。这个"*"与在函数头部的"*"恰恰相反；
		在函数头部它意味着收集任意多的参数，而在调用者中意味着传递任意多的参数。
	
	Keyword-only参数：参数必须按照名称传递。


匹配语法：

函数参数匹配表：

	语法                    位置                     解释
	
	func(value)           调用者                  常规参数：通过位置进行匹配
	func(name=value)      调用者                  关键字参数：通过变量名匹配
	func( *sequence)      调用者                  以name传递所有的对象，并作为独立的基于位置的参数
	func( **dict)         调用者                  以name成对的传递所有的关键字/值，并作为独立的关键字参数
	
	def func(name)        函数                    常规参数：通过位置或变量名进行匹配
	def func(name=value)  函数                    默认参数值,如果没有在调用中传递的话
	def func( *name)      函数                    匹配并收集（在元组中）所有包含位置的参数
	def func( **name)     函数                    匹配并收集(在字典中)所有包含位置的参数
	def func( *args,name) 函数                    参数必须在调用中按照关键字传递
	def func( *,name=value) 函数                  python3


细节：

	在函数调用中，参数必须以此顺序出现：任何位置参数（value）,后面跟着关键字参数(name=value)
	和*sequence形式的组合，后面跟着**dict形式。

	在函数头部，参数必须以此顺序出现：任何一般参数(name),紧跟着任何默认参数(name=value),如果有的话，后面是
	*name（python3中是*）的形式，后面跟着任何name或name=value keyword-only参数(python3)，后面跟着**name形式

	在调用和函数头部中，如果出现**arg形式的话，必须出现最后。
	
	Python内部必须适应一下的步骤来在赋值前进行参数匹配：

	1、通过位置分配非关键字参数。

	2、通过匹配变量名分配关键字参数。

	3、其他额外的非关键字参数分配到*name元组中。

	4、其他额外的关键字参数分配到**name字典中。

	5、用默认值分配给在头部未得到分配的参数。



任意参数的实例：

	*和**,是让函数支持接受任意数目的参数的。他们都可以出现在函数定义和函数调用中.

收集参数：
	
	1、在函数定义中，在元组中收集不匹配的位置参数
		
		def f( *args):print(args)
			...

	当这个函数调用时，python将所有位置相关的参数收集到一个新的元组中，并将这个元组赋值给变量args.
	因为它是一个一般的元组对象，能够索引或在一个for循环中进行步进。

	f()
		()
	
	f(1)
		(1,)
	
	f(1,2,3,4)
		(1,2,3,4)
	
	**特性类似，但是它只对关键字有效。将这些关键字参数传递给一个新的字典，这些字典能够用字典工具进行处理。
	在这种情况下，**允许将关键字参数转换为字典。

	def f( **args):print(args)
		...

	f()
		{}
	f(a=1,b=2)
	{'a':1,'b':2}

	最后，头部混合一般参数，*参数以及**去实现更加灵活的调用方式。
	def f(a,*pargs,**kargs):print(a,pargs,kargs)

	f(1,2,3,x=1,y=2)
		1 (2,3) {'y':2,'x':1}


解包参数：
	
	def func(a,b,c,d):
		print(a,b,c,d)
	...

	args = (1,2)
	args += (3,4)

	func( *args)
		1 2 3 4
	
	相似的，在函数调用时，**会以键/值对的形式解包一个字典，使其成为独立的关键字参数。

	args = {'a':1,'b':2,'c':3}
	args['d'] = 4
	func( **args)
		1 2 3 4



Python 3.0 Keyword-Only参数：
	
	python3把函数头部的排序规则通用化了，允许我们指定keyworld-only参数--即必须只按照关键字传递并且不会
	由一个位置参数来填充的参数。

	从语法上讲，keyword-only参数编码为命名的参数，出现在参数列表中的*args之后。所以这些参数都必须在调用
	中使用关键字语法来传递。例如:如下代码中，a可按照名称或位置传递，b收集任何额外的位置参数，c必须按照
	关键字传递。

	def kwonly(a,*b,c):
		print(a,b,c)

	kwonly(1,2,c=3)
		1 (2,) 3
	
	kwonly(a=1,c=3)
		1 () 3
	kwonly(1,2,3)
		TypeError: kwonly() missing 1 required keyword-only argument: 'c'

	我们也可以在参数列表中使用一个"*"符号，来表示一个函数不会接受一个变量长度的参数列表，而在"*"之后所有参数
	必须作为关键字传递。

	def kwonly(a,*,b,c):
		print(a,b,c)

	kwonly(1,c=3,b=2)
		1 2 3
	
	
	排序规则：
		注意keyworld-only参数必须在一个单星号后面指定，而不是两个星号---命名的参数不能出现在**args任意关键字
	形式的后面。并且一个**不能独自出现在参数列表中，下面两种做法都是错误：

		def kwonly(a,**pargs,b,c):
			SyntaxError: invalid syntax
		def kwonly(a,**,b,c):
			SyntaxError: invalid syntax

	意味着，在一个函数头部，keyword-only参数必须编写在**args任意关键字形式之前，且在*args任意位置形式之后。
	当二者都有的时候，无论何时，一个参数名称出现在*args之前，可能是默认位置参数，而不是keyword-only参数。

	def f(a,*b,**d,c=6):
		pirnt(a,b,c,d)

		SyntaxError: invalid syntax
	
	def f(a,*b,c=6,**d):
		pirnt(a,b,c,d)

	f(1,2,3,x=4,y=5)
		1 (2,3) 6 {'y':5,'z':4}

为何使用keyword-only参数：

	简而言之，他们使得允许一个函数既接收任意多个要处理的位置参数，也接受作为关键字传递的配置选项。



本章小结：

	举出三种以上函数和调用者能够交流结果的方法：
	
	函数可以用return语句，修改传入的可变参数以及通过设置全局变量来返回其结果。




"-------------------------------------------------------------------------------------------"

			第19章         函数的高级话题

"-------------------------------------------------------------------------------------------"

更高级函数的话题：递归函数、函数属性和注解、lambda表达式、如果map和filter这样的函数式编程工具。

函数设计概念：
	
	耦合性：
			对于输入使用参数并且对于输出使用return语句。
			只有在真正必须的情况下使用全局变量。
			不要改变可变类型的参数，除非调用者希望这样做。

	聚合性：
			每一个函数都应该有一个单一的、统一的目标。

	大小：
			每一个函数应该相对较小。

	耦合：
			避免直接改变在另一个模块文件中的变量。

递归函数：

	python支持递归函数--既直接或间接地调用自身以进行循环的函数。

	递归求和：
		def mysum(L):
			if not L:
				return 0
			else:
				return L[0] + mysum(L[1:])

		
		mysum([1,2,3,4,5])
			15

	
函数对象：属性和注解：

	python函数比我们想象中灵活，python函数是俯拾皆是的对象，自身全部存储在内存块中。
	同样，它们可以跨程序自由地传递和间接调用。它们支持与调用根本无关的操作--属性存储和注解。

	间接函数调用：

		pyhton函数是对象，可以赋值给其他名字、传递给其他函数、嵌入到数据结构、以及从一个函数返回给另一个函数，等等。

	在def运行之后，函数名直接是一个对象的引用--我们可以自由地把这个对象赋给其他名称并且通过任何引用调用它。
	def echo(message):
		print(message)

	echo('Direct call')
		Direct call

	X = echo
	X('Indirect call')
		indirect call

	X就是echo，他们是指向同一个对象。


	参数是通过赋值对象来传递，那么函数也可以作为参数传递给其他函数，调用者可以通过把参数添加括号
	中来调用传入的函数：

	def indirct(func,arg):
		func(arg)

	indirect(echo,'argument call!')
		argument call!

	
	我们可以把函数对象的内容填入到数据结构中，就像是整数或字符串一样。

	schedule = [(echo,'apam'),(echo,'ham')]
	for (func,arg) in schedule:
		func(arg)



	def make(label):
		def echo(message):
			print(label + ":" + message)
		return echo

	F = make('spam')
	F('ham')
		spam:ham



函数内省：

	
	函数是对象，我们可以用常规的对象工具来处理函数。

	def func(a):
		b = 'spam'
		return b*a

	func.__name__
		'func'
	dir(func)
		['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']


	内省工具允许我们探索实行细节--例如，函数已经附加了代码对象，代码对象提供了函数的本地变量和参数等方面的细节。
	func.__code__
		<code object func at 0x7ff4a0722030, file "<stdin>", line 1>

	dir(func.__code__)
		['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'co_argcount', 'co_cellvars', 'co_code', 'co_consts', 'co_filename', 'co_firstlineno', 'co_flags', 'co_freevars', 'co_kwonlyargcount', 'co_lnotab', 'co_name', 'co_names', 'co_nlocals', 'co_stacksize', 'co_varnames']

	func.__code__.co_varnames
		('a', 'b')

	工具编写者可以利用这些信息来管理函数


函数属性：

	函数对象不仅仅限制于系统定义的属性，也可能向函数附加任意的用意定义的属性：

	func
		<function func at 0x7ff4a06ba2f0>
	
	func.count = 0
	func.count += 1
	func.count
		1
	func.handles = 'Button-press'
	func.handles
		Button-press
	dir(func)
		['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'handles']

	这样属性可以直接把状态信息附加到函数对象，而不必使用全局、非本地和类其他技术。和非本地不同，这样属性
	可以在函数自身的任何地方访问。从某种意思上说，这也是模拟其他语言中的"静态本地变量"的一种方式。



python3中的函数注解：
	
	给函数对象附件注解信息--与函数的参数和结果相关的任意的用户定义的数据。python为声明注解提供了特殊语法。
	但是自身不做任何事情，注解完全是可选的，出现的时候只是直接附加到函数对象的__annotations__属性以供
	其他用户使用。

	从语法上，函数注解编写在def头部行，就像与参数和返回值相关的任意表达式一样。对应参数，它们出现在
	紧随参数名之后的冒号之后；对于返回值，它们编写于紧随参数列表之后的一个->之后。

	例如下面代码，注解了前面函数的3个参数以及返回值:

	def func(a:'spam',b:(1,10),c:float) -> int:
		return a + b + c
	func(1,2,3)
		6
	
	调用一个注解过的函数，像以前一样，不过，当注解出现的时候，python将它们收集到字典中并且将它们附加给函数
	对象自身。参数名变成键，如果编写了返回值注解的话，它存储的键"return"下，而键的值则赋给了表达式的结果。

	func.__annotations__
		{'a': 'spam', 'b': (1, 10), 'c': <class 'float'>, 'return': <class 'int'>}

	注解只是附加到python对象的python对象，注解可以直接处理。

	def func(a:'spam',b,c:99):
		return a+b+c
	
	func(1,2,3)
		6
	
	func.__annotations__
		{'a': 'spam', 'c': 99}

	for arg in func.__annotations__:
		print(arg,"=>",func.__annotations__[arg])


		a => spam
		c => 99

	
	注意两点，编写注解的话，仍然可以对参数使用默认值

	def func(a:'spam'= 4,b:(1,10)=5,c:float=6) ->int:
		return a + b +c
	
	func()
		15
	func(1,2,3)
		6
	func.__annotations__
		{'a': 'spam', 'b': (1, 10), 'c': <class 'float'>, 'return': <class 'int'>}


	最后：注解在def语句中有效，在lambda表达式中无效。因为lambda的语句已经限制了它所定义的函数工具。


匿名函数：lambda:
	
	lambda的一般形式是关键字lambda，之后是一个或多个参数，紧跟一个冒号，之后是表达式：

	lambda argument1,argument2,... argumentN:expression using arguments

	由lambda表达式所返回的函数对象与def创建并赋值的函数对象工作起来是完全一样的，但是lambda有一些不同之处
	让其扮演特定角色很有用：

		1、lambda是一个表达式，而不是语句。
			因为这一点，lambda能够出现在python语法不允许def出现的地方，例如：在一个列表常量中或者函数调用
			的参数中。此外，作为表达式，lambda返回一个值（一个新的函数），可以选择性赋值给一个变量名。
			相反，def语句总是得在头部将一个新的函数赋值给一个变量名，而不是将这个函数作为结果返回。

		2、lambda的主体是一个单个的表达式，而不是一个代码块。
			lambda主体好像放在def主体的returen语句中的代码一样。简单地将结果写成一个表达式，
		而不是明确的返回。

		def func(x,y,z):return x+y+z
		func(2,3,4)

		f = lambda x,y,z:x+y+z
		f(2,3,4)
	
	这里的f被赋值给一个lambda表达式创建的函数对象。也就是def所完成的任务，只不过def的赋值时自动进行的。

	默认参数也可以在lambda参数中使用，就像def中使用一样。
	
	X = (lambda a='fee',b='fie',c='foe':a+b+c)
	
	X("wee")
		weefiefoe

	在lambda主体中的代码和在def内的代码一样都遵循相同的作用域查找法则（LEGB）。

	def knights():
		title = 'Sir'
		action = (lambda x:title + '' + x)
		return action
	
	act = knights()
	act('robin')

	act
		<function knights.<locals>.<lambda> at 0x7f3b1499c400>
	act('robin')
		'Sirrobin'


为什么是用lambda

	lambda 通常用来编写跳转表，也就是行为的列表或字典，能够按照需要执行相应的动作。
	
	L = [lambda x:X**2,
		 lambda x:X**3,
		 lambda x:X**4]

	for f in L:
		print(f(2))
			
		4,8,16

	print(L[0](3))
		9
	
	lambda表达式作为def的一种速写来说最为有用。
	例如：在列表常量中嵌入lambda表达式创建一个含义三个函数的列表，def不会在列表中工作，因为def是语句。

	def f1(x):return x**2
	def f2(x):return x**3
	def f3(x):return x**4
	
	L = [f1,f2,f3]

	for f in L:
		print(f(2))

	print(L[0](3))


	当python创建字典时，每个嵌入的lambda都生成并留下能够调用的函数，通过键索引取回取出函数的调用。
	是一种更通用的多路分支工具。

	key = 'got'
	
	{'alreadly':(lambda:2+2),
		'got'     :(lambda:2*4),
		'one'	  :(lambda:2**6)
	}[key]()
		8


嵌套lambda 和作用域：
	
	lambda是嵌套函数作用域查找（LEGB中的E）的最大收益者。
	
	def action(x):
		return (lambda y:x + y)

	act = action(99)
	act(2)
		101
	

	action = (lambda x:(lambda y:x + y))
	act = action(99)
	act(3)
		102
	这里嵌套的lambda结构让函数调用时创建了一个函数，无论哪种情况，嵌套的lambda代码都能获取上层lambda函数
	中的变量x。


在序列中映射函数：map

	程序对列表和其他序列常常要做的一件事就是对每一个元素进行操作并把结果结合起来。
	map函数会对序列对象中每一个元素应用被传入的函数，并且返回一个包含了所有函数调用结果的一个列表。

	conters = [1,2,3,4]
	def inc(x):return x+10
	list(map(inc,counters))
		[11,12,13,14]
	map对每一个列表中的元素调用了inc函数，并将所有的返回值收集到一个新的列表中。

	list(map((lambda x:x+3),counters))


	map更高级的用法：例如，提供过个序列作为参数，能够并行返回分别以每个序列中的元素作为函数对应
	参数得到的结果的列表。

	list(map(pow,[1,2,3],[2,3,4]))
		[1,8,81]    #1**2,2**3,3**4
	

函数式编程工具：filter和reduce

	函数式编程的意思就是对序列应用一些函数的工具。
	基于某一测试函数过滤出一些元素(filter),以及对每对元素都应用函数并运行到最后结果（reduce）
	list(range(-5,5))
		[-5,-4,-3,-2,-1,0,1,2,3,4]
	list(filter((lambda x:x>0),range(-5,5)))
		[1,2,3,4]


	form functools import reduce
	reduce((lambda x,y:x+y),[1,2,3,4])
		10
	reduce((lambda x,y:x*y),[1,2,3,4])
		24


本章小结：
	
	1、def语句和lambda表达式有什么关系？
	
		lambda和def都会创建函数对象，不过，lambda可以用在def语法无法使用的地方，lambda总是可以用def来替代，
		并且，通常变量名来引用函数。

	2、使用lambda的要点是什么？
		lambda允许"内联"小单元可执行代码，推迟其执行，并且以默认参数和封闭作用域变量的形式为提供状态。






"--------------------------------------------------------------------------------------------------"

				第20章          迭代和解析，第二部分		

"--------------------------------------------------------------------------------------------------"

列表解析：
	
列表解析与map:
	
	列表解析是在一个序列的值上应用一个任意表达式，将其结果收集到一个新的列表中并返回。
	从语法上来说：列表解析是由方括号封装起来的，它们是简单形式是方括号中编写一个表达式，其中的变量，在后面
	跟随着的看起来像一个for循环的头部一样的语句，有着相同的变量名的变量。

	[x **2 for x in range(10)]
		[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

	list(map((lambda x:x ** 2),range(10)))
		[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

增加测试和嵌套循环：

	[x for x in range(5) if x % 2 == 0]
		[0, 2, 4]
	
	list(filter((lambda x:x%2==0),range(5)))
		[0, 2, 4]


	列表解析还能更加通用，在一个列表解析中编写任意数量的嵌套的for循环，并且都可以管理if测试。

	[expression  for target1 in interable1 [if condition1]
				 for target2 in interable2 [if condition2]
				 for targetN in interableN [if conditionN]]

	res = [x + y for x in [0,1,2] for y in [100,200,300]]
	res
		[100, 200, 300, 101, 201, 301, 102, 202, 302]
	
	效果和下面代码相同：
		res = []
		for x in [0,1,2]:
			for y in [100,200,300]:
				res.append(x+y)

		res
		[100, 200, 300, 101, 201, 301, 102, 202, 302]


	[(x,y) for x in range(5) if x%2 == 0 for y in range(5) if y %2==1]
		[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]
	效果和下面相同：
		res = []
		for x in range(5):
			if x%2 == 0:
				for y in range(5):
					if y%2 == 1:
						res.append((x,y))
		res
			[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]



列表解析和矩阵:
	
	python编写矩阵的基本方法就是使用嵌套的列表结构。
	
	M = [[1,2,3],
		 [4,5,6],
		 [7,8,9]]

	我们通过通过对行进行迭代，之后从所需的列表中提取出元素。
	
	[row[1] for row in M]
		[2,5,8]
	
	[M[row][1] for row in (0,1,2)]
		[2, 5, 8]
	
	[M[i][i] for i in range(len(M))]
		[1, 5, 9]

用列表解析来混合多个矩阵，通过嵌套的列表解析来构建具体相同值的嵌套列表结构

	M = [[1,2,3],
		 [4,5,6],
		 [7,8,9]]
	
	N = [[2,2,2],[3,3,3],[4,4,4]]
	
	
	[M[row][col] * N[row][col] for row in range(3) for col in range(3)]	
		[2, 4, 6, 12, 15, 18, 28, 32, 36]


为什么使用列表解析
	
	列表解析运行更快，比for循环快很多，列表解析还能作为一种列表选择操作使用。


重访迭代器：生成器:

python对延迟提供更多支持---它提供了具体需要的时候才产生结果，而不是立刻产生结果。

	有两种语句结构尽可能延迟结果创建
	
	1、生产器函数：编写常规的def语句，但是使用yield语句一次返回一个结果，在每个结果之间挂起和继续它们的状态

	2、生产器表达式类似于上一节的列表解析，但是，它们返回按需要产生结果的一个对象，而不是构建一个结果列表。

	两者都是通过迭代协议来执行它们延迟结果的魔术。


生产器函数：yield VS return

	生产器函数：函数可以送回一个值并随后从其退出的地方继续的函数，这样的函数叫做生成器函数。
	生成器函数和常规函数一样，都是def语句编写，然而，创建时，它们自动实现迭代协议。

	状态挂起：
		常规函数返回一个值并退出，而生成器函数自动在生产值的时刻挂起并继续函数的执行。
		因此，它们对应提前计算整个一系列值以及在类中手动保存和恢复状态都很有用。
		生成器函数在挂起时保存的状态包含它们整个本地作用域，当函数恢复时，本地变量保持了信息并且使其可用
	
		生成器函数和常规函数主要的代码区别不同之处在于，生成器yields一个值，而不是返回一个值。
		yield语句挂起该函数并向调用者发送一个值，但是，保留足够的状态使得函数能够从它离开的地方继续。
		当继续时，函数在yield返回后立即继续执行。

		从函数的角度看，这允许代码随着时间产生一系列的值，而不是一次计算它们所有值。

	
	迭代协议整合：

		为了支持迭代协议，生成器函数包含一条yield语句，该语句特别编译为生成器。
		当调用时，它们返回一个迭代器对象，该对象支持用一个名为__next__的自动创建的方法来继续执行的接口。
		生成器函数也可能有一条return语句，总在def语句末尾，直接终止值的生成。

		从技术上讲，可以在任何常规函数退出执行之后，引发一个StopIteration异常来实现，从调用者的角度
		生成器的__next__方法继续函数并且运行到下一个yield结果返回或引发一个StopIteration异常。


	生成器函数应用：
		下段代码定义了一个生产器函数
		def gensquares(N):
			for i in range(N):
				yield i**2

		这个函数每次循环都会产生一个值，之后将其返回给调用者。当它被暂停后，它的上一个状态保存了下来，
		并且在yield语句之后控制器马上被收回。
	
		当用在一个for循环时，在循环中每一次完成函数的yield语句后，控制权都会返还给函数。

		for i in gensquares(5):
			print(i,end=':')
			
			0:1:4:9:16:

		看看在for里面发生了什么，直接调用一个生成器函数：
		x = gensquares(4)
		x 
			<generator object gensquares at 0x7f720c09c150>
		得到一个生成器对象，支持迭代协议，也就是说生成器对应有一个__next__方法，它可以开始这个函数，或者
		从它上次yield值后的地方恢复，得到一系列值，产生StopIteration异常。
		next(x)
			0
		next(x)
			1
		next(x)
			4
		next(x)
			9
		next(x)
			Traceback (most recent call last):
				StopIteration

		有了生成器，函数变量就能进行自动的保存和恢复。


	扩展生成器函数协议：send和next

		生成器函数协议中增加了一个send的方法，send方法生产一系列结果的下一个元素，这一点像__next__方法一样
		但是它也提供了一种调用者与生成器之间进行通信的方法，从而能够影响它的操作。

		从技术上说，yield现在是一个表达式的形式，可以返回传入的元素来发送，而不是一个语句。表达式必须
		包含在括号中，除非它是赋值语句右边的唯一一项。例如，x = yield Y 没有问题，就如同X = (yield Y) + 42

		使用额外协议时，值可以通过调用G.send(value) 发送给一个生成器G.之后恢复生成器的代码，并且生成器
		中的yield表达式返回了为了发送而传入的值，如果提前调用了正常的G.__next__()方法，yield返回None。

		def gen():
			for i in range(10):
				X = yield i
				print(X)

		G= gen()
		next(G)
			0
		G.send(77)
			77
			1
		G.send(88)
			88
			2
		next(G)
			None
			3


生成器表达式：迭代器遇到列表解析：

	迭代器和列表解析的概念形成了这种语言的新的特性--生成器表达式。
	从语法上来说：生成器表达式就像一般的列表解析一样，但是它们是括在圆括号中而不是方括号中。

	[x **2 for x in range(4)]
		[0,1,4,9]
	(x**2 for x in range(4))
		<generator object <genexpr> at 0x7fc18efa7db0>

	在一个list内置调用中包含一个生成器表达式以迫使其一次生成列表中所有的结果。

	list(x**2 for x in range(4))
		[0, 1, 4, 9]

	生成器表达式很不相同：不是在内存中构建结果，而是返回一个生成器对象，这个对象将会支持迭代协议并在任意
	的迭代语境的操作中。

	G = (x**2 for x in range(4))
	next(G)
		0
	next(G)
		1
	next(G)
		4
	next(G)
		9
	next(G)
		Traceback
		StopIteration

	我们不会机械使用next迭代器来操作生成器表达式，因为for循环会自动触发。
	for num in (x**2 for x in range(4))
		print(num,end=' ') 
	
		0 1 4 9

	每一迭代的语句都会这样，包括：sum、map和sorted等内置函数，以及其他迭代语境：any、all、list。

	sum(x**2 for x in range(4))
		14
	sorted(x**2 for x in range(4))
		[0, 1, 4, 9]
	
	生成器表达式大体上可以认为是对内存空间的优化，不需要方括号列表解析一样，一次构造出整个结果列表。


生成器函数 VS 生成器表达式：

	同样的迭代往往可以用一个生成器函数或一个生成器表达式编写。如下:

	G = (c*4 for c in 'SPAM')
	list(G)
		['SSSS', 'PPPP', 'AAAA', 'MMMM']
	
	def timesfour(S):
		for c in S:
			yield c*4
	G = timesfour('SPAM')
	list(G)
		['SSSS', 'PPPP', 'AAAA', 'MMMM']

	

生成器是单迭代器对象：
	
	生成器函数和生成器表达式自身都是迭代器。
	
	G = (c*4 for c in 'SPAM')
	iter(G) is G
		True

	如果你使用多个迭代器来迭代结构流
	G = (c*4 for c in 'SPAM')
	T1 = iter(G)
	next(T1)
		'SSSS'
	next(T1)
		'PPPP'
	T2 = iter(G)
	next(T2)
		'AAAA'
	next(T1)
		'MMMM'
	next(T2)
		Traceback (most recent call last):
			StopIteration
	T3 = iter(G)
	next(T3)
		StopIteration

	T3 = iter(c*4 for c in 'SPAM')
	next(T3)
		'SSSS'
	
	一旦迭代器运行到完成，所有的迭代器都将用尽，必须产生一个新的生成器以再次开始。

	与某些内置类型的行为不同，它们支持多个迭代器并且在一个活动迭代器中传递并反映它们的原处修改。
	
	L = [1,2,3,4]
	T1,T2 = inter(L),inter(L)
	next(T1)
		1
	next(T2)
		1




python3 解析语法概括：

	对于集合，新的常量形式{1,3,2}等同于set([1,3,2]),并且新的集合解析语法{f(x) for x in S if P(x)}
	就像是生成器表达式set(f(x) for x in S if P(x)),其中f(x)是一个任意表达式。

	对于字典，新的字典解析语法{key:val for (key,val) in zip(keys,vals)}像dict(zip(keys,vals))形式一样工作
	并且{x:f(x) for x in items}像生成器表达式dict((x,f(x)) for x in items)一样工作。


解析集合和字典解析：

	从某种意义上，集合解析和字典解析只是把生成器表达式传递给类型名的语法糖。
	因此，两者都接受任何的可迭代对象，一个生成器在这里工作的很好。

	{x*x for x in range(10)}
		{0, 1, 64, 4, 36, 9, 16, 49, 81, 25}

	set(x*x for x in range(10))
		{0, 1, 64, 4, 36, 9, 16, 49, 81, 25}

	{x:x*x for x in range(10)}
		{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
	
	dict((x,x*x) for x in range(10))
		{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}

	

对迭代的各种方法进行计时：

	对模块计时：
	import time
	reps = 1000
	repslist = range(reps)

	def timer(func,*pargs,**kargs):
		start = time.clock()
		for i in repslist:
			ret = func( *pargs,**kargs)
		elapsed = time.clock() - start
		return(elapsed,ret)

	
	计时脚本：
		import sys,mytimer
		reps = 10000
		repslist = reange(reps)

		def forLoop():
			res = []
			for x in repslist:
				res.append(abs(x))
			return res

		
		def listComp():
			return [abs(x) for x in repsList]

		print(sys.version)
		for test in(forLoop,listComp):
			elapsed,result = mytimer.timer(test)
			print('_'*33)
			print('%-9s:%.5f')%(test.__name__,elapsed)




函数陷阱：

本地变量是静态检测的：
	
	python定义一个函数中进行分配的变量名是默认本地变量的，它们存在于函数的作用域并只在函数运行时存在。
	Python是静态检测python的本地变量的，当编译def代码时，不是通过发现赋值语句在运行时进行检测的。
	这导致了python新闻组最常见陷阱之一。

	x = 99
	def selector():
			print(x)

	selector()
		99

	x = 99
	def selector():
		print(x)
		X = 88

	selector()
		Traceback (most recent call last):
		UnboundLocalError: local variable 'X' referenced before assignment
	
	得到一个未定义变量名的错误，原因很微妙，Python看到了对X赋值语句，并且决定X将会在函数中的任一地方都将是
	本地变量名，但是，在函数实际运行时，因为在print执行时赋值语句并没有发生，python告诉你正在使用一个未定义
	的变量名。根据变量名规则，本地变量X是在其被赋值前就使用了。实际上，任何在函数体内赋值将会使其成为一个
	本地变量名。Import、=、嵌套def、嵌套类等。都会受到行为影响。

	产生的原因在于被赋值的变量名在函数内部是当作本地变量来对待的，而不是仅仅在赋值以后的语句中才被当作是本地
	变量。


	如果你希望打印全局变量：
	x = 99
	def selector():
		global x
		print(x)
		x = 88

	selector()
		99

	这个位置的赋值语句同样会改变全局变量X,而不是一个本地变量。

	x = 99
	def selector():
		import __main__
		print(__main__.x)
		x = 88
		print(x)

	selector()
		99
		88


默认和可变对象:
	
	默认参数是在def语句运行时评估并保存的，而不是在这个函数调用时。
	从内部来讲，python会将每一个默认参数保存成一个对象，附件在这个函数本身。

	因为默认参数是在def时被评估的，如果必要的话，它能够从整个作用域内保存值，但是因为默认参数在调用之间都保存了
	一个对象，必须对修改可变默认参数十分小心。

	下面一个空列表作为默认参数，并在函数每次调用时对他进行了改变。

	def saver(x=[]):
		x.append(1)
		print(x)
	
	saver([2])
		[2, 1]
	saver()
		[1]
	saver()
		[1, 1]
	saver()
		[1, 1, 1]

	从某种意义上充当C语言中静态本地函数变量的角色。

	如果你不想要这样，在函数主体的开始对默认参数进行简单拷贝，或者将默认参数值的表达式移至函数内部。

	def saver(x=None):
		if x is None:
			x = []
		x.append(1)
			print(x)

	saver(2)
		[2,1]
	saver()
		[1]
	saver()
		[1]

	一种实现默认效果的另一种方式：
		def saver():
			saver.x.append(1)
			print(saver.x)

		saver.x = []
		saver()
			[1]
		saver()
			[1, 1]
		saver()
			[1, 1, 1]
	
	
	
没有return语句的函数:
	
	没有return语句，函数字符返回None对象。
	
	def prox(x):
			pirnt(x)

	x = proc('testing 123...')

	print(x)
		None
	
	list = [1,2,3]
	list = list.append(4)
	print(list)
		None

本章小结:

	1、生成器和迭代器有什么关系？
	生成器是支持迭代协议的对象。






	

"==============================================================================================="

			         第五部分            模块

"=============================================================================================="
	
"---------------------------------------------------------------------------------------------"
	
				第21章   模块：宏伟蓝图								

"---------------------------------------------------------------------------------------------"

python模块是最高级别的程序组织单元，它将程序代码和数据封装起来以便重用。

每一个文件都是一个模块，并且模块导入其他模块之后就可以使用导入模块定义的变量名。

模块可以由两个语句和一个重要的内置函数进行处理:

	import	
		使客户端（导入者）以一个整体获取一个模块
	from
		允许客户端从一个模块文件中获取特定的变量名。
	imp.reload
		提供了一种重新载入模块文件代码的方法。


为什么使用模块：

	1、代码重用

	2、系统命名空间的划分

	3、实现共享服务和数据


Python 程序架构：
	
	一个程序是一个模块的系统。它有一个顶层脚本文件（启动后可运行程序）以及多个模块文件(用来导入工具库)。
	脚本和模块都是包含了python语句的文本文件，尽管在模块中的语句通常都是创建之后使用的对像。

	例子：
	
	在b.py中包含一个python的def语句来生产函数
		def  spam(text):
			print(text,'spam')

	现在,假设a.py想要使用spam，为了实现这个目标，a.py中执行
		import b
		b.spam('gumby')

	首先，一个python import语句，给文件a.py提供了由文件b.py在顶层所定义的所有对象的访问权限。
	概括来讲，就是“载入文件b.py”，并通过变量名b获取它的所有的属性。


标准库模块：
	
	程序导入的模块是由python自身提供的，而并非是程序员所编写的文件。
	Python自带了很多实用模块，称为标准链接库，这个集合大约有200个模块。

import如何工作:
	
	导入模块不应该和C语言的#include比较，在python中，导入并非只是把一个文件文本插入另一个文件而已。
	导入其实是运行时的运算，程序第一次导入指定文件时，会执行三个步骤：
		
		1、找到模块文件
		2、编写成位码（需要时）
		3、执行模块的代码来创建其所定义的对象。
		
	从技术上讲，pyhton把载入的模块存储到一个名为sys.modules的表中，并在一次导入操作的开始检查该表
	如果模块不存在，将会启动一个三步骤的过程。

	1、搜索：
		首先，Python必须找出到import语句所引用的模块文件。
		上例中，只有import b,没有目录路径，事实上，路径和后缀是刻意省略掉的，因为python使用了标准模块
		所搜路径来找出import语句所对应的模块文件。

		搜索模块有些是预先定义，而其中有些可以进行调整告诉Python去哪里所搜：
		
		1、程序的主目录
		2、PYTHONPATH目录（如果已经进行了设置）
		3、标准链接库目录
		4、任何.pth文件的内容（如果存在的话）
		四个文件组合起来就变成了sys.path。

	2、编译（可选）
		找到符合import语句的源代码文件后，如果必须的话，python会编译成字节码。

	3、运行
		import操作的最后步骤是执行模块的字节码。此步骤中任何对变量名的赋值运算，都会产生所得到的模块
		文件的属性。
	

sys.path列表：
	
	如果你看机器上实际配置，可以通过打印sys.path列表来查看路径。
	import sys
	sys.path
		
		['', '/usr/local/Python-3.6.4/lib/python36.zip', '/usr/local/Python-3.6.4/lib/python3.6', '/usr/local/Python-3.6.4/lib/python3.6/lib-dynload', '/usr/local/Python-3.6.4/lib/python3.6/site-packages']



本章小结：
	
	1、模块源代码文件是怎样变成模块对象的？
		
		模块的源代码文件在模块导入时，自动生成模块对象。
		从技术角度讲，模块的源代码在导入时运行，一次一条语句，而在这个过程中赋值的所有变量名都会生成模块对象的属性。
	
	2、为什么需要设置PYTHONPATH环境变量
		
		只需设置PYTHONPATH,从而可以从正在用的目录以外的其他目录进行导入。
	
	3、python可能载入的能够响应import操作的四种文件类型。
		
		源代码文件（.py）、字节码文件(.pyc)、C扩展模块以及相同变量名的目录。
	
	4、什么是命名空间？模块的命名空间包含什么？
		
		命名空间是一种独立完备的变量包，而变量就是命名空间对象的属性。
		模块的命名空间包含了代码在模块文件顶层赋值的所有变量名。





"--------------------------------------------------------------------------------------------"

				第22章     模块代码编写基础

"--------------------------------------------------------------------------------------------"

python模块的创建很简单，只不过是用文本编辑器创建的python程序代码文件而已。

如果名为modulel.py的文件中输入下面def语句
	def printer(x)：
		print(x)

import 语句:
	
	变量名module1有两个不同目的：识别被载入的外部文件，同时会生成脚本中的变量，在文件加载后，用来引用模块对象。
	import module1
	module1.printer('hello world')
		hello world

from语句：
	
	form会把变量名赋值到另一个作用域，所以它就可以让我们直接在脚本中使用赋值的变量名，不需要通过模块
	from module1 import printer
	printer('hello world')
		'hello world'

	from *语句：

	当我们使用*时，会取得模块顶层所以赋了值的变量名的拷贝。
	from module1 import *
	printer('hello world')
		'hello world'

	把模块中所有变量名赋值到进行导入的作用域之内，从根本上来说，就是让一个模块的命名空间融入另一个模块之中。



import和from是赋值语句：

	就像def一样，import和from是可执行的语句，而不是编译期间的声明，换句话来说，被导入的模块和变量名，直到它们所
	对应的import或from语句执行后，才可以使用。此外，就像def一样，import和from都是隐形的赋值语句。

	import 将整个模块对象赋值给变量名
	from将一个或多个变量名赋值给另一个模块中同名的对象。

	我们谈过关于赋值语句方面的内容，也使用模块的读取，例如from复制的变量名会变成共享对象的引用。
	
	例如文件：small.py
		x = 1
		y = [1,2]


	from small import x,y
		x = 42
		y[0] = 42

	此次，x不是一个共享的可变对象，单y是，导入者中变量名y和被导入者引用相同的列表对象，一个地方修改，影响其他地方。

	import small
	small.x
		1
	smll.y
		[42,2]

	"调用者"和"函数"   如同 "被导入模块" 和"导入者"


import  和 from 的对等性：

	一个像这样的from语句：
	from module import name1,name2
	
	等效于：
	import module
	name1 = module.name1
	name2 = module.name2


from语句潜在的陷阱：

	from语句有破坏命名空间的潜质，从理论上讲，使用from导入变量，而那些变量碰巧和作用域中出现的现有的变量名，
	变量就会被悄悄的覆盖掉。使用简单import语句就不存在这个问题。


何时使用import:
	
	当必须用两个不同的模块内定义的相同变量名的变量时，才真的必须使用import.这种情况下不能使用from。
	# M.py
		def func():
			...do something...
	# N.py
		def func():
			...do something else...

	而你必须在程序中使用这两个版本的变量名时，from语句就不能用，作用域内一个变量名只能有一个赋值语句
	# O.py
	form M import func
	form N import func
	func()            #calls N.func only


	#O.py
	
	import M,N
	M.func()
	N.func()



模块命名空间：

	模块就是命名空间，而在于模块之内的变量名就是模块对象的属性。

文件生产命名空间:
	
	文件如何变成命名空间呢?简而言之，在模块文件顶层（也就是不在函数或类的主体内）每一个赋值了的变量名
	都会变成改模块的属性。

	我们需要正式说明模块和作用域的概念以了解其原因：
		
		1、模块语句会在首次导入时执行。
			模块第一次导入时，无论在什么地方，python都会建立空的模块对象，并逐一执行该模块文件内的语句。
			
		2、顶层的赋值语句会创建模块属性：
			
		3、模块的命名空间能够通过属性__dict__或dir获取。

		4、模块是一个独立的作用域


属性名的点号运算：

	在python之中，可以使用点号运算语法object.attribute获取任意的object的attribute属性。

	点号运算其实就是表达式，传回和对象向匹配饿属性名的值。
	点号运算和作用域法则没有关系，LEGB规则只适用于无点号运算的纯变量名。以下其规则：

		1、简单变量
			X是指在当前作用域内搜索变量名X(遵循LEGB规则)
		2、点号运算
		    X.Y 是指当前范围搜索X，然后搜索对象X之中的属性Y
		3、多层点好运算
			X.Y.Z 指的是寻找对象X之中的变量名Y,然后再找对象X.Y之中的Z。
		4、通用性
			点号运算可用于任何具有属性的对象：模块、类、c扩展类型。


重载模块：
	
	模块程序代码默认只对每个过程执行一次，要强制是模块代码重新载入并重新运行，要刻意要求python这么做，
	也就是调用reload内置函数。如果使用reload让系统变得更加动态。简而言之：
		1、导入（无论import还是from）只会模块在流程中第一次导入时，加载和执行该模块代码

		2、之后的导入只会使用已加载的模块对象，而不会重载或重新执行文件的代码。

		3、reload函数会强制己加载的模块的代码重新载入并重新执行，次文件中新的代码的赋值语句会在适当的地方修改
			现有模块对象。
	
	reload函数可以修改程序的一些部分，而无需停止整个程序。

reload基础：

	import 和from不同的是:

	1、reload是python中的内置函数，而不是语句

	2、传给reload的是已经存在的模块对象，而不是变量名

	3、reload在python3中位于模块之中，并且必须导入自己

	reload会在适当的地方修改模块对象，reload并不会删除并重建模块对象。因此，程序中任何引起该模块对象的地方，自动回受到reload的影响。
	
	1、reload 会在模块当前命名空间内执行模块文件的新代码。

	2、文件中顶层赋值语句会使得变量名换成新值。

	3、重载会影响所有使用import读取了模块的客户端。

	4、重载只会对一后使用from的客户端造成影响。



本章小结：

	1、怎么创建模块？
		
		只需要编写一个包含python语句的文本文件就可以了，每一个文本文件都会自动成为模块。
	
	2、reload函数和导入有什么关系
		
		默认，模块是每个进程只导入一次，reload函数会强制模块再次被导入，基本上都是用于开发过程中选取
		模块源代码的新版本，或者动态定制的场景中。

	3、form语句的三个陷阱？
		
		from语句让变量含义模糊，通过reload调用时会有问题，破坏命名空间。from *形式有多数情况下很糟糕；
		严重污染命名空间。

	



"------------------------------------------------------------------------------------------------------"

				    第23章   模块包

"------------------------------------------------------------------------------------------------------"

	除了模块名之外，导入也可以指定目录路径。python代码目录就称为包，因此，
	这类导入就称为包导入事实上，包导入时把计算机上的目录变成另一个Python命名空间，而属性则对应目录中的包含的子目录和模块文件。


包导入基础：
	
	包导入时如果运作？在import语句中列举简单文件名的地方，可以改成列出路径名称，彼此以点号相隔。
	import dir1.dir2.mod

form 语句也一样：

	from dir1.dir2.mod import x 
	
	这些语句中的“点号”路径是对应机器上的目录层次路径，通过这个路径可以获得文件mod.py。

__init__.py包文件:
	
	如果选择包导入，必须遵循一条约束：包导入语句的路径中的每个目录内都必须有__init__.py这个文件，否则导入包
	会失败。像下面这样目录结构：
	dir0\dir1\dir2\mod.py
	以这种形式的import语句：
	import dir1.dir2.mod
	
	必须遵循下列规则：
		1、dir1 和 dir2中必须都含有一个__init__.py文件
		2、dir0是容器，不需要__init__.py文件，如果有的话。这个文件也可以额忽略
		3、dir0必须列在模块搜索路径上（也就是说此目录必须是主目录，或者列在PYTHONPATH之中）

	__init__.py可以包含python程序代码，就像普通文件，这类文件从某种程度上像python的一种声明，可以是空的。
	作为声明，这些文件可以防止有相同名称的目录不小心隐藏在模块搜索路径中，而之后才出现真正所需的模块。


为什么要使用包导入：
	
	包让导入更具有信息性，并可以作为组织工具，简化模块的搜索路径，而且可以解决模糊性。

相对导入基础知识：
	
	from语句现在可以使用前面的点号(".")来指定，它们需要位于同一包中的模块(所谓的包的相对导入)，
	而不是位于模块导入搜索路径某处的模块（叫做决定导入）。
	
	如下面语句：
	from . import spam
	告诉python把位于语句中给出的文件相同包路径中的名为spam的一个模块导入。类似的语句还有：
	
	form .spam import name
	意味着“从名为spam的模块导入变量name，而这个spam模块域包含这条语句的文件位于同一个包下”。

相对导入作用域：
	
	1、相对导入适用于只在包内导入
	2、相对导入只是用于from语句。
	3、术语含糊不清



本章小结：
	
	1、模块包目录内的__init__.py文件有何用途？
		用于声明和初始化模块包。

	2、每次引用包的内容时，如何避免重复的包我完整路径？
		通过from语句使用包，直接把包的变量名复制出来，或者使用import语句的as扩展功能，把路径改为较短的别名。





"-------------------------------------------------------------------------------------------------------"

		         	第24章  高级模块话题

"--------------------------------------------------------------------------------------------------------"

本章为第五部分结尾：数据隐藏、__future__模块、__name__变量、sys.path修改、列表工具、通过名称字符串来运行模块、过渡式重载等。


在模块中隐藏数据：

	最小化from *的破坏：_X和__all__:
		
		在特定情况下，把下划线放在变量名的前面(例如，_X)，可以防止客户端使用from *语句导入模块名时，把其中
	的那些变量名复制出去。下划线不是“私有”声明：你还是可以使用其他导入形式看见并修改这类变量名。例如import语句。

	此外，也可以在模块顶层把变量名的字符串列表赋值给变量名__all__,以达到类似_X命名惯例的隐藏效果。
	__all__=["Error","endcode","decode"]
	使用此功能时，form *语句只会把列在__all__列表中的这些变量赋值出来。事实上，这和_X惯例相反。
	和_X惯例一样，__all__只对from *语句这种形式有效，它并不是私有声明。



启用以后的语言特性：

	from __future__ import featurename
	语句位于文件顶端，开启特殊的代码编译。


混合用法模式：__name__ 和 __main__:
	
	模块是对象，并且所有的模块都有一个内置属性 __name__。一个模块的 __name__ 的值取决于您如何应用模块。
	如果 import 一个模块，那么模块__name__ 的值通常为模块文件名，不带路径或者文件扩展名。
	但是您也可以像一个标准的程序样直接运行模块，在这 种情况下, __name__ 的值将是一个特别缺省"__main__"。


修改模块搜索路径:

	实际上，修改搜索路径，也就是修改名为sys.path的内置列表。
	import sys
	sys.path
		['', '/usr/local/Python-3.6.4/lib/python36.zip', '/usr/local/Python-3.6.4/lib/python3.6', '/usr/local/Python-3.6.4/lib/python3.6/lib-dynload', '/usr/local/Python-3.6.4/lib/python3.6/site-packages']['', '/usr/local/Python-3.6.4/lib/python36.zip', '/usr/local/Python-3.6.4/lib/python3.6', '/usr/local/Python-3.6.4/lib/python3.6/lib-dynload', '/usr/local/Python-3.6.4/lib/python3.6/site-packages']
	
	sys.path = [r'd\temp']
	sys.path.append('c:\\l[4e\\example]')
	sys.path
		['d:\\temp','c:\\lp4e\\example']

	import string
		ImportError:No module named string


import语句和from语句的as扩展：
	
	import modulename as name
	相当于：
		import modulename
		name = modulename
		del modulename
	在这类import之后，使用列在as之后的变量名来引用该模块。from语句也可以这么用，从某个文件导入的变量名，赋值
	给脚本中的不同的变量名。
		from modulename import attrname as name
	使用as，可以避免变量名冲突。


模块是对象：元程序：
	
	因为模块通过内置属性显示了它们的大多数有趣的特性，因此，可以很容易地编写程序来管理其他程序。
	我们通常称这类管理程序为元程序，因为它们是在其他系统之上工作。也称为内省，因为其他程序能看见和处理对象
	的内部，内省是高级功能，也可以用在创建程序的工具。

	例如：要取得M模块内名为name的属性，可以使用结合点号运算，或者对模块的属性字典进行索引运行
	(在内置__dict__属性中显示)，python也在sys.modules字典中导出所有已加载的模块列表（也就是sys模块的modules属性）
	并提供一个内置函数getattr,让我们以字符串取出属性。
	因此，下面的表达式都会得到相同的属性和对象。
		M.name
		M.__dict__['M'].name
		sys.modules['M'].name
		getattr(M,'name')


模块的设计理念：
	
	1、总是在python的模块内编写代码
	2、模块耦合要降到最低：全局变量
	3、最大化模块的粘合性：统一目标
	4、模块应该少去修改其他模块的变量。



模块陷阱：

	1、from复制变量名，而不是连接
	2、from *会让变量语义模糊
	3、reload不会影响from导入
	4、reload、from以及交互模式测试
	5、递归形式的from导入无法工作




本章小结：

	1、当模块的__name__变量是字符串"__main__"时，代表什么意义？
		代表改文件是作为顶层脚本运行的，而不是被程序中另一个文件所导入的，也就是说，这个文件作为程序在使用，
		而不是一个库。

	2、如果用户通过交互模式输入模块的变量名进行测试，你改怎样进行导入？
		通过字符串导入所引用的模块，可以创建import语句并通过exec执行，或把字符串传给__import__函数进行调用。

	3、改变sys.path和设置PYTHONPATH来修改模块搜索路径有什么不同?
		
		修改sys.path只是影响一个正在运行的程序，是暂时的，程序结束，修改会消失。
		PYTHONPATH设置是存在操作系统中，所有机器上是程序都会使用，而且设置修改会保存。
		
	4、如果模块__future__可让我们导入未来，那我们也能导入过去吗?
		不能，无法导入过去，可以安装旧版，但是最新的就是最好的。
	


"======================================================================================================"

					第六部分  类和OOP

"======================================================================================================"

"-----------------------------------------------------------------------------------------------------"
	
				第25章  OOP：宏伟蓝图

"-----------------------------------------------------------------------------------------------------"

编写类树：
	
	1、每个class语句会生产一个新的类对象
	
	2、每次类调用时，就会生产一个新的实例对象
	
	3、实例自动连接至创建了这些实例的类
	
	4、类连接其超类的方式是，将超类类在类头部的括号中。其从左至右的顺序会决定树中的次序。
		class c1(c2,c3)

本章小结：
	
	1、python的oop的重要意义是什么？
		
		OOP就是代码重用：分解代码、最小化代码的冗余以及对现有代码进行定制来编写代码，而不是实时修改代码，或从头开始。

	2、继承搜索在哪里查找属性？
	
		先在实例对象中寻找，然后是创建实例的类，最后是超类（从左到右）。
		当属性搜词找到时，搜索会停止。类的层次自然而然地支持了通过扩展进行代码的定制。
	
	3、类对象和实例对象有什么不同？
	
		类和实例对象都是命名空间，差不是。类是建立多个实例的工厂。类也支持运算符重载方法，由实例继承
		而且把其中任何函数视为处理实例的特殊的方法。
	
	4、为什么类方法函数中的第一个参数特殊？
		
		因为它总是接受将方法调用视为隐含主体的实例对象。统称self.
	
	5、__init__作用
		
		每次类创建实例，python自动调用，称为构造函数，也是最常见的运算符重载方法。
	
	6、怎么创建实例
		
		调用类名创建类实例。任何传给类名称的参数都要出出现在__init__构造函数中第二和其后的参数。
		新的实例会记得创建它的类，从而可以实现继承目的。
	
	7、怎么创建类
		
		运行class语句创建类。函数定义一样，这些语句所在的模块文件导入时，一般就会运行。
	
	8、怎么定义超类
		
		定义类的超类通过class语句的圆括号中将其列出，也就是新的类名称后，类在圆括号中从左至右列出的顺序，
		会决定其类树中有从左至右的搜索顺序。



"-----------------------------------------------------------------------------------------------------"

					第26章      类代码编写基础

"-----------------------------------------------------------------------------------------------------"

类有三个主要的不同之处：从最底层看，类几乎就是命名空间，很像模块。但是和模块不同，
	
	类支持多个对象的产生、命名空间继承和运算符重载。


类产生多个实例对象：
	
	python的oop模型中的两种对象：类对象和实例对象。
	
	类对象来自于语句，而实例来自于调用。
	
	类对象是多个实例的工厂，这是和模块不同的，模只有一个副本会导入某一个程序中，事实上，我们必须调用reload来
	更新单个模块对象，反映出来对该模块的修改。

	从某种程度上来说，Python的类和def以及模块很相似，但是它和其他语言中用过的相比可能就不相同。
	类对象提供默认行为：
		
		1、class语句创建类对象并将其赋值给变量名。
		
			python class语句也是可执行语句。执行时，会产生新的类对象，并将赋值给class头部的变量名。

		2、class语句内的赋值语句会创建类的属性。
			
			和模块一样，class语句内的顶层赋值语句（不是在def内），会产生类对象中的属性，
			从技术角度讲，class语句的作用域会变成类对象的属性的命名空间，就像模块的全局作用域一样。
		
		3、类属性提供对象的状态和行为。
			函数def语句会产生方法	

	实例对象是具体的元素：
		
		1、像函数那样调用类对象会创建新的实例对象。
			实例代表了程序领域中的具体元素
		
		2、每个实例对象继承类的属性并获得了自己的命名空间。
	
		3、在方法内对self属性做赋值运算会产生每个实例自己的属性，
	
第一个例子:
	
	首先，定义一个名为FirstClass的类
		class FirstClass:
			def setdata(self,value):
				self.value = value
			def display(self):
				print(self.value)
	
	def其实是赋值运算，在这里把函数对象赋值给变量名setdata，而且display位于class语句范围内，因此会产生
	附加在类上的属性：FirstClass.setdata和FirstClass.display，都是类属性。

		x = Firstclass()
		y = FirstClass()

	类和实例是类树中通过继承搜索的相连的命名空间,这里“data”属性会在实例内找到，但是"setdata"和"display"则是在
	它们之上的类中找到。

		x.sendata("King Arthur")  #"King Arthur" 是实例属性 
		y.sendata(3.1415)         #3.1415 是实例属性
	
	x或y本身都没有setdata属性，为了寻找这个属性，python会顺着实例到类的连接搜索。这就是所谓的python继承：继承
	是在属性点号运算时发生的，而且只与查找连接对象内的变量名有关。

	在FirstClass的setdata函数中，传入的值会赋给self.data。在方法中，self会自动引用正在处理的实例，所以赋值语句
	会把储存在实例的命名空间，而不是类的命名空间。
	
	因为类会产生多个实例，方法必须经过self参数才能获取正在处理的实例。当调用类的display方法打印self.data时，
	会发现每个实例的值不同。变量名display在x 和y之内都是相同的，因为它们来自于（继承自）类的。

		x.display()
			King Arthy
		y.display()
			3.1415

	注意：每一个实例内的data存储了不同的对象类型。实例属性并没有声明，首次赋值后，实例就会存在，就像简单的变量。
	事实上，调用setdata之前，调用display,则会触发未定义变量名的错误。

	在类内时，通过方法self进行赋值运算；在类外时，通过实例对象进行赋值运算：
		x.data = "New value"
		x.display()
			New vlaue

	我们甚至可以在实例命名空间内产生全新的属性：
		x.anothername = 'spam'
	会增加新的属性anothername，实例对象x任何类方法都可以使用它。


类通过继承进行定制:

	类除了作为工厂生产多个实例对象之外，类也可引入新组件（子类）来进行修改，而不是对现有组件进行原地修改。
	python让类继承其他类，开启了编写类层次结构的大门，在阶层较低的地方覆盖现有属性，让行为特定化。
	在这里和模块并不一致，模块属性存在于单一、平坦的命名空间之内。

	在python中，实例从类中继承，而类继承与超类，以下是属性继承机制的核心观点:
		
		1、超类列在子类开头的括号中。
		
		2、类从其超类中继承属性。

		3、实例会继承所有课读取类是属性。

		4、每个object.attribute都会开启新的独立搜索。
			
			Python会对每个属性取出表达式进行对类树的独立搜索。这里包括class语句外对实例和类的引用
			以及类方法函数内对self实例参数属性的引用。方法中的每个self.attr表达式都会开启对self及其
			上层类的attr属性的搜索。

		5、逻辑的修改是通过创建子类，而不是修改超类。
			在树中层次较低的子类重新定义超类的变量名，子类就可取代并定制所继承的行为。

第二个例子：

	class secondClass(FirstClass):
		def display(self):
			print('current value = "%s"' % self.data)

	secomdClass有效的取代器超类中display属性。

	有时候，我们把这种在树中较低处发生的重新定义、取代属性的动作称为重载。

	在类树中较低的扩展类中重新定义变量名，从而覆盖了继承的变量名并将其专有化。

	类所支持的扩展和重用比函数和模块更好。



类是模块内的属性：
	
	类的名称没有什么神奇之处，当class语句执行时，这只是赋值给对象的变量，而对象可以用任何普通表达式引用。

	虽然类和模块都是附加属性的命名空间，它们是非常不同的源代码结构，模块反应了整个文件，而类只是文件内的语句。


类可以截获Python运算符：

	模块和类的第三个主要差别：运算符重载。
	运算符重载就是让用类写成的对象，可截获并响应用在内置类型上的运算：加法、切片、打印和点号运算等。

	以下是重载运算符主要概念的概要：
		
		1、以双下划线命名的方法（__X__)是特殊钩子。

			python语句替每种运算和特殊命名的方法之间，定义了固定不变的映射关系。
		
		2、当实例出现在内置运算时，这类方法会自动调用。
			
			例如，如果实例对象继承了__add__方法，当对象出现+表达式内试，该方法就会调用。

		3、类可覆盖多数内置类型运算。
		
		4、运算符覆盖方法没有默认值，而且也不需要。

		5、运算符可让类与python的对象模型相集成。

第三个例子：
	
		class ThirdClass(secondClass):
			
			def __init__(self,value):
				self.data = value
		
			def __add__(self,other):
				return ThirdClass(self.data + other)   #这里返回的就是一个实例引用，不是一个类，没有class语句。
			
			def __str__(self):
				return '[ThirdClass:%s]' % self.data
			
			def mul(self,other):
				self.data *= other


		a = ThirdClass('abc')
		
		a.display()
			Current value = 'abc'
		print(a)
			[ThirdClass:abc]
		
		b = a + 'xyz'
		b.display()
			current value = "abcxyz"
		print(b)
			[ThirdClass:abcxyz]

		a.mul(3)
		print(a)
			[ThiedClass:abcabcabc]

	ThidClass生产的调用可以出现在 +表达式和print调用中。对于+,python把左侧的实例对象传给__add__中
	的self参数，把右边的值传给other，__add__返回的内容成为+表达式的结果，
	对于print把要打印的对象传递给__str__中的self,该方法返回字符串看作是对象的打印字符串。
	使用__str__，我们可以用一个常规的print来显示该类的对象，而不是特殊的display方法。

	在运算符重载中，在类的实例上执行的表达式运算符，和其他内置运算符都会对应到类中特殊名称的方法。
	这些特殊方法是选用的，也可像平常那样继承。在这里"+" 表达式触发"__add__"方法。

	
为什么要使用运算符重载：
	
	只有在实现本质为数学的对象时，才会用到许多运算符重载方法。

世界上最简单的Python类：
	
	class res:
		pass

	res.name = 'Bob'
	res.age = 40

	通过赋值创建这些属性，可以用一般语法将它们取出。类差不多就像C是struct.

	注意：其实该类没有实例，也能这样用。类本身就是对象，也是没有实例。
	类只是独立完备的命名空间，只有有类的引用值，就可以在任何时刻设定或修改其属性。

		x = res()
		y = res()

	这些实例最初完全是空的命名空间对象。
		x.name,y.name
	这些实例本身没有属性，他们从类对象哪里取出name属性。

	事实上，命名空间对象的属性通常都是以字典的形式实现的，而类继承树只是连接至其他字典而已。
	__dict__属性是针对大多数基于类的对象的命名空间字典。

	res.__dict__.keys()
		dict_keys(['__module__', '__dict__', '__weakref__', '__doc__', 'name', 'age'])
	
	Python中的OOP其实就是在已连接命名空间对象内寻找属性而已。


类和字典的关系：

	rec = {}
	rec['name'] = 'mel'
	rec['age'] = 45
	rec['job'] = 'trainer/writer'

	print[rec['name']]
		mel

	这段代码模拟了像其他语言中的记录这样的工具，这里也有许多方法用类做同样的事情。
	
	class rec: pass
		
	rec.name = 'mel'
	rec.age = 45
	rec.job = 'trainer/writer'

	print(rec.age)
		45
	
	这段代码的语法比字典等价形式要少很多。一个空的class语句来产生一个空的命名空间对象。
	一旦产生了空类，随着时间用赋值类属性来填充它。



本章小结：

	1、python类中如何编写运算符重载?
		
		python类中的运算符重载是用特定名称的方法写成的。这些方法的开头和结尾都是双下划线，
		通过这种办法使其变得独特。这些不是内置或保留字。当实例出现在相应的运算中时，python
		就会执行它们，python为这些运算和特殊方法的名称定义了对应关系。

	2、python oop程序代码最重要的两个概念是什么?
		
		特殊self参数和__init__构造函数。
		
	
	
"---------------------------------------------------------------------------------------------------"

			          第27章     更多实例

"---------------------------------------------------------------------------------------------------"

步骤1 ：创建实例
	
	按照惯例，类名使用一个大写字母开头。

	class Person
		
		def __init__(self,name,job,pay):
			self.name = name
			self.job = job
			self.pay = pay

	实例对象属性是通过类方法函数中的self属性赋值来创建。
	在__init__构造函数方法中将它们赋给self。
	在oo术语中，self就是新创建的实例对象，而name、job和pay变成了状态信息。
	
	注意：参数这里出现了两次，代码看上去是多余，实际上不是，例如：job参数在__init__函数的作用域里
	是一个本地变量，但是self.job是实例的一个属性，它暗示了方法调用的内容。这是两个不同的变量，但
	巧合有相同的名字。self.job = job把本地job属性赋给了self.job属性。

	说到参数,__init__实在没有什么奇妙之处，只不过产生实例的时候，自动调用函数，它仍然是一个普通的函数，
	可以为它提供默认值。
	
	根据python语法规则：一个函数定义中，在第一个拥有默认值的参数之后的任何参数，都必须拥有默认值。

	class Person:
		def __init__(self,name,job=None,pay=0):
			self.name = name
			self.job = job
			self.pay = 0

	这段代码意味着，需要传入name值，job和pay现在是可选的，如果忽略，默认是None和0。


步骤2：添加行为方法:
	
	if __name__ == '__main__':
		bob = Person('Bob Smith')
		sue = Person('Sue Jones',job='dev',pay=100000)
		print(bob.name,bob.pay)
		print(bob.name.split()[-1])
		sue.pay *= 1.10
		print(sue.pay)


	封装的思想就是把操作逻辑包装到界面之后。

	class Person:
		def __init__(self,name,job=None,pay=0):
			self.name = name
			self.job = job
			self.pay = pay
		
		def lastName(self):
			return self.name.split()[-1]
		def giveRaise(self,percent):
			self.pay = int(self.pay *(1+percent))

	方法只是附加给类并旨在处理那些类的实例的常规函数。


步骤3：运算符重载

	class Person:
		def __init__(self,name,job=None,pay=0):
			self.name = name
			self.job = job
			self.pay = pay
		def lastName(self):
			return self.name.split()[-1]
		def giveRaise(self,percent):
			self.pay = int(self.pay *(1+percent))
		
		def __str__(self):
			return '[Person:%s,%s]' % (self.name,self.pay)

步骤4：通过子类定制行为：
	
	class Manager(Person):
		def giveRaise(self,percent,bonus=0.10)

	
	扩展方法：不好的方式：
	
		class Manager(Person):
			def giveRaise(self,percent,bonus=0.10):
				self.apy = int(self.pay *(1 + percent + bonus))

		这里的问题是一个非常常见的问题：任何时候，当你复制粘贴代码的时候，基本上都会使未来的维护工作倍增。
		考虑一下：因为我们复制了最初的版本，如果一旦改变了涨工资的方式，将必须修改两个地方的代码。

	扩展方式：好的方式：
		
		真正想要做的事情是扩展最初的giveRaise，而不是完全替代它。在python中做到这一点的好处是，
		使用扩展的参数来直接调用其最初的版本，如下：

		class Manager(Person):
			def giveRaise(self,percent,bonus=0.10):
				Person.giveRaise(self,percent+bonus)

		这段代码利用了一个事实：类方法总是可以在一个实例中调用，或者通过类来调用。
	
	好的版本，对未来的代码维护意义重大。


多态的作用：

	class Person:
		def __init__(self,name,job=None,pay=0):
			self.name = name
			self.job = job
			self.pay = pay
		
		def lastName(self):
			return self.name.split()[-1]

		def giveRaise(self,percent):
			self.apy = int(self.pay*(1+percent)))

		def __str__(self):
			return '[Person:%s,%s]' % (self.name,self.pay)

	class Manager(Person):
		def giveRaise(self,percent,bonus = 0.1):
			Person.giveRaise(self,percent + bonus)

	
	if __name__== '__main__':
		bob = Person('Bob Smith')
		sue = Person('Sue Jones',job = 'dev',pay=100000)
		print(bob)
		print(sue)
		print(bob.lastName(),sue.lastName())
		sue.giveRaise(0.10)
		print(sue)
		
		tom = Manager('Tom Jones','Mgr',50000)
		tom.giveRaise(0.10)
		print(tom.lastName())
		print(tom)

		print('--All three--')
		for object in (bob,sue,tom):
			object.giveRaise(0.10)
			print(object)

	下面是新添加的代码，对象是一个Person或Manager，python自动运行相应的giveRaise，这里不过是python所谓的多态。


步骤5：定制构造函数

	一种常见的编码模式是把对象彼此嵌套以组成复合对象。
	
	class Person:
		...same...

	class Manager:
		def __init__(self,name,pay):
			self.person = Person(name,'mgr',pay)     #产生了一个Person实例self.person

		def giveRaise(self,percent,bonus=0.1):
			self.person.giveRaise(percent + bonus)
		
		def __getattr__(self,attr):
			return getattr(self.person,attr)

		def __str__(self):
			return str(self.person)

	if__name__ == '__main__':
		...same...


	实际上，这个Manager替代方案是一种叫委托的常用代码模式的一个代表，委托是一种基于复合的结构。
	它管理一个包装的对象并且把方法调用传递给它。


步骤6：使用内省工具：

	特殊类属性：
		
		内置的instance.__class__属性提供了一个从实例到创建它的类的链接。类反过来有一个__name__(就像模块一样)
		
		还有一个__bases__序列，提供了超类的访问。我们使用这些来打印一个实例类的名字，而不是硬编码来做到。

		内置的object.__dict__属性提供了一个字典，带有一个键/值对，以便每一个属性都有附加到一个命名控件对象（包括模块、类和实例）。
		由于它是字典，因此我们可以获取键的列表、按照键来索引、迭代其键，等等，从而广泛的处理所有属性
		我们使用这些来打印出任何实例的每一个属性，而不是在定制显示中硬编码。

	用form语句载入Person:类名存在语句之中，并且从模块导入，这与函数名和其他变量是完全相同的：
		
		from person import Person
		
		bob  = Person('Bob Smith')
		print(bob)
			[Person:Bob Smith,0]

		bob.__class__
			<class 'person.Person'>

		bob.__class__.__name__
			'Person'

		list(bob.__dict__.keys())
			['pay','job','name']

		for key in bob.__dict__:
			print(key,'=>',bob.__dict__[key])



步骤7：把对象存储到数据库中

	使用python一项叫做对象持久化的功能---让对象在创建它们的过程退出之后依然存在。

	Pickle 和 Shelve
	对象持久化通关3个3个标准的库模块来实现，这3个模块在python中都可用：

	pickle:
		任意python对象和字节串之间的序列化。

	dbm:(在python2.6中叫做anydbm)
		实现一个可通过键访问的文件系统，以存储字符串。

	shelve:
		使用另两个模块按照键把python对象存储到一个文件中。
		

	
	pickle模块是一种非常通用的对象格式化和解格式化工具。
	shelve模块提供了一个额外的层结构，允许按照键来存储pickle处理处理后的对象。
	
	实际上，一个shelve提供了一个简单的数据库来按照键存储和获取本地的python对象，并由此使它们
	跨程序运行而保持持久化。它不支持SQL这样的查询语句，并缺乏在企业数据库中可用的某些高级功能(真正事务处理)
	但是，一旦使用键获取了存储在shelve中的本地python对象，就可以使用python语言的所有功能处理他。



	在shelve数据库中存储对象：

	一旦有了实例，将它们存储到shelve中简直是小菜一碟，直接导入shelve模块，用外一个文件打开一个新的shelve,
	把对象赋给shelve中的键，当我们操作完毕后关闭shelve，因为已经做过修改：

	from person import Person,Manager
	bob = Person('Bob Smith')
	sue = Person('Sue Jones',job = 'dev',pay = 100000)
	tom = Manager('Tom Jones',5000)

	import shelve
	db = shelve.open('persondb')
	for object in (bob,sue,tom):
		db[object.name] = object
	db.close()

	在shelve中，键可以是任何字符串，唯一的规则是必须唯一。文件的后缀是".db"

	交互的探索shelve:
		
	此时，当前目录下会有一个或多个真爽的文件，他们的名字都以"persondb"开头，和内置open函数一样，shelve.open()
	中的文件名也是相对于当前工作目录，除非它包含路径。不关文件在哪里，这些文件实现为一个键访问的文件，不要
	删除文件，它们是你的数据库，并且是我们备份或移动存储的时候需要复制和转移的内容。


	这里交互的模式有效的成为一个数据库客户端：
	import shelve
	db = shelve.open('persondb')

	len(db)
		3
	list(db.keys())
		['Tom Jones','Sue Jones',"Bob Smith"]
	
	bob = db['Bob Smith']
	print(bob)
		[Person:job= None,name=Bob Smith,pay=0]

	for key in db:
		print(key,'=>',db[key])

	Tom Jones => [Manager:job=mgr,name=Tom Jones,pay=50000]
	Sue Jones => [Person: job=dev,name=Sue,pay=100000]
	Bob Smith => [Person: job=None,name=Bob Smith,apy=0]

	
本章习题：
	
	1、当shelve获取Manager对象打印它的时候，显示格式逻辑来自何处？
	
		在类的最终版本中，Manager最终从单独的classtools模块的AttrDisplay继承其__str__打印方法。

	2、当一个从shelve获取一个Person对象而没有导入其模块的时候，改对象如何知道他是一个giveRaise方法可供我们调用？
		
		shelve（实际上，使用pickle模块）自动地把该实例重新连接到他创建自的类。

	3、为什么把处理放入方法中而不是类之外硬编码如此重要？
		
		未来只需要副本修改，利用维护，这是python封装的概念

	4、何时选择使用对象嵌入和组合而不是继承
		
		继承是最佳的代码扩展
		对于多个对象集合到一个完整的对象，并且由一个控制器层类主导的情况，组合非常实用。
		继承向上传递调用以实现复用，组合向下传递以实现委托。


"---------------------------------------------------------------------------------------------------------"

				第28章        类代码编写细节

"---------------------------------------------------------------------------------------------------------"

class语句：

	class语句是python主要的OOP工具，但与C++不同，python的class并不是声明式的，就像def一样，
	class语句是对象的创建者并且是一个隐含的赋值运算---执行时，会产生类对象，并把其引用值存储在前面
	所使用的变量名，此外，和def一样，class语句也是真正的可执行代码，指定python抵达并且运行定义class语句前，
	你的类不存在。

一般形式：
	
	class是复合语句,在class语句内，任何赋值语句都会产生类属性。

	怎么从class语句到命名空间呢？
		
		1、就像函数一样，class语句是本地作用域，由内嵌的赋值语句建立的变量名，就存在于这个本地作用域内。
		
		2、就像模块内的变量名，在class语句内赋值的变量名会变成类对象中的属性。

	类主要的不同之处在于其命名空间，在类或实例对象中找不到所引用的属性，就会从其他类中获取，这是python继承基础。

	
	class ShareData:
		spam = 42

	x = ShareData()
	y = ShareData()
	
	x.spam,y.spam
		42,42
	
	ShareData.spam = 99
	x.spam,y.spam,ShareData.spam
		99,99,99
	
	x.spam = 88
	x.spam,y.spam,ShareData.spam
		88,99,99

	对实例的属性进行赋值运算会在该实例内创建或修改变量名，而不是在共享的类中。
	通常情况下，继承搜索只会在属性引用时发生，而不是在赋值运算时发生：对对象属性进行赋值总会修改该对象，
	除此之外没有其他是影响。例如，y.spam会通过继承而在类中查找，但是，对x.spam进行赋值运算则会把该变量名
	附加到x本身上。

	class MixedNames:
		data = 'spam'
		def __init__(self,value):
			self.data = value
		def display(self):
			print(self.data,MixedNames.data)

	data是类中的对象属性，data会被继承，从而被所有没有自己的data属性的类的实例所共享。
	当创建实例的时候，变量名data会在构造方法中对self.data进行赋值运算，把data附加到实例上。

	data存在于两个地方：实例对象内(由__init__中self.data赋值运算所创建)，以及在实例继承变量名的类中(由类中
	的赋值语句创建)
	


方法：
	
	静态方法：可以让你编写不预期第一参数为实例对象的方法。并且可以用来管理类数据。
	类方法：当调用的时候接受一个类而不是一个实例，并且可以用来管理基于每个类的数据。


继承：

	像class语句这样的命名空间工具的重点就是支持变量名继承。

	在python中，当对对象进行点号运算时，就会发生继承，而且涉及了搜索属性定义树。

	属性树的构造：
		
		1、实例属性是由对方法内self属性进行赋值运算而产生的。
		
		2、类属性是通过class语句内的语句而产生的。

		3、超类的链接是通过class语句首行的括号内列出类而产生的。


继承方法的专有化：

	重新定义继承变量名的概念引出各种专有化技术。子类完全取代继承属性

抽象超类：

	class Super:
		def method(self):
			print('in Super.mothod')
		def delegate(self):
			self.action()

	class Provider(Super):
		def action(self):
			print('in Provider.action')


	if __name__ == '__main__':
		x = Provider()
		x.delegate()

	当通过Provider实例调用delegate方法时，有两个独立的搜索会发生：
		
		1、在最初x.delegate的调用中，Python会搜索Provider实例和它上层的对象，知道在Super中找到delegate的方法。
		实例x会像往常一样传递给这个方法的self参数。

		2、在Super.delegate方法中，self.action会对self以及它上层的对象启动新的独立继承搜索。因为self指的是
		Provider实例，在Provider子类中就会找到action方法。

	从delegate方法角度来看，超类有时也称作抽象超类--也就是类的部分默认是其子类所提供的。如果预期的方法子类没有
	定义，python会引发未定义变量名异常。


Python2.6和Python 3.0的抽象超类：

	前面的抽象超类，需要由子类填充的方法，可以以特殊的类语法来实现，如下:
	
	在python 3.0中，我么在一个class头部使用一个关键字参数，已经特殊的@装饰器语法。

	from abc import ABCMeta,abstractmethod

	class Super(metaclass=ABCMeta):
		@abstractmethod
		 def method(self,...):
			 pass

	在python2.6中，使用一个类属性：

	class Super:
		__metaclass__ = ABCMeta
		@abstractmethod
		def method(self,...):
			pass


	等价语法如下：
	from acb import ABCMeta,abstractmethod
	class Super(metaclass=ABCMeta):
		def delegate(self):
			self.action()
		@abstractmethod
		 def action(self):
			 pass



命名空间：完整的内容

	点号和无点号的变量名，会用不同的方式处理，而有些作用域是用于对对象命名空间做初始设定的。

		1、无点号运算的变量名于作用域想对应。
			
			无点号变量名遵循函数LEGB作用域法则。
	
		2、点号的属性名使用的是对象的命名空间

		3、有些作用域会对对象的命名空间进行初始化（模块和类）


属性名称：对象命名空间：

	点号属性名指的是特定对象的属性，并且遵循模块和类的规则。
	
	赋值语句(object.X = value)
		在进行点号运算的命名空间内创建或修改属性名X，并没有其他作用。继承树的搜索只是发生在属性引用时，而不是属性赋值运算时。

	引用(object.X)
		就基于类的对象而言，会在对象内搜索属性名称X，然后是其上所有可读取的类，对于不是类的对象而言(模块)则是从对象中直接读取X。


Python命名空间的"禅"：赋值将变量名分类：

	在python中，赋值变量名的场所相当重要，这完全决定了变量名所在作用域或对象。

	x = 11

	def ():
		print(x)

	def g():
		x =22
		print(x)

	class C:
		x = 33
		def m(self):
			x = 44
			self.x = 55

	模块属性（11）、函数内的本地变量(22)、类属性(33)、方法中的本地变量(44)、实例属性(55)


命名空间字典：

	类和实例对象和模块一样，命名空间实际上是以字典的形式实现的，属性点号运算其实内部就是字典的索引运算，而属性继承其实就是搜索链接字典而已。

	class super:
		def hello(self):
			self.data1 = 'spam'

	class sub(super):
		def hola(self):
			self.data2 = 'eggs'

	我们制作子类的实例时，该实例一开始会是空的命名空间字典，但是有链接会指向它的类，让继承搜索能顺着寻找。
	实例中有一个__class__属性链接到了它的类，而类中有个__bases__属性，是一个元组，其中包含了通往更高的
	超类链接。

	X = sub()
	X.__dict__
		{}
	X.__class__
		<class '__main__.sub'>
	sub.__bases__
		(<class '__main__.super'>,)
	super.__bases__
		(<class 'object'>,)

	当类为self属性赋值时，会填入实例对象，也就是说，属性最后会位于实例的属性命名空间字典内，而不是类。
	实例对象的命名空间保存了数据，会随着实例不同而不同，而self正是进入其命名空间的钩子。

	
	X.hello()
	X.__dict__
		{'data1': 'spam'}
	X.hola()
	X.__dict__
		{'data1': 'spam', 'data2': 'eggs'}
	sub.__dict__.keys()
		dict_keys(['__module__', 'hola', '__doc__'])
	super.__dict__.keys()
		dict_keys(['__module__', 'hello', '__dict__', '__weakref__', '__doc__'])
	
	
	Y = sub()
	Y.__dict__
		{}

	因为属性实际上是python字典键，所有有两种方式可以读取并对其进行赋值：通过点号运算或索引运算。
	X.data1,X.__dict__['data1']
	('spam','spam')

	X.data3 = 'toast'
	X.__dict__
		{'data1': 'spam', 'data2': 'eggs', 'data3': 'toast'}


	dir(x)
		['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'data1', 'data2', 'data3', 'hello', 'hola']

	dir(sub)
		['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'hello', 'hola']
		
	dir(super)
		
		['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'hello']



类和模块的关系：

	模块：
		是数据/逻辑包
		通过编写python文件或C扩展来创建
		通过导入来使用

	类：
		实现新的对象
		由class语句创建
		通过调用使用
		总是在一个模块中

	类支持：运算符重载、多实例生成、继承。



本章习题：
	
	1、什么是抽象类？
		
		抽象类是会调用方法的类，但没有继承或定义该方法，而是期待改方法由子类填补。

	2、为什么类可能会需要手动调用超类的__init__方法？

		如果类定义自身的__init__构造函数，但是必须启用超类的构建起代码，就要手动调用超类__init__方法。





"--------------------------------------------------------------------------------------------------"

				   第29章  运算符重载

"--------------------------------------------------------------------------------------------------"
		
基础知识：

	1、运算符重载让类拦截常规的pyhton运算。

	2、类可重载所有Python表达式运算符。

	3、类也可重载打印、函数调用、属性点号运算等内置运算。

	4、重载使类实例的行为像内置类型。

	5、重载是通过提供特殊名称的类方法来实现的。


构造函数和表达式：__init__和__sub__:
	
	构造函数:__init__
	捕捉减法表达式：__sub__,这种特殊方法是钩子，可与内置运算相绑定。

	文件number.py
	class Number:
		def __init__(self,start):
			self.data = start
		def __sub__(self,other):
			return Number(self.data - other)

	from number import Number
	X = Number(5)
	Y = X - 2
	Y.data
		3

常见的运算符重载方法：

	方法                     重载                 调用

	__init__               构造函数               对象建立：X = Class(args)
		
	__del__                析构函数               X 对象收回

	__add__                运算符+                如果没有_iadd_, X + Y, X += Y

	__or__                 运算符|                如果没有_ior_,X|Y, X|=Y

	__repr__,__str__       打印、转换             print(X)，repr(X)，str(X)

	__call__               函数调用               X( *args,**kargs)

	__getattr__            点号运算               X.undefined

	__setattr__            属性赋值语句           X.any = value

	__delattr__            属性删除               del  X.any

	__getattribute__       属性获取               X.any

	__getitem__            索引运算               X[key],X[i:j],没有__iter__时的for循环和其他迭代器

	__setitem__            索引赋值语句           X[key] = value, X[i:j] = sequence

	__delitem__            索引和分片删除         del X[key],del X[i:j]

	__len__                长度                   len(x),如果没有__bool__,真值测试

	__bool__               布尔测试               bool(x)

	__lt__,__gt__          特定的比较             X < Y,X>Y 

	__le__,__ge__                                 X<=Y, X>=Y

	__eq__,__ne__                                 X == Y, X != Y

	__radd__               右侧加法               other + X

	__iadd__               实地（增强的）加法     X += Y
	
	__iter__,__next__       迭代环境              I = iter(X),next(I)

	__contains__           成员关系测试           item in X

	__index__              整数值                 hex(X),bin(X),oct(X)

	__enter__,__exit__     环境管理                with obj as  var:

	__get__,__set__        描述符属性             X.attr,X.attr = value

	__delete__
	
	__new__                创建                   在__init__之前创建对象


所有重载方法前后都有两个下划线字符，以便同类中定义的变量名区分开，特殊方法名称和表达式或运算符的映射关系是由python语言预先定义好的。






"---------------------------------------------------------------------------------------------------"

					第30 章     类的设计	

"---------------------------------------------------------------------------------------------------"

python常用的OOP设计模式：继承、组合、委托和工厂。


Python 和 OOP:

继承：
	
	继承是基于python中属性查找的(在X.name表达式中)

多态：

	在X.method方法中，method的意义取决于X的类型(类)

	因为python没有类型声明，属性总是在运行期解析，实现相同接口的对象是可互相交换的，
	所有客户端不需要知道实现它们调用方法是对象种类。

封装：
	
	方法和运算符实现行为，数据隐藏默认是一种惯例。
	封装指的是在pyhon中打包，也就是把实现的细节隐藏在对象接口之后，封装可让对象接口的实现出现变动时，
	不影响对象的用户。


OOP和继承："是一个" 关系(is-a)。

OOP和组合："有一个" 关系(has-a)。
	
	从程序员的角度来看，组合涉及把其他对象嵌入容器对象内，并使其实现容器方法。
	对设计来说，组合是另一种表示文件领域中关系的方式，但是，组合不是集合的成员关系，而是组件
	整体的组成部分。

	组合也反应了各组成部分之间的关系，
	组合就是指内嵌对象集合体。组合类一般都提供自己的接口，并通过内嵌的对象来实现接口。

	from employees import PizzaRobot,Server

	class Customer:
		
		def __init__(self,name):
			self.name = name
		def order(self,server):
			print(self.name,"Orders from",server)
		def pay(self,server):
			print(self.name,"pays for item to",server)

	class Over:
		def break(self):
			print("oven bakes")

	class PizzaShop:
		def __init__(self):
			self.server = Seerver('Pat')
			self.chef = PizzaRobot('Bob')
			sefl.oven = Oven()

		def order(self,name):
			customer = Customer(name)
			customer.order(self.server)
			self.chef.work()
			self.oven.bake()
			customber.pay(self.server)

	if __name__ == "__main__":
		scene = PizzaShop()
		scene.order('Homer')
		print('...')
		scene.order('Shaggy')

	PizzaShop类是容器和控制器，其构造函数会创建员工类实例并将其嵌入。


OOP和委托："包装"对象：

	面向对象程序员时常谈到所谓的委托，通常就会指控制器对象内嵌其他对象，而把运算请求传给那些对象。
	控制器负责管理工作，例如，记录存取等。
	在python中，委托通常以__getattr__(点号运算)钩子方法实现。

	class wrapper:
		def __init__(self,object):
			self.wrappend = object

		def __getattr__(self,attrname):
			print('Trace:',attrname)
			return getattr(self.wrapped,attrname)

	你可以使用这个模块包装类的做法，管理任何带有属性的对象的存取：列表，字典，甚至是类和实例。
	在这里，wrapper类只是在每个属性读取时打印跟踪消息，并把属性请求委托给嵌入的wrapped对象。

	from trace import wrapper

	x = wrapper([1,2,3])
	
	x.append(4)

		Trace:wrappend
	x.wrappend
		[1,2,3,4]

	x = wrapper({"a":1,"b":2})
	x.keys()
		Trace: keys
		dict_keys(['a', 'b'])




类是伪私有属性：

	python支持变量名压缩（mangling，相当于扩张）的概念，让类内某些变量局部化。
	压缩后的变量名有时被误认为"私有属性"，但这其实是一个把类所创建的变量名局部化方式而已。
	名称压缩无法阻止类外代码读取，只是避免实例内命名空间冲突，而不是限制变量名读取。
	压缩称为"伪私有"。

	变量名压缩的工作方式：class语句开通内两个下划线，但结尾没有两个下划线的变量名，会自动扩张，
	从而包含了类的名称。例如：像Spam类内__X这样的变量名会自动变成_Spam__X。

	变量名压缩只发生在class语句内，而且只针对开头有两个下划线的变量名。


为什么使用伪私有属性：

	伪私有属性功能是为了缓和域实例属性存储方式有关的问题。在python中，所有实例属性最后都会在类树
	底部的单个实例对象内。
	在python的类方法内，每当方法赋值self的属性时（self.attr = value）,就会在实例内修改或创建该属性。
	
	class C1:
		def meth1(self):
			self.X = 88
		def meth2(self):
			print(self.X)

	class C2:
		def metha(self):
			self.X = 99
		def methb(self):
			print(self.X)

	这两个类都在各行其事，如果这两个类混合在相同类树中时，问题就产生了。

	class C3(C1,C2):



多重继承："混合" 类

	所谓的多重继承：类和其实例继承了列出的所有超类的变量名。

编写混合显示类：

	class Spam:
		def __init__(self):
			self.data1 = "food"

	X = Spam()
	print(X)
		<__main__.Spam object at 0x7fac72c055f8>

	用__dict__列出实例属性：

		#File lister.py

	class ListInstance:
		def __str__(self):
			return '<Instance of %s,address %s:\n%s?' % (self.__class__.name,id(self),self.__attrnames())

		def __attrnames(self):
			result = ''
			for attr in sorted(self.__dict__):
				result += '\tname %s=%s\n' % (attr,self.__dict__[attr])
			return result

	from  lister import ListInstance

	class Spam(ListInstance):
		def __init__(self):
			self.data1 = 'food'

	x = Spam()
	print(x)
		<Instance of Spam,address 4024088o:
					name data1 = food
		>


类是对象：通用对象的工厂：

	类是对象，很容易传递，保存在数据结构中，也可以把类传给任意种类对象的函数，这类函数在OOP设计领域汇总
	偶尔称为工厂。

	def factory(aClass, *args):
		return aClass( *args)

	class Spam:
		def doit(self,message):
			print(message)

	class Person:
		def __init__(self,name,job):
			self.name = name
			self.job = job


	object1 = factory(Spam)
	object2 = factory(Person,"Guido","guru")

	我们定义了一个对象生成器函数，称为factory。它传入类对象。



与设计有关的其他话题：

	继承、复合、委托、多继承、绑定方法、工厂，这些是Python程序中组合类的所有常用模式。

	抽象超类、装饰器、类型子类、静态方法和类方法、管理属性、元类



本章习题：

	1、什么是多继承
		
		类从一个以上超类继承时，就发送了多重继承。

	2、什么是委托
		
		委托涉及把对象包装在代理类中，这样代理类会增加额外的行为，而把其他运算传给被包装的对象。
		代理类包含了被包装的对象接口。

	3、什么是组合

		组合是一种技术，让控制类嵌入和引导一群对象，并自行提供接口。

	4、什么是绑定方法

		绑定方法结合实例和方法函数。

	5、为什么使用伪私有属性

		用了吧名称本地化到包含类中。


"-----------------------------------------------------------------------------------------------"

			        第31章      类的高级主题

"-----------------------------------------------------------------------------------------------"

	如何建立内置类型的子类、新式类的变化和扩展、静态方法和类方法、函数装饰器等。


通过子类扩展类型：

	所有的内置类型现在都能直接创建子类。像list、str、dict以及tuple,这些类型转换函数都变成
	内置类型的名称：虽然脚本看不见，但是类型转换调用其实是启用了类型的对象构造函数。

	class  Mylist(list):
		def __getitem__(self,offset):
			print('(indexing %s at %s)' % (self,offset))
			return list.__getitem__(self,offset-1)

	if __name__ == '__main__':
		print(list('abc'))
		x = Mylist('abc')
		print(x)

		print(x[1])

		pirnt(x[3])

	

新式类：

	python3中所有的类都是新式类。
	class newstyle(object):
		....normal code...

	新式类变化：

		1、类与类型合并
			
			类自身就是类型。type对象产生类作为自己的实例，并且类产生它们的类型的实例。

			从技术上讲，每个类都由一个元类生成--元类是这样的一个类，它要么是type自身，要么是它定制来
			扩展或管理生成的类的一个子类。

			所有对象派生自object,每个对象都派生自object内置类，不管是直接地或通过一个超类。

		2、继承搜索顺序
		
			对经典类而言，继承搜索程序是绝对深度优先，然后才是由左至右。
			新式类：搜索相对来说是宽度优先的。Python先寻找第一个搜索的右侧的所有超类，然后才一路往
			上搜索至顶端共同的超类。


		3、针对内置函数的属性获取

		4、新的高级工具


	新式类的扩展：
		
		1、slots实例：
			将字符串属性名称顺序赋值给特殊的__slots__类属性。

			这个特殊属性在class语句顶层内将字符串名称顺序赋值给变量__slots__而设置：
			只有__slots__列表内的这些变量名可赋值为实例属性，

			class limiter(object):
				__slots__ = ['age','name','job']

			x = limiter()
			x.age
				AttributeError: age
			x.age = 40
			x.age
				40
			x.ape = 100
				AttributeError: 'limiter' object has no attribute 'ape'

		slots对应python动态特殊是一种违背。



静态方法和类方法：

	静态方法大致与一个类中的简单的无实例函数类似地工作。

	类方法传递一个类而不是一个实例。
	
	要使用这些方法，必须在类中调用特殊内置函数，分别名为staticmethod 和 classmethod,或者遇到装饰符语法来调用。
	
	在python3.0中，无实例的方法只能通过一个类名调用，不需要staticmethod声明。

	python通过静态方法的概念来支持这样的目标---嵌套在一个类中的没有self参数的简单函数，并且旨在操作类属性
	而不是实例属性。静态方法不会接受一个自动的self参数，不管是通过一个类还是一个实例调用。


	使用静态方法统计实例：

		class Spam:
			numInstances = 0
			
			def __init__(self):
				Spam.numInstances += 1
			
			def printNumInstances():
				print("Number of instances:",Spam.numInstances)

			printNumInstances = staticmethod(printNumInstances)

	使用静态方法内置函数，程序允许类或其他实例调用无self方法。

		a = Spam()
		b = Spam()
		c = Spam()
	
		Spam.printNumInstances()
			Number of instances: 3

		a.printNumInstances()
			Number of instances: 3



	用类方法统计实例：

		class Spam:
			numInstances = 0
			def __init__(self):
				Spam.numInstances += 1

			def printNumInstances(cls):
				print("Number of instances:",cls.numInstances)
			printNumInstances = classmethod(printNumInstances)

	它接受类而不是实例：
		a,b = Spam(),Spam()
		a.printNumInstances()
			Number of instances: 2
		Spam.printNumInstances()
			Number of instances: 2

				
装饰器和元类: 第一部分
	
	函数装饰器：提供了一种方式，替函数明确了特定的运算模式，也就是讲函数包裹了另一层，在另一个函数的逻辑内实现。

	函数装饰器基础：

		从语法上讲：函数装饰器是它后边的函数的运行时的声明。函数装饰器是写成一行，就在定义函数或方法的
		def语句之前，而且由@符号、后面跟着所谓的元函数组成：也就是管理另一个函数（或其他可调用对象）的函数。

		静态方法可用装饰器语法编写：

			class C:
				@staticmethod
				def meth():
					...

		从内部来看，这个语法和下面的写法有相同效果：
			
			class C:
				def meth():
					...
				meth=staticethod(meth)

		结果是，调用方法函数的名称，实际上是触发了它staticmethod装饰器的结果。
		因为装饰器会传回任何种类的对象，这也可以让装饰器在每次调用上增加一层逻辑。装饰器函数可返回
		原始函数，或者新对象。

			class Spam:
				numInstances = 0
				def __init__(self):
					Spam.numInstances = Spam.numInstances + 1

				@staticmethod
				def printNumInstances():
					print("Number of instances created:",Spam.numInstances)

			a = Spam()
			b = Spam()
			c = Spam()
			
			Spam().printNumInstances()

	
	
	类装饰器和元类：

		类装饰器类似于函数装饰器，但是，它们在一条class语句的末尾运行，并且把一个类名重新绑定到一个可调用对象。

		def decorator(aClass):...

		@decoracor
		class C:...
	
	被映射为下列相当代码：

		def decorator(aClass):...

		class C:...
		C = decorator(C)

	元类是一种类似的基础类的高级工具，用途往往与类装饰器有所重合。它们提供了一种可选的模式，
	会把一个类对象的创建导向到顶级type类的一个子类。


类陷阱：

	1、修改类属性的副作用
		
		class X:
			a = 1

		I = X()
		I.a
			1
		X.a 
			1

		X.a = 2
		I.a 
			2
		J = X()
		J.a	
			2

	2、修改可变的类属性也可能产生副作用
	
	由于类属性属于所有实例共享，所以如果一个类属性引用一个可变对象，那么从任何实例来原处修改
	都会立刻影响到所有实例：

	class C:
		shared = []

		def __init__(self):
			self.perobj = []

	x = C()
	y = C()

	y.shared,y.perobj
		([], [])
	x.shared.append('spam')
	x.perobj.append('spam')

	y.shared,y.perobj 
		(['spam'], [])


	可变对象通过简单变量来共享，全局变量由函数共享，模块级的对象由多个导入者共享，
	可变的函数参数由调用者和被调用者共享。



	3、多重继承：顺序很重要：

	4、类、方法以及嵌套作用域：

	5、“过度包装”

	
本章小结：

	列举出两种能够扩展内置对象类型的方法？
		
		1、在包装类中内嵌内置对象。
		
		2、直接做内置类型的子类。

	函数装饰器用来做什么的？

		函数装饰器通常是用来给现存的函数增加函数每次被调用时都会运行的一层逻辑。

1、类和实例的关系:

	python oop的本质是:在已连接的命名空间内寻找属性而已。

	类对象和实例对象是两个不同的命名空间，
	类对象是由class()执行语句创建类对象，并赋值绑定到类名。
	实例对象是由调用类名是创建。

	类对象和实例对象是类树通过继承搜索相连的命名空间，继承
	是在属性点号运算符时发送的，而且只查找相连对象内的命名空间。
	搜索方式是通过字典类型来实现的。

2、运算符重载:

	a、基础知识：
	
		运算符重载让类拦截常规的python运算

		类可重载所有的python表达式运算符

		类也可重载打印、函数调用、属性点号等内置运算

		重载使类实例的行为像内置类型

		重载是通过提供特殊名称的类方法来实现的。

	b、例子，__sub__()方法

		class Number:
			def __init__(self,start):
				self.data = start

			def __sub__(self,other):
				return Number(self.data - other)

		x = Number(5)

		y = x - 2  // x - 2 执行的是__sub__(self,other), y = Number(5-2)

		y.data
			3

	c、常见的运算符重载方法：

	方法             重载                 调用

	__new__          创建                在__init__之前创建对象

	__init__         构造函数            实例对象建立：x = Class(args)

	__del__          析构函数            x 对象回收

	__add__          运算符 +            如果没有__iadd__, x+y, x+=y

	__sub__          运算符 -            x - y ,x -= y

	__or__           运算符 |            如果没有__ior__, X|Y, X|=y



	__repr__,__str__ 打印，转换          print(x),repr(x),str(x)

	__call__         函数调用            x( *args,**kargs)


	
	__getattr__      点号运算            x.undefined

	__setattr__      属性赋值运算        x.any = value

	__delattr__      属性删除            del  x.any

	__getattribute__ 属性获取            x.any
	
	__get__,__set__,__delete__  属性描述 x.attr,x.arrt= value,del x.attr



	__getitem__      索引运算           x[key],x[i:j],没有__iter__时的for循环和其他迭代器

	__setitem__      索引赋值运算       x[key] = value,x[i:j] = sequence

	__delitem__      索引和分片删除     del x[key],del x[i:j]



	__len__          长度               len(x),如果没有__bool__

	__bool__         布尔测试           bool(x) 真值测试


	__lt__           小于               x < y   less than

	__gt__           大于               x > y   greater than

	__le__           小于等于           x <= y  less equal

	__ge__           大于等于           x >= y  greater equal

	__eq__           等于               x == y  equal

	__ne__           不等于             x != y  not equal


	__iter__,__next__ 迭代环境          I = iter(x),next(x)

	__contains__     成员关系测试       item in x 

	__index__        整数值             hex(x),bin(x),oct(x)

	__enter__,__exit__ 环境管理         with obj as var

3、模块和类:

	模块是一个文件
	类是一个语句

	模块：
	
		是数据/逻辑包
		通过编写python文件或C扩展来创建
		通过导入来使用

	类：
	
		实现新的对象
		由class语句创建
		通过调用使用
		总是在一个模块中

	类支持：运算符重载、多实例生成、继承。

	python常用的OOP设计模式：继承、组合、委托和工厂。

4、继承：

	继承是基于python中属性查找的(在X.name表达式中)
	继承："是一个" 关系(is-a)。

	多态：

	在X.method方法中，method的意义取决于X的类型(类)
	因为python没有类型声明，属性总是在运行期解析，实现相同接口的对象是可互相交换的，
	所有客户端不需要知道实现它们调用方法是对象种类。

	封装：

	方法和运算符实现行为，数据隐藏默认是一种惯例。
	封装指的是在pyhon中打包，也就是把实现的细节隐藏在对象接口之后，
	封装可让对象接口的实现出现变动时，
	不影响对象的用户。
5、组合:

	OOP和组合："有一个" 关系(has-a)。
	组合就是指内嵌对象集合体。组合类一般都提供自己的接口，并通过内嵌的对象来实现接口。

	from employees import PizzaRobot,Server

	class Customer:

		def __init__(self,name):
			self.name = name
		def order(self,server):
			print(self.name,"Orders from",server)
		def pay(self,server):
			print(self.name,"pays for item to",server)

	class Over:
		def break(self):
			print("oven bakes")

	class PizzaShop:
		def __init__(self):
			self.server = Seerver('Pat')
			self.chef = PizzaRobot('Bob')
			sefl.oven = Oven()

		def order(self,name):
			customer = Customer(name)
			customer.order(self.server)
			self.chef.work()
			self.oven.bake()
			customber.pay(self.server)

	if __name__ == "__main__":
		scene = PizzaShop()
		scene.order('Homer')
		print('...')
		scene.order('Shaggy')

	PizzaShop类是容器和控制器，其构造函数会创建员工类实例并将其嵌入。

6、委托:

	面向对象程序员时常谈到所谓的委托，通常就会指控制器对象内嵌其他对象，
	而把运算请求传给那些对象。控制器负责管理工作，例如，记录存取等。
	在python中，委托通常以__getattr__(点号运算)钩子方法实现。

	class wrapper:

		def __init__(self,object):
			self.wrappend = object
		def __getattr__(self,attrname):
			print('Trace:',attrname)
			return getattr(self.wrapped,attrname) //执行点号运行

	你可以使用这个模块包装类的做法，管理任何带有属性的对象的存取：列表，字典，甚至是类和实例。
	在这里，wrapper类只是在每个属性读取时打印跟踪消息，并把属性请求委托给嵌入的wrapped对象。

	from trace import wrapper

	x = wrapper([1,2,3])

	x.append(4)
		Trace:wrappend

	x.wrappend
		[1,2,3,4]

	x = wrapper({"a":1,"b":2})
	x.keys()
		Trace: keys
		dict_keys(['a', 'b'])
7、工厂:

	类是对象，很容易传递，保存在数据结构中，也可以把类传给任意种类对象的函数，
	这类函数在OOP设计领域汇总偶尔称为工厂。

	def factory(aClass, *args):
		return aClass( *args)

	class Spam:
		def doit(self,message):
			print(message)

	class Person:
		def __init__(self,name,job):
			self.name = name
				self.job = job

	object1 = factory(Spam)
	object2 = factory(Person,"Guido","guru")

	我们定义了一个对象生成器函数，称为factory。它传入类对象。

8、抽象超类:

	抽象类是会调用方法的类，但没有继承或定义该方法，而是期待改方法由子类填补。

	class Super:
		def method(self):
			print('in Super.mothod')
		def delegate(self):
			self.action()

	class Provider(Super):
		def action(self):
			print('in Provider.action')


	if __name__ == '__main__':
	x = Provider()
	x.delegate()

	当通过Provider实例调用delegate方法时，有两个独立的搜索会发生：

	1、在最初x.delegate的调用中，Python会搜索Provider实例和它上层的对象，
	直到在Super中找到delegate的方法。实例x会像往常一样传递给这个方法的self参数。

	2、在Super.delegate方法中，self.action会对self以及它上层的对象启动新的独立继承搜索。
	因为self指的是Provider实例，在Provider子类中就会找到action方法。

	从delegate方法角度来看，超类有时也称作抽象超类--也就是类的部分默认是其子类所提供的。
	如果预期的方法子类没有定义，python会引发未定义变量名异常。

9、静态方法:

	需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数

	class People(object):
		country = 'china'

		#静态方法
		@staticmethod
		def getCountry():
			return People.country

	print People.getCountry()

10、类方法:

	是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法，
	对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数
	（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以'cls'
	作为第一个参数的名字，就最好用'cls'了），能够通过实例对象和类对象去访问。


	class People(object):
		country = 'china'

		#类方法，用classmethod来进行修饰
		@classmethod
		def getCountry(cls):
			return cls.country

	p = People()
	print p.getCountry()    #可以用过实例对象引用
	print People.getCountry()    #可以通过类对象引用


	类方法还有一个用途就是可以对类属性进行修改：

	class People(object):
		country = 'china'

		#类方法，用classmethod来进行修饰
		@classmethod
		def getCountry(cls):
			return cls.country

		@classmethod
		def setCountry(cls,country):
			cls.country = country


	p = People()
	print p.getCountry()    #可以用过实例对象引用
	print People.getCountry()    #可以通过类对象引用

	p.setCountry('japan')   

	print p.getCountry()   
	print People.getCountry()

	从类方法和实例方法以及静态方法的定义形式就可以看出来，
	类方法的第一个参数是类对象cls，那么通过cls引用的必定是类对象的属性和方法；
	而实例方法的第一个参数是实例对象self，那么通过self引用的可能是类属性、
	也有可能是实例属性（这个需要具体分析），
	不过在存在相同名称的类属性和实例属性的情况下，实例属性优先级更高。
	静态方法中不需要额外定义参数，因此在静态方法中引用类属性的话，必须通过类对象来引用.

11、管理属性:

	先来谈一下类属性和实例属性

	类属性就是类对象所拥有的属性，它被所有类对象的实例对象所共有，
	在内存中只存在一个副本，这个和C++中类的静态成员变量有点类似。
	对于公有的类属性，在类外可以通过类对象和实例对象访问.

	类属性:

		class People(object):
			name = 'Tom'  #公有的类属性
			__age = 12     #私有的类属性

		p = People()

		print(p.name)           #正确
		print(People.name)      #正确
		print(p.__age)            #错误，不能在类外通过实例对象访问私有的类属性
		print(People.__age)        #错误，不能在类外通过类对象访问私有的类属性''


	实例属性(对象属性):

		class People(object):
			address = '山东' #类属性

			def __init__(self):
				self.name = 'xiaowang' #实例属性
				self.age = 20 #实例属性

		p = People()
		p.age =12 #实例属性
		print(p.address) #正确
		print(p.name)    #正确
		print(p.age)     #正确

		print(People.address) #正确
		print(People.name)    #错误
		print(People.age)     #错误


	如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。
	如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，
	不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，
	实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。

12、装饰器:

	1、装饰器用法：

	代码要遵循开放封闭原则，虽然在这个原则是用的面向对象开发，但是也适用于函数式编程，
	简单来说，它规定已经实现的功能代码不允许被修改，但可以被扩展，即：
	封闭：已实现的功能代码块
	开放：对扩展开发

	
	def w1(func):
		def inner():
			# 验证1
			# 验证2
			# 验证3
			func()
		return inner
	@w1
	def f1():
		print('f1')


	python解释器就会从上到下解释代码，步骤如下：

	a、	def w1(func): ==>将w1函数加载到内存
	b、	@w1
	
	没错， 从表面上看解释器仅仅会解释这两句代码，因为函数在 没有被调用之前其内部代码不会被执行。

	从表面上看解释器着实会执行这两句，但是 @w1 这一句代码里却有大文章，@函数名 是python的一种语法糖。

	@w1内部会执行一下操作：
		
		执行w1函数 ，并将 @w1下面的函数作为w1函数的参数，
		即：@w1 等价于 w1(f1) 所以，内部就会去执行：
		
		def inner(): 
			#验证 1
			#验证 2
			#验证 3
			f1()     # func是参数，此时 func 等于 f1 
		return inner
		返回的 inner，inner代表的是函数，非执行函数 ,其实就是将原来的f1函数塞进另外一个函数中。
	
	w1的返回值：

		将执行完的w1函数返回值赋值给@w1下面的函数名f1，即将w1的返回值再重新赋值给f1，即：

		新f1 = def inner():
					#验证 1
			        #验证 2
			        #验证 3
			        原来f1()
				return inner
	
		所以，以后业务部门想要执行 f1 函数时，
		就会执行 新f1 函数，在新f1 函数内部先执行验证，
		再执行原来的f1函数，然后将原来f1 函数的返回值返回给了业务调用者。
		
	2、装饰器的作用：

	a、引入日志
	b、函数执行时间统计
	c、执行函数前预备处理
	d、执行函数后清理功能
	e、权限校验等场景
	f、缓存
	
	3、例1:无参数的函数

		from time import ctime, sleep

		def timefun(func):
			def wrappedfunc():
				print("%s called at %s"%(func.__name__, ctime()))
				func()
				return wrappedfunc

		@timefunc
		def foo():
			print("I am foo")


		foo()
		sleep(2)
		foo()

		上面代码理解装饰器执行行为可理解成:

			foo = timefun(foo)
			#foo先作为参数赋值给func后,foo接收指向timefun返回的wrappedfunc
			foo()
			#调用foo(),即等价调用wrappedfunc()
			#内部函数wrappedfunc被引用，所以外部函数的func变量(自由变量)并没有释放
			#func里保存的是原foo函数对象

	4、被装饰的函数有参数

		from time import ctime, sleep

		def timefun(func):
			def wrappedfunc(a, b):
				print("%s called at %s"%(func.__name__, ctime()))
				print(a, b)
				func(a, b)
			return wrappedfunc

		@timefun
		def foo(a, b):
		print(a+b)


		foo(3,5)
		sleep(2)
		foo(2,4)

	5、类装饰器（扩展，非重点）

		装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。

		在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了 __call__() 方法，
		那么这个对象就是callable的。

			class Test():
				def __call__(self):
					print('call me!')

			t = Test()
			t()  # call me

		类装饰器demo:

		class Test(object):
			def __init__(self, func):
				print("---初始化---")
				print("func name is %s"%func.__name__)
				self.__func = func
			def __call__(self):
				print("---装饰器中的功能---")
				self.__func()

		说明：
		1. 当用Test来装作装饰器对test函数进行装饰的时候，首先会创建Test的实例对象
		   并且会把test这个函数名当做参数传递到__init__方法中
		   即在__init__方法中的func变量指向了test函数体

		2. test函数相当于指向了用Test创建出来的实例对象

		3. 当在使用test()进行调用时，就相当于让这个对象()，因此会调用这个对象的__call__方法

		4. 为了能够在__call__方法中调用原来test指向的函数体，所以在__init__方法中
		   就需要一个实例属性来保存这个函数体的引用所以才有了self.__func = func这句代码，
		   从而在调用__call__方法中能够调用到test之前的函数体

		@Test
		def test():
			print("----test---")

		test()
		showpy()#如果把这句话注释，重新运行程序，依然会看到"--初始化--"

		运行结果如下：

			---初始化---
			func name is test
			---装饰器中的功能---
			----test---
13、元类：

	1. 类也是对象

	在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。
	在Python中这一点仍然成立：但是，Python中的类还远不止如此。
	类同样也是一种对象。是的，没错，就是对象。
	只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。

	class ObjectCreator(object):
		pass

	将在内存中创建一个对象，名字就是ObjectCreator。
	这个对象（类对象ObjectCreator）拥有创建对象（实例对象）的能力。
	但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作：

		你可以将它赋值给一个变量
		你可以拷贝它
		你可以为它增加属性
		你可以将它作为函数参数进行传递
	
	2. 到底什么是元类

	元类就是用来创建类的“东西”。
	元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解为：

	MyClass = MetaClass() #使用元类创建出一个对象，这个对象称为“类”
	MyObject = MyClass() #使用“类”来创建出实例对象

	函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。

	3. 使用type创建类

	type(类名, 由父类名称组成的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)

	Test2 = type("Test2",(),{}) #定了一个Test2类
	
	4. 使用type创建带有属性的类

	Foo = type('Foo', (), {'bar':True})

5、__metaclass__属性:

	你可以在定义一个类的时候为其添加__metaclass__属性:
		class Foo(object):
			__metaclass__ = something…
			...省略...

	如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。
	你首先写下class Foo(object)，但是类Foo还没有在内存中创建。
	Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类Foo，
	如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。当你写如下代码时 :

	class Foo(Bar):
		pass

	Python做了如下的操作：

	Foo中有__metaclass__这个属性吗？如果是，Python会通过__metaclass__创建一个名字为Foo的类(对象)
	如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。
	如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。
	如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。
	现在的问题就是，你可以在__metaclass__中放置些什么代码呢？
	答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？
	type，或者任何使用到type或者子类化type的东东都可以。

6、 自定义元类：

	元类的主要目的就是为了当创建类时能够自动地改变类。
	通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。

	假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。
	有好几种方法可以办到，但其中一种就是通过在模块级别设定__metaclass__。
	采用这种方法，这个模块中的所有类都会通过这个元类来创建，
	我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。

	幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类。
	所以，我们这里就先以一个简单的函数作为例子开始。


	class UpperAttrMetaClass(type):
		# __new__ 是在__init__之前被调用的特殊方法
		# __new__是用来创建对象并返回的方法
		# 而__init__只是用来将传入的参数初始化给对象
		# 你很少用到__new__，除非你希望能够控制对象的创建
		# 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__
		# 如果你希望的话，你也可以在__init__中做些事情
		# 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用
		
		def __new__(cls, future_class_name, future_class_parents, future_class_attr):
			#遍历属性字典，把不是__开头的属性名字变为大写
			newAttr = {}
			for name,value in future_class_attr.items():
				if not name.startswith("__"):
					newAttr[name.upper()] = value

			# 方法1：通过'type'来做类对象的创建
			# return type(future_class_name, future_class_parents, newAttr)

			# 方法2：复用type.__new__方法
			# 这就是基本的OOP编程，没什么魔法
			# return type.__new__(cls, future_class_name, future_class_parents, newAttr)

			# 方法3：使用super方法
			return super(UpperAttrMetaClass, cls).__new__(cls, future_class_name, future_class_parents, newAttr)

		#python2的用法
		class Foo(object):
			__metaclass__ = UpperAttrMetaClass
			bar = 'bip'

		# python3的用法
		# class Foo(object, metaclass = UpperAttrMetaClass):
		#     bar = 'bip'

	print(hasattr(Foo, 'bar'))
	# 输出: False
	print(hasattr(Foo, 'BAR'))
	# 输出:True

	f = Foo()
	print(f.BAR)
	# 输出:'bip'

14、闭包：

	在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，
	那么将这个函数以及用到的一些变量称之为闭包

	定义一个函数
	def test(number):
		def test_in(number_in):
			print("in test_in 函数, number_in is %d"%number_in)
			return number+number_in
			#其实这里返回的就是闭包的结果
		return test_in


	#给test函数赋值，这个20就是给参数number
	ret = test(20)

	#注意这里的100其实给参数number_in
	print(ret(100))

	#注意这里的200其实给参数number_in
	print(ret(200))


	内部函数对外部函数作用域里变量的引用（非全局变量），则称内部函数为闭包。
	def counter(start=0):
		count=[start]
		def incr():
			count[0] += 1
			return count[0]
		return incr


	nonlocal访问外部函数的局部变量(python3)

	def counter(start=0):
		def incr():
			nonlocal start
			start += 1
			return start
		return incr

	闭包思考：

	1.闭包似优化了变量，原来需要类对象完成的工作，闭包也可以完成
	2.由于闭包引用了外部函数的局部变量，则外部函数的局部变量没有及时释放，消耗内存

15、私有化:

	xx: 公有变量
	_x: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问
	__xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)
	__xx__:双前后下划线,用户名字空间的魔法对象或属性。例如:__init__ , __ 不要自己发明这样的名字
	xx_:单后置下划线,用于避免与Python关键词的冲突

	父类中属性名为__名字的，子类不继承，子类不能访问
	如果在子类中向__名字赋值，那么会在子类中定义的一个与父类相同名字的属性
	_名的变量、函数、类在使用from xxx import *时都不会被导入

16、slots:

	python是动态语言,动态编程语言 是 高级程序设计语言 的一个类别，在计算机科学领域已被广泛应用。
	它是一类 在运行时可以改变其结构的语言 ：例如新的函数、对象、甚至代码可以被引进，
	已有的函数可以被删除或是其他结构上的变化。动态语言目前非常具有活力。

	1. 运行的过程中给对象绑定(添加)属性

		>>> class Person(object):
				def __init__(self, name = None, age = None):
					self.name = name
					self.age = age

		>>> P = Person("小明", "24")

		在这里，我们定义了1个类Person，在这个类里，定义了两个初始属性name和age，
		但是人还有性别啊！如果这个类不是你写的是不是你会尝试访问性别这个属性呢？

		>>> P.sex = "male"
		>>> P.sex
			'male'

		这时候就发现问题了，我们定义的类里面没有sex这个属性啊！怎么回事呢？ 
		这就是动态语言的魅力和坑！ 这里 实际上就是 动态给实例绑定属性！


	2. 运行的过程中给类绑定(添加)方法

		既然给类添加方法，是使用类名.方法名 = xxxx，
		那么给对象添加一个方法也是类似的对象.方法名 = xxxx

		import types

		#定义了一个类
		class Person(object):
			num = 0
			def __init__(self, name = None, age = None):
				self.name = name
				self.age = age
			def eat(self):
				print("eat food")

		#定义一个实例方法
		def run(self, speed):
			print("%s在移动, 速度是 %d km/h"%(self.name, speed))

		#定义一个类方法
		@classmethod
		def testClass(cls):
			cls.num = 100

		#定义一个静态方法
		@staticmethod
		def testStatic():
			print("---static method----")

		#创建一个实例对象
		P = Person("老王", 24)
		#调用在class中的方法
		P.eat()

		#给这个对象添加实例方法
		P.run = types.MethodType(run, P)
		#调用实例方法
		P.run(180)

		#给Person类绑定类方法
		Person.testClass = testClass

		#调用类方法
		print(Person.num)
		Person.testClass()
		print(Person.num)

		#给Person类绑定静态方法
		Person.testStatic = testStatic
		#调用静态方法
		Person.testStatic()

	3. 运行的过程中删除属性、方法

		a、del 对象.属性名
		b、delattr(对象, "属性名")
		通过以上例子可以得出一个结论：相对于动态语言，静态语言具有严谨性！
		所以，玩动态语言的时候，小心动态的坑！

		那么怎么避免这种情况呢？ 请使用__slots__，

	4、__slots__：

	动态语言：可以在运行的过程中，修改代码
	静态语言：编译时已经确定好代码，运行过程中不能修改

	如果我们想要限制实例的属性怎么办？比如，只允许对Person实例添加name和age属性。
	为了达到限制的目的，Python允许在定义class的时候，
	定义一个特殊的__slots__变量，来限制该class实例能添加的属性：

	
	>>> class Person(object):
		    __slots__ = ("name", "age")		
	>>> P = Person()
	>>> P.name = "老王"
	>>> P.age = 20
	>>> P.score = 100
	Traceback (most recent call last):
	  File "<pyshell#3>", line 1, in <module>
	  AttributeError: Person instance has no attribute 'score'
	
	
	注意:

	使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，
	对继承的子类是不起作用的
	
	class Test(Person):
		pass
	t = Test()
	t.score = 100

17、属性property：

	1. 私有属性添加getter和setter方法

		class Money(object):
			def __init__(self):
				self.__money = 0

			def getMoney(self):
				return self.__money

			def setMoney(self, value):
				if isinstance(value, int):
					self.__money = value
				else:
					print("error:不是整型数字")

	2.使用property升级getter和setter方法

		class Money(object):
			def __init__(self):
				self.__money = 0

			def getMoney(self):
				return self.__money

			def setMoney(self, value):
				if isinstance(value, int):
					self.__money = value
				else:
					print("error:不是整型数字")

			money = property(getMoney, setMoney)

		运行结果:

			from get_set import Money
			a = Money()
			a.money = 100
			a.getMoney()
				100

	3.使用property取代getter和setter方法

		@property成为属性函数，可以对属性赋值时做必要的检查，并保证代码的清晰短小，
		主要有2个作用:

			将方法转换为只读
			重新实现一个属性的设置和读取方法,可做边界判定

		class Money(object):
			def __init__(self):
				self.__money = 0

			@property
			def money(self):
				return self.__money

			 @money.setter
			def money(self, value):
				if isinstance(value, int):
					self.__money = value
				else:
					print("error:不是整型数字")


"------------------------------------------------------------------------------------"

	
	

"================================================================================================="

				第七部分     异常和工具

"================================================================================================="


"------------------------------------------------------------------------------------------------"
				
				第 32 章        异常基础
				
"------------------------------------------------------------------------------------------------"

	异常由四个语句处理：

	1、try/except
		
		捕捉由python或你引起的异常并恢复。

	2、try/finally

		无论异常是否发生，执行清理行为。

	3、raise
		
		手动在代码中触发异常

	4、assert

		有条件地在程序代码中触发异常

	5、with/as

		在pyhton2.6和后续版本中实现环境管理器


为什么使用异常：

	异常让我们从一个程序中任意大的代码中跳出来。

	异常是一种结构化的"超级goto"，异常处理器(try语句)会留下标识，并可执行一些代码。


异常的角色:
	
	在python中，异常通常用于各种用途，最常见的几种角色。

	1、错误处理
		
		每当在运行时检测到程序错误时，python就会发生异常。如果忽略错误，python默认的异常处理行为将
		启动：停止程序，打印错误消息。如果不想启动默认行为，就要写try语句来捕捉异常并从异常中恢复：
		当检测到错误时，python会跳到try处理器，而程序在try之后从新继续执行。


	2、事件通知

	3、特殊情况处理

	4、终止行为

	5、非常规控制流程


异常处理：简明扼要
	
	捕捉异常：

		def fetcher(obj,index):
			return obj[index]

		x = 'spam'

		try:
		
			fetcher(x,4)
		except IndexError:
			print('got exception')

		当try代码块执行时触发异常，python会自动跳至处理器（except分句下面的代码块）。


	引发异常：

		手动触发异常，直接执行raise语句。用户触发异常的捕捉方式和python引用的异常一样。

		try:
			raise IndexError	
		except IndexError:
			print('got exception')


	用户定义的异常：

		用户定义异常能够通过类编写，它继承自一个内置的异常类：通过这个类想名称叫做：Exception。

		class Bad(Exception)
			pass

		def doomed():
			raise Bad()

		try:
			doomed()
		except Bad:
			print('got Bas')


	终止行为：

		try/finally组合，无论try中是否发生异常，一定会最后执行finally。

		try：
			fetcher(x,3)
		finally:
			print('after fetch')


		def after():
			try:
				fetcher(x,3)
			finally:
				print('after fetch')
				print('after try?')


为什么要在意：错误检查：

	了解异常是多么有用的方法之一就是，比较python以及没有异常的语言的代码风格。例如C语言，
	如下想以C语言编写稳健的程序，一般在每个可能出错的运算之后测试返回值或状态码，然后在程序执行时传递测试结果。




"-------------------------------------------------------------------------------------------"
	
			    第 33 章         异常编码细节

"-------------------------------------------------------------------------------------------"

try/except/else 语句：

	try是复合语句，后面紧跟着缩进的语句代码，然后是一个或多个except分句来识别要捕捉的异常，
	最后一个可选的else分句。

		try:
			<statements>
		except <name1>:
			<statements>
		except(name2,name3):
				<statements>
		except <name4> as <data>:
			<statements>
		except:
			<statements>
		else:
			<statemnets>

	try首行底下的代码块代码次语句的主要动作：试着执行的程序代码。Except子句是定义try代码块内引发
	的异常处理器，而else字句则是提供没有发生异常时要执行的处理器。


	try语句分句：

		分句形式                                 说明
		except:                             捕捉所有异常类型
		except name:                        只捕捉特定的异常
		except name,value:                  捕捉所列的异常和其额外的数据
		except (name1,name2):               捕捉任何列出的异常
		except (name1，name2),value:        捕捉任何列出的异常，并取得其额外数据
		else:                               如果没有引发异常，就运行
		finally                             总是会运行此代码块



	空的except子句是一种通用功能：因为这里捕捉任何东西，可以让处理器通用化或具体化。
		try:
			action()
		except:
			...

	不过，空except也会引发一下设计问题:尽管方便，也可能捕捉程序代码无关、意料之外的系统异常，而且可能
	意外拦截其他处理器异常。

	python3.0引入了替代方案--捕捉一个名为Exception的异常几乎和except具有相同的效果，
	但是忽略和系统退出相关的异常：

		try:
			action()
		except Exception:
			...


	try/finally:
		
		如果try代码块运行时有异常发生，python依然会回来运行finally代码块，但是会把异常向上传递
		到较高的try语句或顶层默认处理器。和except不同，finally不会终止异常，而是在finally代码
		执行后，一直处于发生状态。



raise语句：

	要显示的触发异常，可以用raise语句，其一般形式相当简单。raise语句的组成是：
	raise关键字，后面跟着可选的要引发的类或者类的一个实例：

	raise  <instance>
	raise  <class>
	raise


	示例：
	raise IndexError
	raise IndexError()

	我们也可以提前创建实例--因为raise语句接收任何类型的对象引用。如下两个示例像前两个一样引发了IndexError:

	exc = IndexError()
	raise exc

	excs = [IndexError,TypeError]
	raise excs[0]

	
	利用raise传递异常：

		raise语句不包括异常名称或额外数据值时，就是重新引发当前异常。

		try:
			raise IndexError('spam')
		except IndexError:
			print('propagating')
			raise

			
			propagating
			Traceback (most recent call last):
				File "<stdin>", line 2, in <module>
			IndexError: spam

	通过这种方式执行raise时，会重新引发异常，将其传递给更高层的处理器。


assert语句：

	assert可视为条件式的raise语句，该语句形式为：

		assert <test>,<data>

	执行起来就行如下代码：
		if __debuf__:
			if not <test>:
				raise AssertionError(<data>)

	换句话说，如果test计算为假，python就会引发异常：data项是异常的额外数据。

	例子：收集约束条件（但不是错误）

		def f(x):
			assert x < 0, 'x must be negative'
			return x ** 2

		f(1)
			
			Traceback (most recent call last):
				File "<stdin>", line 1, in <module>
				File "<stdin>", line 2, in f
			AssertionError: x must be negative


	牢记：assert几乎都是用来收集用户的约束条件，而不是捕捉内在的程序设计错误。


with/as环境管理器：

	python2.6和python3.0引入了一种新的异常相关的语句：with语句已经可选的as子句。
	这个语句的设计是为了和环境管理器对象一起工作。
	简而言之，with/as语句设计是为常见try/finally用法模式的替代方案。
	wit/as语句也是用于定义必须执行的终止或"清理"行为，无论处理步骤中是否发生异常。
	不过，和try/fianlly不同的是，with语句支持更丰富的基于对象的协议，可以为代码块定义
	支持进入和离开动作。

	基本使用：
	
		with expression [as variable]:
			with-block

	在这里expression要返回一个对象，从而支持环境管理协议。如果选用的as子句存在时，次对象也可返回
	一个值，赋值给变量名variable。

	注意：variable并非赋值为expression的结果，expression的结果是支持环境协议的对象，而variable则是
	赋值给其他的东西。然后，expression返回的对象可在with-block开始前，先执行启动程序，并且在该代码
	块完成后，执行终止程序代码，无论该代码块是否发生异常。


	例如：文件对象有环境管理器，可在with代码块后自动关闭文件，无论是否发生异常。

		with open("/home/data.txt")  as myfile:
			for line in myfile:
				print(line)
				...more code here...

	这里，对open的调用，会返回一个简单文件对象，赋值给变量名myfile。我们可以用一般文件工具来使用myfile：
	就此而言，文件迭代器会在for循环内逐行读取。



本章习题:

	1、try语句用途？
		
		捕捉异常并从中恢复，try语句两种常见的变体是try/except/else以及try/finally

	2、raise语句有什么作用？

		引发异常

	3、assert语句有什么用？和其他那些语句相似？
		
		条件为假时，引发AssertionError异常，就像包裹在if语句中的条件式raise语句

	4、with/as语句有什么用？和其他那些语句相似？

		为了让必须在程序代码块周围发生的启动和终止活动一定会发生。




"--------------------------------------------------------------------------------------------"

				第 34 章         异常对象

"--------------------------------------------------------------------------------------------"

	内置异常和用户定义的异常都是通过类实例对象来表示。

	基于类的异常由如下特点：

		1、提供了类型分类，对今后的修改有更好的支持。

		2、它们附加了状态信息。

		3、它们支持继承。

	
基于类的异常：

	基于类的基础更好支持异常状态信息（附加在实例上），而且可以让异常参与继承层次(获得通用的行为)。

	class General(Exception):pass
	class Specific1(General):pass
	class Specific2(General):pass

	def raiser0():
		X = General()
		raise X

	def raiser1():
		X = Specific1()
		raise X

	def raiser2():
		X = Specific2()
		raise X

	for func in (raiser0,raiser1,raiser2):
		try:
			func()
		except General:
			import sys
			print('caught:',sys.exc_info()[0])


内置Exception类：

	python自身能够引发所有的内置异常，都是预定义的类对象。

BaseException:
	
	异常的顶级根类。这个类不能由用户定义的类直接继承的。它提供了子类所继承的默认的打印和状态保存行为。

Exception:
	
	这是BaseException的一个直接子类，并且是所有其他内置异常的超类，除了系统退出事件之外(SystemExit、
			KeyboardInterrupt和GeneratorExit)

ArithmeticError
	
	所有数值错误的超类。

OverflowError

	识别特定的数值错误的子类。


本章习题：
	
	1、在python3.0 中，对于用户定义异常的两个新限制是什么？

		异常必须有类定义，异常必须派生内置类BaseException

	2、基于类的异常是怎样和处理器匹配的？
	
		基于类的异常是由超类的关系匹配的：在异常处理器中指定超类，
		就会捕捉该类的实例，以及类树中任何更低的子类实例。

	3、环境信息附加到异常对象上的两种方法
		
		通过在引发的实例对象中填充实例属性，来把环境信息附加到基于类的异常，通常是在一个定制类构造函数中做到这点。


	4、异常对象指定出错误消息的两种方法

		可以用一个定制__str__运算符重载方法来指定。



"---------------------------------------------------------------------------------------------------"

				  第 35 章     异常的设计

"---------------------------------------------------------------------------------------------------"

异常的习惯用法：

	异常不总是错误：
		所有错误都是异常，但并非所有异常都是错误。

		例如内置的input函数，每次调用从标准输入串流sys.stdin读取一行文字，并且在文件尾部引发内置EOFError异常。
		这种异常在这种环境下只是信号而已，不是错误。

函数信号条件和raise：

		下面代码中，try/except/else处理器做的就是if/else返回值的测试工作。

			class Found(Exception):pass

			def searcher():
				if ...success...:
					raise Found()
				else:
					return

			try:
				searcher()
			except Found:
				...success...
			else
				...failure...

	这种代码结构，可用于任何无法返回警告值以表明成功或失败的函数。


关闭文件和服务器连接：

	with open(r'/home/test.txt','w') as myfile:
		...process myfile...


在try外进行调试：

	利用异常处理，取代python的默认顶层异常处理行为，在顶层代码中的外层try中包装整个程序，捕捉发生的异常
	可以破坏默认的程序终止行为。

		try:
			...run program...
		except:
			import sys
			print('uncaught!',sys.exc_infp()[0],sys.exc_info()[1])


关于sys.exc_info:

	sys.exc_info,通常允许一个异常处理器获取对最近引发异常的访问。当使用空的except字句来盲目地捕获
	每个异常以确定引发了什么的时候，这种方式特别有用：
		
		try:
			...
		except:
			sys.exc_info()[0:2]

	
与异常有关的技巧：

	应该包装什么：
		
		理论上，在脚本中所有的语句都包装在try中，这样不明智，一下是一下简要的元则：

		1、经常会失败的运算应该包装在try语句内。

		2、希望运算失败终止程序，而不是被忽略或捕捉

		3、在try/finally中实现终止动作。

		4、偶尔，大型的函数调用包装在try内。


捕捉太多：避免空except语句：

	空except会捕捉try代码块中执行时所引发的每一个异常。

		def func():
			try:
				...
			except:
				...

捕捉太少：使用基于类的分类：

	try:
		...
	except(MyExcept1,MyExcept2):
		...
	else:
		...
	

核心语言总结:

	一般而言，Python提供了一个有层次的工具集。

	1、内置工具：
		
		像字符串、列表以及字典等这些内置类型

	2、Python扩展：

		编写自己的函数、模块以及类，来扩展Python

	3、已编译的扩展：

		C 或 C++ 外部语言所编写的模块进行扩展

	Python的工具箱类型:

		分类           例子

		对象类型        列表、字典、文件、字符串

		函数             len、range、open

		异常             IndexError、KeyError

		模块             os、tkinter、pickle、re

		属性             __dict__ 、__name__、__class__

		外部工具         NumPy、SWIG、Jython、Django、Iropython



大型项目的开发工具:

	1、PyDoc 和 文档字符串：

		PyDoc为模块和对象提供了一个文档系统，并整合了python的文档字符串功能。

	2、PyChecker 和 Pylint：

		PyChecker 和 Pylint 系统可以在脚本运行前把大量的常见错误预先缓存起来。可以用PyChecker执行其代码
		捕捉潜在的问题。PyChecker 和 PyLint是第三方开源代码包。

	3、PyUnit：(也就是unittest)

		python有两个测试辅助工具。第一个是PyUnit，提供了一个面现对象的类框架，来定义和定制测试案例以及预期的结果。

	4、doctest：
		
		doctest标准库模块，提供第二个并且更为简单的做法来进行回归测试。

	5、IDE:

	6、配置工具:
		
		pfofile是标准库模块，为python实现源代码配置工具。
	
	7、调试器：

		Python标准库包含了一个命令行源代码调试器模块，称为pdb,这个模块提供了与常用C语言的调试器（gdb）工作非常类似
		的一个命令行界面。

	8、发布的选择：

		py2exe、PyInstaller 以及freeze都可以打包字节码以及python虚拟机，从而称为"冻结二进制"的独立的可执行文件，
		也就是不需要目标机器上有安装python，完全可以隐藏系统的代码。


本章小结：

	前路漫漫，勇往直前！





"=========================================================================================================="
								
					第 八 部分    高级话题

"========================================================================================================="
	
"---------------------------------------------------------------------------------------------------------"

					第 36 章    Unicode 和字节字符串	

"---------------------------------------------------------------------------------------------------------"

Pythddddon 3.0中的字符串修改：

	python 3.0最引人注目的修改之一，就是字符串对象类型的变化。

字符串的基础知识：
	
	字符编码方法：
		
		ASCII标准：定义了从0到127的字符代码，并且允许每个字符存储在一个8位的字节中。
		python内置函数ord给出了一个字符的二进制，并且chr针对一个给定的整数代码值返回其字符。
		
		ord('a')
			97
		chr(97)
			'a'

		Unicode文本通常叫做"宽字符"字符串，因为每个字符可能表示为多个字节。

	要在计算机内存储如此丰富的文本，我们要确保字符和原始字节之间可以使用一种编码相互转换，
	而编码就是把一个Unicode字符转换为字节序列以及从一个字节序列提取字符串的规则。
	字节和字符串之间的来回转换有两个术语定义：

		编码：根据一个想要的编码名称，把一个字符串翻译为其原始的字节形式

		解码：根据其编码名称，把一个原始字节串翻译为字符串形式的过程。

	ASCII把每一个字符映射为一个单字节，因此，不需要翻译工作，对于其他的编码，映射更复杂，每个字符产生多个字节。

	UTF-8编码，通过采用可变的字节数的方案，允许表示众多的字符。小于128的字符代码表示为单个字节；128-0x7ff之间
	的代码转换为2个字节，而每一个字节拥有一个128到255之间的值；0x7ff以上的代码转换为3个或4个字节序列，序列中的
	每个字节值在128到255之间。

	由于编码的字符映射把字符分别给同样的代码以保持兼容性，因此ASXII是UTF-8的子集。
	反过来说，对应小于128的字符代码，UFT-8编码与ASCII是二进制兼容的。

	对于python程序员，编码指定为包含了编码名的字符串。Pyhton带有大约100种不同的编码，导入encodings模块
	help(encodings)会显示很多编码名称。


Python 的字符串类型：

	Python 2.X ：
		
		str 表示8位文本和二进制数据。
		unicode 用来表示宽字符Unicode文本。

	Python 3.X (3种字符串对象类型--一种文本，两种二进制数据)

		str 表示Unicode文本（8位的和更宽的），str类型不可改变的字符序列。

		bytes 表示二进制数据，bytes类型为一个8位整数的不可变序列，表示绝对的字节值。
		
		bytearray 是一种可变的bytes类型，bytearray类型是一个变体，可变并且支持在原处修改。


文本和二进制文件：

	文本文件：

		读取字节将内容解码，并且返回一个str，写入会接受一个str,并且传输到文件之间自动编码它。

	二进制文件：

		二进制模式打开一个文件，读取其数据不好任何方式解码它，直接返回内容，作为一个bytes对象；
		写入类似地接受一个bytes对象，并且将其传送到文件中未经修改。

	注意：内置函数open的模式字符串参数，在python3中至关重要，因为其内容不仅指定了一个文件处理模式，
	而且暗示了一个Python对象类型。例如：模式rb、wb和rb+暗示bytes，而r、w+和rt暗示str。


Python 3.0中的字符串应用：

	在python 3.0中，所有当前字符串常量形式，'xxx'、"xxx"和三引号字符串块，都产生一个str;在它们任何一个
	前面添加一个b或B，则会创建一个bytes。这个新的b'...'字符常量类似于用来抑制反斜杠转义的r'...'raw字符串。

		B = b'spam'
		S = 'eggs'
		type(B),type(s)
			(<class 'bytes'>, <class 'str'>)

		B
			b'spam'
		S
			'eggs'

	bytes对象实际行是较小的整数的一个序列。

		B[0],S[0]
			(115, 'e')
		B[1:],S[1:]
			(b'pam', 'ggs')
		list(B),list(S)
			([115, 112, 97, 109], ['e', 'g', 'g', 's'])

	bytes对象是不可修改的，就像str。

		B[0] = 'x'
			TypeError: 'bytes' object does not support item assignment

	python2.6中的u'XXX' 和 U'XXX' Unicode字符串常量形式在python 3.0中已经取消了，而是使用'XXX'替代，
	因为所有的字符串都是Unicode，即便它们包含所有的ASCII字符。


转换：

	尽管python 2.X 允许str 和 Unicode类型对象自由的混合（如果字符串包含7位的ASCII），python 3.0引入了一个鲜明
	的区别--str 和bytes类型对象不在表达式中混自动地合，并且当传递给函数的时候不会自动相互转换。

	因此，python 3.0基本上要求遵守一种类型或另一种类型，或手动执行显示转换：

		str.encode() 和 bytes(S, encoding)把一个字符串转换为其raw bytes形式，
			并且在此过程中根据一个str创建一个bytes.

		bytes.decode() 和 str(B, endcoding)把raw bytes转化为其字符串形式，
			并且在此过程中根据一个bytes创建一个str.

		S = 'eggs'
		S.encode()
			b'eggs'

		bytes(S,encoding='ascii')
			b'eggs'

		B = b'spam'
		B.decode()
			'spam'
			
		str(B,encoding='ascii')
			'spam'


		import sys
		sys.platform
			'linux'
		sys.getdefaultencoding()
			'utf-8'
			
	因为python3是bytes-like的，所以我们需要用split的话只能把它转为str

		# bytes object
  	  	b = b"example"

		# str object
		s = "example"

		# str to bytes
		bytes(s, encoding = "utf8")

		# bytes to str
		str(b, encoding = "utf-8")

		# an alternative method
		# str to bytes
		str.encode(s)

		# bytes to str
		bytes.decode(b)

编码Unicode字符串：

	当我们处理真正非ASCII Unicode文本的时候，编码和解码变得更有意义。

	编码ASCII文本：

		ASCII文本是一种简单的Unicode，存储为表示字符的字节值的一个序列：

		ord('X')
			88
		chr(88)
			'X'

		S = 'XYZ'
		S
			'XYZ'
		len(S)
			3
		[ord(c) for c in S]
			[88,89,90]

	编码非ASCII文本：

		可能在字符串中使用16进制或Unicode转义；16进制转义限制于单个字节的值
		但Unicode转义可以指定其值有两个或四个字节宽度的字符。

		chr(0xc4)
			'Ä'
		chr(0xe8)
			'è'

使用Python 3.0 Bytes对象：

	方法调用：
		
		如果想看看str拥有哪些bytes所没有是属性，可以查看dir内置函数。

		set(dir('abc')) - set(dir(b'abc'))
			{
				'format_map', 'isnumeric', 'isdecimal', 'isprintable', 'isidentifier', 
				'encode', 'casefold', 'format'
			}

		set(dir(b'abc')) - set(dir('abc'))

			{
				'fromhex', 'decode', 'hex'
			}


		
python 3.0 中其他字符串工具的变化：

	re模式匹配模块：

	struct二进制数据模块:
		用来从字符串创建和提取打包的二进制数据。但是打包的数据只是
		作为bytes和bytearray对象显示，而不是str对象。

		from struct import pack 
		pack(b'>i4sh',7,b'spam',8)
			b'\x00\x00\x00\x07spam\x00\x08'
		
	pickle对象序列化模块：

		pickle模块是python3总是创建一个bytes对象，我们可以使用该模块dumps调用来返回一个pickle字符串。

		import pickle
		pickle.dumps([1,2,3])
			b'\x80\x03]q\x00(K\x01K\x02K\x03e.'

		dump调用直接把试图把pickle字符串写入一个打开的输出文件中，必须以二进制读取。

		pickle.dump([1,2,3],open('temp','wb'))
		pickle.load(open('temp','rb'))
			[1, 2, 3]

	XML解析工具



本章小结：

	如何把非ASCII Unicode字符编写到字符串中？

	可以以十六进制转移(\xNN) 和 Unicode转义(\uNNN,\UNNNNN)编写到一个字符串中。




"---------------------------------------------------------------------------------------"

					第 37 章 管理属性

"---------------------------------------------------------------------------------------"
	
	本章将展开介绍前面所提到的属性拦截技术。


特性：

	特性协议允许我们把一个特定属性的get和set操作指向我们所提供的函数或方法，使得我们能够插入在属性
	访问的时候自动运行的代码。

	通过property内置函数来创建特性并将其分配给类属性，就像方法函数一样。

	一个特性管理一个单个的、特定的属性。

	基础知识：

	通过一个内置函数的结果赋给一个类属性来创建一个特性：

	attribute = property(fget,fset.fdel,doc)
		
	内置函数参数不是必需的，所有都可默认为None。
		fget 传递一个函数的拦截属性访问
		fset 传递一个函数进行赋值
		fdel 传递一个函数进行属性删除
		doc  接受一个文档字符串


	第一个例子：

		class Person:
			def __init__(self,name):
				self._name = name
			def getName(self):
				print('fetch...')
				return self._name
			def setName(self,value):
				print('change...')
				self._name = value
			def delName(self):
				print('remove...')
				del self._name

			name = property(getName,setName,delName,"name property docs")

		bob = Person('Bob Smith')
		print(bob.name)              #Runs getName
		bob.name = 'Robert Smith'    #Runs setName
		print(bob.name)              
		del bob.name                 #Runs dleName
		

描述符：

	描述符提供了拦截属性访问的一种替代方法，实际上。特性是描述符的一种---从技术上讲，property内置函数
	只是创建一个特定类型的描述符的一种简化方式，而这个描述符在属性访问时运行方法函数。

	描述符作为独立的类创建，并且她们就像方法函数一样分配给类属性。

	和特性一样，描述符也管理一个单个的、特定的属性。

	基础知识:

		描述符作为单独的类编写，并且针对想要拦截的属性访问提供命名的访问器方法。

		class Descriptor:
			"docstring goes here"
			def  __get__(self,instance,owner):...
			def  __set__(self,instance,value):...
			def	 __delete__(self,instance):...

		带有任何这些方法的类都可以看做是描述符，并且当它们的一个实例分配给另一个类的属性的时候。
		它们的这些方法是特殊的--当访问属性的时候，会自动调用它们。


		第一个示例：

			class Name：
				"name descriptor docs"
				def __get__(self,instance,owner):
					print('fetch ...')
					return instance._name
				def __set__(self,instance,value):
					print('change ...')
					instance._name = vuale
				def __delete__(self,instance):
					print('remove...')
					del instance._name


			class Person:
				def __init__(self,name):
					self._name = name

				name = Name()
			
			
			bob = Person('Bob Smith')
			print(bob.name)            #Runs Name.__get__
			bob.name = 'Robert Smith'  #Runs Name.__set__
			print(bob.name)
			del bob.name               #Runs Name.__delete__


		注意上段代码中：
			self 是Name类实例
			instance 是Person类实例
			owner是Person类实例


__getattr__ 和 __getattribute__:
			
	特性和描述符--管理特定属性的工具，__getattr__ 和 __getattribute__操作符重载方法提供了拦截类实例的
	属性获取的另一种方法。

	__getattr__ 针对未定义属性--也就是说，属性没有存储在实例上。

	__getattribute__ 针对每个属性。

	与特性和描述符不同，这些都是python的操作符重载协议的一部分，是类的特殊命名的方法，有子类继承，
	并且在隐式的内置操作使用实例的时候自动调用。

	第一个示例：

		class Person:
			def __init__(self,name):
				self._name = name

			def __getattr__(self,attr):
				if attr == 'name':
					print('fetch...')
					return self._name
				else:
					raise AttributeError(attr)

			def __setattr__(self,attr,value):
				if attr == 'name':
					print('changer...')
					attr = '_name'
				self.__dict__[attr] = value

			def __delattr__(self,attr):
				if attr == 'name':
					print('remove...')
					attr = '_name'
				del self.__dict__[attr]


			bob = Person('Bob Smit')
			print(bob.name)            #Runs __getattr__
			bob.name = 'Robert Smith'  #Runs __setattr__
			print(bob.name)
			del bob.name


本章小结：

	1、__getattr__ 和 __getattribute__有何区别？

		__getattr__方法针对未定义属性的获取运行
		__getattribute__方法针对所有的属性获取运行

	2、特性和描述符有何区别？

		特性充当一个角色，而描述符更为通用。

	3、特性和装饰器有何关联

		特性可以用装饰器语法编写。

	4、__getattr__和__getattribute__已经特性和描述符之间主要的功能区别是什么？

		__getattr__ 和 __getattribute__更通用，特性和描述符只针对一个特定属性提供访问拦截。







"----------------------------------------------------------------------------------------"

				第 38 章  装饰器

"----------------------------------------------------------------------------------------"
	
本章深入装饰器内部工作机制，学习编写新装饰器更高级方法。

什么是装饰器：

	装饰是为函数和类指定管理代码的一种方式。装饰器本身的形式是处理其他的可调用对象的可调用的对象。
	python装饰器以两种相关形式呈现：

		函数装饰器在函数定义的时候进行名称重绑定，提供一个逻辑层来管理函数和方法或随后对它们的调用。

		类装饰器在类定义的时候进行名称重绑定，提供了一个逻辑层来管理类，或管理随后调用它们所创建的示例。

	简而言之，装饰器提供了一种方法，在函数和类定义语句的末尾插入自动运行代码--对函数装饰器，在def的末尾
	对应类装饰器，在class的末尾。


为什么使用装饰器：

	1、装饰器有一种非常明确的语法，使得那些可能任意地远离主体函数或类的辅助函数调用更容易为人们发现。

	2、当主体函数或类定义的时候，装饰器应用一次，在对类或函数每次调用的时候不必添加额外代码。

	3、由于前面两点，装饰器使得一个API的用户不太可能忘记根据API需求扩展一个函数或类。
		
	
	装饰器自然地促进了代码的封装

	装饰器有潜在的缺点---当它们插入包装类的逻辑，它们可以修改装饰的对象的类型，并且它们可能引发额外的调用。



基础知识：

	装饰器的很多神奇之处可归结为自动重绑定操作。

	函数装饰器：

		函数装饰器是一种关于函数的运行时声明，函数的定义需要遵守次声明。
		
		语法：

			@decorator
			def F(arg):
				...

			F(99)

		映射为一对等的形式，器中装饰器是一个单参数的可调用对象，它返回与F具有相同数目的参数的一个可调用对象：

		def F(arg):
			...

		F = decorator(F)

		F(99)



		def decorator(F):           #F is func or method without instance
			def wrapper( *args):    #class instance in args[0] for method
				return wrapper

		@decorator              
		def fun(x,y):               #func = decorator(func)
			...
		func(6,7)                   #Really calls wrapper(6,7)


		class C:
			@decorator
			 def method(self,x,y):    #method = decorator(method)
				 ...

		X = C()
		X.method(6,7)                #really calls wrapper(X,6,7)


装饰器嵌套：

	语法：
			@A
			@B
			@C

			def f(...):
				...

			如下这样运行：
				
				def f(...):
					...
				f = A(B(C(f)))



编写函数装饰器:

	class tracer:
		def __init__(self,func):
			self.calls = 0
			self.func = func

		def __call__(self,*args):
			self.calls += 1
			print('call %s to %s' % (self.calls,self.func.__name))
			self.func( *args)

	@tracer
	def spam(a,b,c):        #spam = tracer(spam)
		print(a+b+c)
	

为什么使用装饰器：
	
	装饰器有两个潜在缺陷：

		1、类型修改：

			当插入包装器的时候，一个装饰器函数或了不会保持其最初的类型--其名重新绑定到一个包装器对象。

		2、额外调用：

			每次调用装饰器对象的时候，会引发一次额外调用所需的额外性能成本

	好处:

		1、明确的语法

		2、代码可维护性
		
		3、一致性




"------------------------------------------------------------------------------------------------------"

					第 39 章          元 类

"-----------------------------------------------------------------------------------------------------"
	
	元类只是扩展了装饰器的代码插入模式。
	元类允许我们拦截并扩展类创建

提高魔力层次：

	1、内省属性：
		
		像__class__和__dict__这样的属性允许我们查看python对象的内部实现方面

	2、运算符重载方法：

		像__str__和__add__这样特殊命名的方法，来编写来拦截并提供应用于类实例的内置操作的行为。

	3、属性拦截方法：

		__getattr__,__setattr__和__getattribute__允许包装的类插入自动运行的代码

	4、类特性：

		内置函数property允许我们把代码和特殊的类属性关联起来，当获取、赋值或删除该属性的时候自动运行代码

	5、类属性描述符：
		
		描述符允许我们在单独类中编写__get__、__set__和__delete__处理程序方法

	6、函数和类装饰器


	元类是这些技术的延续---允许我们在一条class语句的末尾，插入当创建一个类对象的时候自动运行的逻辑。



元类模型：

	类是类型，类型也是类，即：

		1、类型由派生自type的类定义。

		2、用户定义的类是类型类的实例。

		3、用户定义的类是产生它们自己的实例的类型。


	元类是Type的子类:

		type是产生用户定义的类的一个类

		元类是type类的一个子类

		类对象是type的一个实例，或一个子类

		实例对象产生字一个类


本章小结：

	1、什么是元类

		元类是用来创建一个类的类

	2、如果什么一个元类

		class C(metaclass = M)


