
学习手册

"---------------------------------------------------------------------------------------------------------"  
					第四章   python 对象类型  
"----------------------------------------------------------------------------------------------------------"

1、import 和 from 

import 语句将模块作为一个整体载入，并使用模块名后跟一个属性名来获取使用。
内置的dir函数，可以使用它获得模块内部的可用的变量名列表。

from 和import 很相似，只不过增加了对载入组件的变量名的额外的赋值，从技术上讲，from复制了模块的属性，以便属性能够成为接收者的直接变量。

from语句从某种意义上来说战胜了模块的名称空间分隔的目的，以为from把变量从一个文件复制到另一个文件，这可能导致在导入的文件中相同名称的变量被覆盖（不会警告）。这根本上回导致名称空间重叠在一起，至少会在复制变量上回重叠。



2、核心类型

python内置对象：数字、字符串、列表、字典、元组、文件、集合。

其他类型(类型、None、布尔型)、编程单元类型(函数、模块、类)、与现实相关的类型（编译的代码堆栈跟踪）

核心类型中，数字、字符串和元组是不可变的，列表和字典可以自由改变，字符串，列表、元组是序列，字典是映射。

集合:集合是最近增添到python语言中的类型，它不是映射也不是序列，相反他是唯一的不可变的无序集合，集合可以通过内置对象set函数而创建或使用python3中集合常量和表达式创建，集合更像是一个无值的字典的键。


字典：字典不是队列，而是一种映射。映射是一个其他对象的集合，但是他们是通过键而不是相对位置来存储的。
	  字典是python核心对象中唯一的一种映射类型，也具有可变性。

文件：文件对象是python代码对电脑上外部文件的主要接口。虽然文件是核心类型，但是它有些特殊：没有特定的常量语法创建文件。要创建一个文件对象，需要调用内置的open函数一字符串的形式传递给它一个外部的文件名以及一个处理模式的字符串。

Python还有额外的类文件工具:管道、先进先出队列（FIFO）、套接字、通过键访问文件、对象持久、基于描述符的文件、关系数据库和面向对象数据库接口等。例如，描述符文件支持文件锁定和其他的底层工具，问套接字提供网络和进程间通信接口。


Python3中类型已经和类结合起来了。

python中允许编写代码来检验它所处理的对象的类型，python中至少有三种方法可以做到:

1:
		if type(L) == type([]):   
			print('yes')

2:       
		if type(L) == list:  
			print('yes')

3:
		if isinstance(L,list):  
			print('yes')

核心python概念(可能是唯一一个)：在代码中检验了特定的类型，实际上是破坏了它的灵活性，即限制它使用一种类型工作。没有这样的检测，代码也许能使用整个范围的类型工作。

这与多太思想有些关联，它是由Python没有类型声明而发展出来的。在python中，我们编写对象接口而不是类型。不关注于特定的类型意味着代码会自动地适应它们中的很多类型：任何具有兼容接口的对象均能够工作,而不管它是什么对象类型。尽管支持类型检测（极少情况下，是必要的），但是它并不是一个“python式”的思维方法。事实上，多态也是使用Python的一个关键思想。

"多态"意味着一个操作符的意义取决于被操作的对象。这将变成使用好Python的关键思想之一：不要把代码限制在特定的类型上，使代码自动适应多种类型。


我们学的这些数字、字符串、列表、字典、集合类型，是对象仅是对象而已，并不一定是面向对象。面向对象是一种往往要求有继承和python类声明的概念。


"----------------------------------------------------------------------------------------------------------"  
						第五章  数字    
"----------------------------------------------------------------------------------------------------------"

在python中数字并不是一个真正的对象类型，而是一组类似类型的分类。

yield x                    生成器函数发送协议

lambda args:expression     生产匿名函数

x if y else z              三元选择表达式

x or y                     逻辑或（只有x 为假，才会计算y）

x and y                    逻辑与（只有x 为真，才会计算y）

not x                      逻辑非

x in y , x not in y        成员关系（可迭代对象、集合）

x is y , x is not y        对象实体测试

x | y                      位或

x ^ y                      位异或

x // y                     真除法

x[i:j:k]                   分片

x(...)                     调用（函数、方法、类及其他调用）

(...)                      元组、表达式、生成器表达式

[...]                      列表、列表解析

{...}                      字典、集合、集合和字典解析


列表解析：
	
	根据已有的列表，高效创建新列表的方式。列表解析是python迭代机制的一种应用。
	
	语法：
	
	[expression for iter_val in interable]
	
	[expression for iter_val in interable if cond_expr]

	例如：
	L = [ i**2 for i in range(1,11) if i >= 4 ]
	
	print L
	
	[16,25,36,49,64,81,100]



协程：

协程是一种用户级的轻量级线程。协程拥有自己的寄存器上下文和栈。

协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。

因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，

就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。

在并发编程中，协程与线程类似，每个协程表示一个执行单元，有自己的本地数据，与其它协程共享全局数据和其它资源。

目前主流语言基本上都选择了多线程作为并发设施，与线程相关的概念是抢占式多任务（Preemptive multitasking），

而与协程相关的是协作式多任务。



yield与send实现协程操作:

在函数内部含有yield语句即称为生成器。

def foo():

	while True:
	
		x = yield
			
		print("value:",x)

g = foo()        #g 是一个生产器

next(g)          #程序运行到yield就停住了，等待下一个next

g.send(1)        #我们给yield 发送值1，然后这个值就被赋值给了x,并且打印出来，然后继续下一次循环停在yield处

g.send(2)        #同上

next(g)          #没有给赋值，执行print语句，打印None,继续循环停在yield处


我们都知道，程序一旦执行到yield就会停在该处,并且将其返回值进行返回.上面的例子中，我们并没有设置返回值，

所有默认程序返回的是None。我们通过打印语句来查看一下第一次next的返回值：

print(next(g))

####输出结果#####
	
	None

正如我们所说的，程序返回None。接着程序往下执行，但是并没有看到next()方法。

为什么还会继续执行yield语句后面的代码呢？这是因为，send()方法具有两种功能：

第一，传值，send()方法，将其携带的值传递给yield，注意，是传递给yield，而不是x,然后再将其赋值给x；

第二，send()方法具有和next()方法一样的功能，也就是说，传值完毕后，会接着上次执行的结果继续执行，

知道遇到yield停止。这也就为什么在调用g.send()方法后，还会打印出x的数值。

有了上述的分析，我们可以总结出send()的两个功能：1.传值；2.next()。

既然send()方法有和next一样的作用，那么我们可不可以这样做：

def foo():
	    
	while True:
		        
		x = yield
		
		print("value:",x)
		   
g = foo()
	
g.send(1) #执行给yield传值,这样行不行呢?

执行结果：TypeError: can not send non-None value to a just-started generator

错误提示:不能传递一个非空值给一个未启动的生成器。

也就是说，在一个生成器函数未启动之前，是不能传递数值进去。必须先传递一个None进去或者调用一次next(g)方法，

才能进行传值操作。至于为什么要先传递一个None进去，可以看一下官方说法。

Because generator-iterators begin execution at the top of the
generator function body, there is no yield expression to receive
a value when the generator has just been created.  Therefore,
calling send() with a non-None argument is prohibited when the
generator iterator has just started, and a TypeError is raised if
this occurs (presumably due to a logic error of some kind).  Thus,
before you can communicate with a coroutine you must first call
next() or send(None) to advance its execution to the first yield
expression.

问题就来，既然在给yield传值过程中，会调用next()方法，那么是不是在调用一次函数的时候，

是不是每次都要给它传递一个空值？有没有什么简便方法来解决這个问题呢？答案，装饰器！！看下面代码:

def deco(func):  # 装饰器:用来开启协程
	
	def wrapper():

		res = func()

		next(res)

		return res    #返回一个已经执行了next的函数对象

	return wrapper

@deco

def foo():

	food_list = []

	while True:
		
		food = yield food_list    #返回添加food的列表

		food_list.append(food)

		print("elements in foodlist are:",food)

g = foo()

print(g.send('苹果'))

print(g.send('香蕉'))

print(g.send('菠萝'))

###########输出结果为######

elements in foodlist are: 苹果

['苹果']

elements in foodlist are: 香蕉

['苹果', '香蕉']

elements in foodlist are: 菠萝

['苹果', '香蕉', '菠萝']


这里我们要明确一点，yield的返回值和传给yield的值是两码事！！

yield的返回值就相当于return的返回值，这个值是要被传递出去的,而send()传递的值，是要被yield接受，

供函数内部使用的的，明确这一点很重要的。那么上面的打印，就应该打印出yield的返回值，

而传递进去的值则本保存在一个列表中。






装饰器：


装饰器本质上是一个Python函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外的功能，

装饰器的返回值也是一个函数或类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、

缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计。

有了装饰器，我们可以抽离大量与函数功能本身无关的雷同代码到装饰器中并继续使用。概括的将，装饰器的作用

就是为已经存在的对象添加额外的功能。


例子： 定义一个函数专门处理日志，日志处理完之后执行代码

def use_logging(func):
	
	logging.warn("%s is running"% func.__name__)
	
	func()

def foo():

	print('i am foo')

use_logging(foo)


这样做的逻辑没有问题，功能实现了，但是我们调用的时候不再试调用真正的业务逻辑函数foo，而是变成了use_logging函数

破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个 foo 函数作为参数传递给 use_logging 函数，

那么有没有更好的方式的呢？当然有，答案就是装饰器。


def use_logging(func):

	def wrapper():

		logging.warn("%s is running"% func.__name__)

		return func()

	return wrapper

def foo():
	print('i am foo')


foo = use_logging(foo) #因为装饰器use_logging(foo)返回的函数对象wrapper,这条语句相当于foo = wrapper

foo()                  # 执行foo()就相当于执行 wrapper()


@语法糖

@ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。

def use_logging(func):

	def wrapper():
	
		logging.warn("%s is running" % func.__name__)
		
		return func()
	return wrapper
							 

@use_logging

def foo():
	
	print("i am foo")
									 
foo()

如上所示，有了@，我们就可以省去foo = use_logging(foo)这一句了，直接调用 foo() 即可得到想要的结果。

装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，

可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。



*args、**kwargs:

可能有人问，如果我的业务逻辑函数 foo 需要参数怎么办？比如：

def foo(name):
	
	print("i am %s" % name)

我们可以在定义 wrapper 函数的时候指定参数：

def wrapper(name):
	        
		logging.warn("%s is running" % func.__name__)
			    
		return func(name)

	return wrapper


这样 foo 函数定义的参数就可以定义在 wrapper 函数中。这时，又有人要问了，如果 foo 函数接收两个参数呢？

三个参数呢？更有甚者，我可能传很多个。当装饰器不知道 foo 到底有多少个参数时，我们可以用 *args 来代替：

def wrapper(*args):
	
		logging.warn("%s is running" % func.__name__)
			        
		return func(*args)

	return wrapper





类装饰器：

没错，装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。

使用类装饰器主要依靠类的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。


class Foo(object):
	
	def __init__(self, func):
		
		self._func = func

		def __call__(self):
			
				print ('class decorator runing')
									        
				self._func()
				
				print ('class decorator ending')
											 
@Foo

def bar():
	
	print ('bar')
													 
bar()




在python中变量不需要声明，但是使用之前必须赋值，在混合类型的表达式中，python首先将被操作

的对象转换成其中最复杂的操作对象的类型，然后再对相同的类型的操作对象进行数字运算。

在python3中有3种方法计算平方根：使用一个模块函数、一个表达式或一个内置函数。

import math
math.sprt(144)

144**.5

pow(144,.5)

模块是外部组件，而内置函数位于一个隐形的命名空间内，python会自动搜索程序的变量名。

这个命名空间对应Python3中为builtins模块（python2.6中的__builtin__）。


小数：

from decimal import Decimal 

printf(Decimal('0.1') + Decimal('0.1') + Decimal('0.1') -Decimal('0.3'))

Decimal('0.0')


decimal.getcontext().prec = 4 (设置精度，小数点后4位)


分数：

from fractions  import Fraction

x = Fraction(1,3)

y = Fraction(4,6)

printf(x + y)

Fraction(1,1)


print(x - y)

Fraction(-1,3)


print(x * y)

Fraction(2,9)




集合：

集合(set)，这是一些唯一的，不可变的对象的一个无序集合（collection）.


集合对象支持与数学集合理论相对应的操作。

要创建一个集合对象，向内置的set函数传递一个序列或其他的可迭代的对象：

集合通过表达式操作符支持一般的数学集合运算。注意，不能在一般序列上应用这些表达式，

必须通过序列创建集合后才能使用。

x = set('abcde')

y = set('bdxyz')

print(x)

	set(['a', 'c', 'b', 'e', 'd'])

'e' in  x
	
	True

x - y
	
	set(['a','c','e'])

x | y

	set(['a','c','b','d','y','x','z'])

x & y
	
	set(['b','d'])

x ^ y

	set(['a','c','e','y','x','z'])

x > y ,x < y
	
	(False,False)


除了表达式，集合对象还提供了对应这些操作的方法。


"----------------------------------------------------------------------"

					第六章   动态类型简介
	
"----------------------------------------------------------------------"

动态类型以及它提供的多态性是python语言简洁性和灵活性的基础。


静态编译类型语言：C、C++、Java，Python是动态类型模型的领域，在python中，类型是在运行过程中自动决定的，

而不是通过代码声明。这意味着没有比要声明变量，这个概念实质上对变量、对象和他们之间的关系都适用。


变量、对象和引用：

当在Python中运行赋值语句a = 3 时，即使没有告诉Python将a作为一个变量来使用，或者没有告诉a应该作为一个整数类型

对象，但一样能工作，在python语言中，这些都会以一种非常自然的方式完成，就像下面这样：

变量创建：

	一个变量（也就是变量名），就像a，当代码第一次给它赋值时就创建了它。之后的赋值将会改变已创建的比变量名的值。

	从技术上讲，Python在代码运行之前先检查变量名，可以当成是最初的赋值创建变量。

变量类型：

	变量永远不会有任何的和它关联的类型信息或约束。类型的概念是存在于对象中而不是变量名中。变量原本是通用的，它只是

	在一个特定的时间点，简单地引用了一个特定的对象而已。

变量使用：

	当变量出现在表达式中时，它会马上被当前引用的对象所代替，无论这个对象是什么类型。此外，所有的变量必须在使用前明确地

	赋值，使用未赋值的变量会产生错误。

总而言之，变量在赋值的时候才创建，它可以引用任何类型的对象，并且必须在引用之前赋值。这意味着，不需要通过脚本声明所要

使用的名字，但是，必须初始化名字然后才能更新他们，例如：必须把计数器初始化为0，然后才能增加它。


对于动态类型应清楚的将变量名和对象划分开来

	例如： a = 3

	Python 将会执行三个不同步骤去完成这个请求，这个步骤反映了Python语言中的所有赋值操作：

	1、创建一个对象来代表值3
	
	2、创建一个比变量a,如果它还没有创建的话

	3、将变量与新的对象3相连接

变量和对象保存在内存中不同的部分，并通过连接相关联，变量总是链接到对象。

在运行a = 3后，变量a变成对象3的一个引用。在内部，比变量事实上是到对象内存空间的一个指针。

在python中从变量到对象的连接称为引用，也就是说，引用是一种关系，以内存中的指针的形式实现。

一旦变量被使用，Python自动跟随这个变量到对象的连接。
	
	变量是一个系统表的元素，拥有指向对象的连接的空间。

	对象是分配的一块内存，有足够的空间去代表它们所代表的值。

	引用是自动形成的从变量到对象的指针。

每一个对象都有两个标准的头部信息：一个类型标志符去标识这个对象的类型，以及一个引用的计数器，用来决定是不是

可以回收这个对象。


类型属于对象，而不是变量：



共享引用：

a = 3

b = a

变量a和b都引用了相同的对象（也就是指向了相同的内存空间）。在python中叫共享引用，多个变量名引用了同一个对象。

a = 3

b = a

a = 'spam'

变量a引用了由常量表达式'spam'所创建的新对象，但是变量b仍然引用原始对象3.因为这个赋值运算改变的不是对象3，

仅仅是变量a的引用。


a = 3

b = a 

a = a + 2

给一个变量赋一个新的值，并不是替换了原始的对象，而是让这个变量去引用完全不同的一个对象。实际的效果就是对一个变量赋值。

仅仅是影响那个被赋值的变量。



共享引用和相等：

由于Python的引用模型，在Python中有两种不同的方法去检查是否相等，例如：
L = [1,2,3]

M = L

pirnt(L == M)
	
	True

print(L is M)

	True

第一种技术"==操作符"，测试两个被引用的对象是否有相同的值。这种方法往往在python中用作相等的检查。

第二种方法"is操作符"，是检查对象的统一性。如果两个变量名精确地指向同一个对象，它会返回True,这是一种更严格形式的相等测试。

实际上，is只是比较实现引用的指针，所以如果必要的话是代码中检测共享引用的一种办法。如果变量名引用值相等，但是是不同的对象，

它的返回值将是Flase

L = [1,2,3]

M = [1,2,3]

pirnt(L == M)

	True

print(L is M)

	False

在sys模块中getrefcount函数返回对象引用的次数。例如查询整数对象1时：

import sys

sys.getrefcount(1)



"-----------------------------------------------------------------------------"

					第七章          字符串
		
"-----------------------------------------------------------------------------"

在python中，字符串变成了一个强大的处理工具集，没有单个字符的这种类型。


单双引号字符串是一样的：

在python字符串中，单引号和双引号可以互换。两种形式能够使用是因为你不使用反斜杠转义字符就可以实现在

一个字符串中包含其余种类的引号，即是你可以在一个双引号中嵌入一个单引号，反之亦然

str1 = 'knight"s'

str2 = "knight's"

此外，python自动在任意的表达式中合并相邻的字符串常量，尽管可以简单的在他们之间增加"+"操作符来明确的表示

这是一个合并操作。（这种形式放在园括号中，就可以允许跨越多行）

title = "Meaning "  'of ' "Life "

print(title)
		
	'Meaning of Life'
	
注意，在这些字符串中间增加逗号会创建一个元组，而不是一个字符串。

在Python中，零（空）字符不会像C语言那样去结束一个字符串。相反，Python在内存中保持了整个字符串的长度和文本。

事实上，Python中没有字符会结束一个字符串。


raw字符抑制转义：

如果字母r(大写或小写)出现在字符串的第一个引号前面，它将关闭转义机制。

注意：尽管有用，但一个raw字符串也不能以单个的反斜杠结尾，因为，反斜杠会转义后续引用的字符，仍然必须转义外围引号

字符以将其嵌入到该字符串中，也就是说，r"...\" 不是一个有效的字符串常量，一个raw字符串不能以奇数个反斜杠结束。



三重引号编写多行字符串块：

python 把所有在三重引号之内的文本收集到一个单独的多行字符串中，并在代码折行处嵌入了换行字符(\n).

三重引号字符串常用于文档字符串，当它出现在文件的特定地点时，被当作注释一样的字符串常量。



基本操作：

与C字符数组不同的是，使用python字符串时，不用分配或管理存储数组，只要在需要时创建字符串对象，

让python去管理底层的内存空间。


pyhton在执行"+","*"操作符是能根据数字和字符串正确的执行时因为它知道操作对象的类型。

python不允许你在"+"表达式中混数字和字符串：例如"abc" + 9 

字符串定义为字符的有序集合，所以我们能够通过其位置获得他们的元素。


索引和分片：

与C语言一样，Python偏移量从0开始的，并比字符串的长度小1.与c语言不同，

python支持类似在字符串中使用负偏移这样的方法从序列中获取元素。

一个负偏移与这个字符串的长度相加后得到这个字符串的正的偏移量。


当使用一对以冒号的偏移量来索引字符串的序列对象时，Python将返回一个新的对象，其中包含了以这对偏移

所标识的连续的内容。左边的偏移为下边界（包含下边界在内），而右边的为上边界（不包含上边界在内）的

所有元素的新的对象。如果被省略，上、下边界的默认值分别为0和分片的对象的长度。


扩展分片：第三个限制值

X[I:J:K]表示：索引X对象中的元素，从偏移为I直到偏移为J-1,每隔K元素索引一次。

第三个限制为-K，默认为1，这就是通常一个切片中从左至右提取每一个元素的原因。

负数作为步进。例如分片表达式"Hello" [::-1]返回新的字符串"olleH",步进-1表示

分片将从右至左进行而不是从左到右。实际效果就是讲序列进行反转。

通过一个负数步进，两个边界的意义实际上进行了反转。也就是说，

分片s[5:1:-1]以反转的顺序取从2到5的元素。



字符串转换工具：

Python的设计座右铭之一就是：拒绝猜的诱惑。

int函数将字符串转换成数字，而str函数将数字转换成字符串表达形式。float把字符串转换成浮点数。

int,float只能对数字字符串进行转换。


字符串代码转换：

单个字符串通过内置ord函数转换成对应的ASCII码，这个函数实际返回是这个字符在内存中对应的字符的二进制。

而chr函数将会执行相反的操作，获取的ASCII码转化为对应的字符：

>>> ord('s')

115

>>>chr(115)

's'

字符串方法实例：修改字符串

内置list函数（或一个对象构造函数调用）以任意序列中的元素创立一个新的列表。

>>>s = 'spammy'

>>>l = list(s)

>>>l

['s','p','a','m','m','y']


修改列表之后，需要将其变回一个字符串，可以用字符串方法join将列表"合成"一个字符串。

>>>s = ''.join(l)

>>>s

spammy


字符串方法实例：文本解析

>>> line='aaa bbb ccc'

>>>cols = line.split()

>>>cols

['aaa','bbb','ccc']

字符串的split方法将一个字符串分割为一个子字符串的列表，以分割符字符串为标准。


字符串格式化表达式，python中的字符串格式化可以两种形式实现：

字符串格式化表达式：

	基于c语言的"printf"模型。

字符串格式化方法调用：

	python中独有的方法，和字符串格式化表达式功能很大重叠。


python在对字符串操作的时候定义了%二进制操作符（%在数字中是除法取余数的操作符），当应用到字符串上，

%提供了简单的方法对字符串的值进行格式化，这一操作取决于格式化定义的字符串。


格式化字符串：

1.在%操作符的左侧放置一个需要进行格式化的字符串，这个字符串带有一个或多个嵌入的转换目标，都以%开头（例如%d）

2.在%操作符的右侧放置一个（或多个，嵌入到元组中）对象，这些对象将会插入到左侧想让python进行格式化字符串的一个

（或多个）转换目标的位置上。

例如：

>>> 'That is %d %s bird!' % (1,'dead')

That is 1 dead bird!

>>> exclamation = "Ni"

>>> "The knights who say %s!" % exclamation

The knights who say Ni!

>>> "%s ---%s---%s" %(42,3.14159,[1,2,3])

'42 ---3.14.159---[1,2,3]'

一个整数，一个浮点数和一个列表对象，但是目标左侧都是%s,这就表示要把他们转换成字符串。

由于每一个对象的每个类型都可以转换为字符串，每一个与%s一同参与操作的对象类型都可以转换代码。

另外，格式化总会返回一个新的字符串作为结果而不是对左侧的字符串进行修改。


基于字典的字符串格式化：

字符串的格式化同时也允许左边的转换目标来引用右边字典中的键来提取对应的值。

>>>"%(n)d %(x)s" %{"n":1,"x":"spam"}

'1 spam'


字符串格式化调用方法：format方法

字符串对象的format方法使用主体字符串作为模板，并且接受任意多个表示将要根据模板替换的值的参数。

在主体字符串中，花括号通过位置（例如{1}）或关键字指出替换目标及将要插入的参数。

例如：

>>> template = '{0},{1} and {2}'

>>> template.format('spam','ham','eggs')

'spam,ham and eggs'

>>>template = '{motto},{pork} and {food}'

>>>template.format(motto='spam',pork='ham',food='eggs')

'spam,ham and eggs'


就像%表达式和其他字符串方法一样，format创建并返回一个新的字符串对象。


添加键、属性和偏移量：

像%格式化表达式一样，格式化调用可以变的更复杂以支持更多高级用途。

>>>import sys

>>> 'My {config[spam]} runs {sys.platform}'.format(sys=sys,config={'spam':'laptop'})

'My laptop runs linux'


添加具体格式化：

对于格式化方法，我们在替换目标的标识之后使用一个冒号，后面跟着可以指定字段大小，

对齐方式和一个特定类型编码的格式化声明。如下是可以在一个格式字符串中作为替代目标出现的形式化结构：

{fieldanme!conversionflag:formatspec}

在这个替代目标语法中:

fieldname是指定参数的一个数字或关键字，后面跟着可选的".name"或"[index]"成分引用。

conversionflag可以是r、s、或者a分别是在该值上对repr、str或ascii内置函数的一次调用。

formatspec指定了如何表示该值，包括字段宽度、对齐方式、补零、小数点精度等

例子：

>>>'{0:10} = {1:10}'.format('spam',123.4567)

'spam       =   123.4567'

>>>'{0:.2f}'.format(1/3.0)

'0.33'



通常意义下的类型分类：


数字（整数、浮点数、二进制、分数等）

	支持加法和乘法等。

序列（字符串、列表、元组）

	支持索引、分片和合并等

	对于任意的序列对象X 和 Y：

	X + Y : 将会创建一个包含了两个操作对象的新的序列对象。

	X * N : 将会创建一个包含操作对象X内容N份拷贝的新的序列对象。


映射(字典)

	支持通过键的索引等。


可变类型能够在原处修改：

不可变类型（数字、字符串、元组、不可变集合）
	
	不支持在原处修改。

可变类型（列表、字典、可变集合）



字符串find方法能用于搜索列表吗？

不行，因为方法是类型特定的，只能用于单一数据类型上。像X+Y这样的表达式和len(X)这样的内置函数是通用的。

可以用在多种类型上。


在python，怎么修改字符串？

字符串无法被修改，字符串是不可改变的。但是可以通过切片运算、合并、格式化、方法调用创建新的字符串，将结果赋值

给最初的变量名，从而达到相似的效果。





"---------------------------------------------------------------------------------------------------"

								    第八章 列表与字典

"---------------------------------------------------------------------------------------------------"

python 列表：

	任意对象的有序集合

	通过偏移读取

	可变长度、异构以及任意嵌套（异构：可以包含任何类型的对象而不仅仅是包含单个字符串。嵌套：创建列表的子列表的子列表）

	属于可变序列的分类

	对象引用数组(从技术上来讲，Python列表包含了零个或多个其他对象的引用)


常用列表常量和操作：

操作：           解释

L = []           一个空的列表

L = [0,1,2,3]    四项：索引为0到3

L = ['abc',['def','ghi']]   嵌套子列表


L = list('spam')     可迭代项目的列表

L = list(range(-4,4)) 连续整数的列表

L[i]              索引

L[i][j]           索引的索引

L[i:j]            分片

len(L)            求长度

L1 + L2           合并(同种类型)

L * 3             重复

for x in L:print(x) 迭代

3 in  L           成员关系


方法

L.append(4)       增长

L.extend([5,6,7]) 扩展

L.insert(I,X)     插入

L.index(1)        搜索

L.count(X)        元素个数

L.sort()          排序（从小到大）

L.reverse()       反转


语句

del L[k]          删除

del L[i:j]        删除

方法：

L.pop()           删除（最后一个元素）

L.remove(2)       删除

L[i:j] =[]        删除


L[i] = 1          索引赋值

L[i:j] =[4,5,6]   赋值

L = [x**2 for x in range(5)]  列表解析

list(map(ord,'spam'))


我们这里讨论的原处修改操作适用于可变对象：无论如何也不能在字符串、元组上修改。

可变性是每个对象类型的固有属性。



字典(dictionary)：

字典也许是Python之中最灵活的内置数据结构类型。如果列表看做是有序的对象集合，那么字典就是无序的对象集合。

他们主要区别是：字典当中的元素是通过键来存取，而不是通过偏移存取。


python字典的主要属性：

	通过键而不是偏移量来读取：（字典有时叫关联数组或者散列表(hash),通过键将一系列值联系起来）

	任意对象的无序集合:(与列表不同，保存在字典中的项并没有特定的顺序，各项随机排序，键提供了字典项的象征性位置)

	可变长、异构、任意嵌套：

	属于可变映射类型：

	对象引用表（散列表）：字典和列表一样，字典存储的是对象引用。


常见字典常量和操作：

操作                         解释

D = {}                      空字典

D = {'spam':2,'eggs':2}     两项目字典

	D['eggs']

D = {'food':{'ham':1,'egg':2}} 嵌套

	D['food']['ham']

D = dict.fromkeys(['a','b']) 其他构造技术

D = dict(zip(keyslist,valslist)) 关键字、对应的对、键列表

D = dict(name = 'Bob',age = 42) 创建字典
	
	{'name': 'Bob', 'age': 42}

'eggs' in D                  成员关系：键存在测试
	
	False

D.keys()                     获取字典的键

	dict_keys(['name', 'age'])

D.values()                   获取字典的值

	dict_values(['Bob', 42])

D.items()                    获取键+值

	dict_items([('name', 'Bob'), ('age', 42)])

D.copy()                      副本

D.get(key)                 获取某个键的值

D.update(D2)               合并

D.pop(key)                 删除

len(D)                     长度（存储的元素的数目）

D[key] = 42                新增/修改键

del D[key]                 根据键删除条目

list(D.keys())             字典视图(返回键组成的列表,python3.0)

D1.keys()&D2.keys()        查询相同的键

D = {x : x*2 for x in range(10)} 字典解析（python3.0）


注意：字典内键由左至右的次序几乎总是和原先输入的顺序不同。这样设计目的是快速执行键查找（散列查找），
键在内存中随机设定。

与列表相同，字典中已存在的索引赋值改变索引关联值，不同的是，每当对新字典键赋值（之前不存在的键），
会在字典中生成一个新的元素，但是列表不允许，python将会超出列表末尾的偏移视为越界并报错。想扩充列表
可以用append方法或分片赋值实现。


字典并非序列，你无法像字符串和列表那样直接通过一个for语句迭代他们，但是，如果需要遍历各项内容：调用字典的
keys方法，返回经过排列之后所有键的列表，再用for循环进行迭代。

实际上，python也可以遍历字典的键列表，而并不是多数for循环调用keys方法。就任何字典而言，写成for key in D:
和写成key in D.keys():效果是一样的。这其实是迭代器能够允许in成缘关系操作符用于字典的另一个实例。


字典用法注意事项：

	序列运算无效：字典是映射不是序列。

	对新索引赋值会添加项： 会生产新键

	键不一定总是字符串：任何不可变对象都可以做键（数字、字符串、元组）
		
		Matrix = {(2,3,4):88,(7,8,9):99}
	

创建字典的方法：

1、D = {'name':'mel','age':45}

2、D = {}
		D['name'] ='mel'
		D['age'] = 45

3、D = dict(name = 'mel',age = 45)

4、D = dict([('name','mel'),('age',45)])


这四种形式都会创建相同的两键字典，但是不同的条件下使用：

	如果你可以事先拼出整个字典，那么第一种方便

	如果你需要一次动态的建立字典的一个字段，第二种合适

	第三种关键字所需的代码比常量少，但是键必须都是字符串才行

	如果你需要在程序运行时把键和值逐步建成序列，最后一种比较有用。

如果所有键的值都相同，你可以用特殊形式对字典初始化---简单地传入一个键列表，以及初始值。

5、D = dict.fromkeys(['a','b'],0)
		{'a':0,'b':0}

6、字典解析表达式（python3）


Python3.0 中字典变化：

	1、支持字典解析表达式，这是列表和集合解析的"近亲"

	2、对于D.key、D.values和D.items方法，返回可迭代的视图，而不是列表

		如果想要应用列表操作或显示他们的值，必须通过内置函数list来运行这3个方法：

		D= dict(a=1,b=2,c=3)
		
			{'a': 1, 'b': 2, 'c': 3}

		K = D.keys()

			dict_keys(['a', 'b', 'c'])
		
		K[0]
			
			TypeError: 'dict_keys' object does not support indexing'

		list(K)
			
			['a', 'b', 'c']




	3、由于前面一点，需要新的编码方式通过排序键来遍历
	
		D = {'a':1,'b':2,'c':3}
		
		不可以：
		Ks = D.keys()
		ks.sort()  出错 AttributeError:'dict_keys' object has no attribute 'sort'

		可以：
		Ks = list(Ks)
		Ks.sort()

		可以：
		Ks = D.keys()
		for k in sorted(Ks):print(k,D[k])   
		
		可以：
		for k in sorted(D):print(k,D[k])


	4、不再直接支持相对大小比较，取而代之的是手动比较

		通过手动比较排序后的键列表来比较

		sorted(D1.items()) < sorted(D2.items)

		python3中字典相等性测试仍然有效。


	5、不再有D.has_key方法，相反，使用in成员关系测试




	
"-----------------------------------------------------------------------------------------"

							第九章 元组、文件及其他

"-----------------------------------------------------------------------------------------"

元组：


元组属性：

	任意对象的有序集合

	通过偏移存取

	属性不可变序列类型

	固定长度、异构、任意嵌套

	对象引用的数组


常见元组常量和运算：

运算                         解释

()                          空元组

T=(0,)                      单个元素的元组（非表达式）
	
	因为圆括号也可以把表达式括起来，如果圆括号里是单一对象是元组对象而不是简单表达式需特别说明
	如果想得到一个元组，只要在一个元素后，关闭括号之前加一个逗号就可以了。

	x = (40)	
		40
	
	y = (40,)
		(40,)


T=(0,'Ni',1.2,3)            四个元素的元组

T= 0,'Ni',1,2,3             四个元素的元组（和前列相同）
	
	在不会引起语法冲突的情况下，Python允许忽略元组的圆括号。


T=('abc',('def','ghi'))     嵌套元组

T=tuple('spam')             一个可迭代对象的项的元组
	('s', 'p', 'a', 'm')

T[i]                        索引

T[i][j]                     索引的索引

T[i:j]                      分片

len(T)                      长度

T1 + T2                     合并

T*3                         重复

for x in T:print(x)         迭代

'spam' in T                 成员关系

T.index('Ni')               搜索，元素所在元组中的位置

T.count('Ni')               计数


元组操作和字符串以及列表是一致的，值得注意的"+","*"以及分片操作应用元组时返回一个新元组
元组不提供字符串、列表、字典中的方法。如果想对元组排序，通常先转换其他类型。或者使用新的
sorted内置方法，它接受任何序列对象：

	T =('cc','aa','dd','bb')
	temp = list(T)
	temp.sort()
	T = tuple(temp)

	sorted(T)


为什么有了列表还要元组：

	元组是不可变类型提供了某种完整性，这样可以确保元组在程序中不会被另一个引用修改，而列表没有这个的保证。
	列表是定序集合的选择工具，可能需要进行修改，而元组能够处理其他固定关系的情况。


文件：

	我们讲文件主要是内置对象类型提供了一种可以存取python程序内部文件的方法。简而言之，内置open函数会创建
	一个python文件对象，可以作为计算机上一个文件链接。调用open之后，你可以通过返回的文件对象的方法来读写
	相关外部文件。


常见文件运算

操作                                    解释
 
这里的输入输出是相对程序而言的，而不是外部文件。

output = open(r'C:\spam','w')           创建输出文件（'w'是指写入）

input = open('data','r')				创建输入文件('r'是指读写)           

input = open('date')                    与上一行相同（'r'是默认值）

aString = input.read()                  把整个文件读进单一字符串

aString = input.read(N)					读取之后N个字节到一个字符串

aString = input.readline()              读取下一行（包括行末标识符）到一个字符串

aList   = input.readlines()             读取正个文件到字符串列表

output.write(aString)                   写入字节字符串到文件

output.writelines(aList)                把列表内的所有字符串写入文件

output.close()                          手动关闭（当文件收集完成时会替你关闭文件）

output.flush()                          把输出缓冲区刷到硬盘中，但不会关闭文件

anyFile.seek(N)                         修改文件位置到偏移量N处以便进行下一步操作

for line in open('data'):use line       文件迭代器一行一行读取

open('f.txt',encoding='latin-1')        python3.0 Unicode文本文件（str字符串）

open('f.bin','rb')                      python3.0 二进制byte文件  (byte字符串)




打开文件：

	处理模式：

		'r':代表输入打开文件（默认值） 
		'w'：输出生成并打开文件（文件不存在生成一个文件）
		'a'：代表在文件尾部追加内容而打开文件。

	b:在处理模式字符串尾部加上b可以进行二进制数据处理
	+:加上"+"意味着同时为输入和输出打开文件

	要打开的两个参数必须是python字符串，第三个参数是可选的，它能够控制输出缓存“传入"0"输出无缓存。


使用文件：

python程序中的文本文件都采用字符串形式。读取文件时返回字符串形式的文本，文本作为字符串传递给write方法。

基础用法提示：

	文件迭代器是最好用的读取行工具

	内容是字符串，不是对象

	close是通常选项

	文件是缓冲的并且是可查找的


实际应用中的文件:

注意：readline如果调用返回一个空字符串。这是python文件方法告诉我们已经达到文件底部。
文件的空行是含有换行符字符串（'\n'）,而不是空字符串。看一下交互模式会话：

	myfile = open('/home/zhangkun/myfile.txt','w')
	myfile.write('hello text file\n')
	myfile.write('\n')
	myfile.write('\n')
	myfile.write('aaaaaaaaaaaaaaa\n')
	myfile.close()


	myfile = open('/home/zhangkun/myfile.txt','r')
	myfile.readline()
		'hello text file\n'
	myfile.readline()
		'\n'
	myfile.readline()
		'\n'
	myfile.readline()
		'aaaaaaaaaaaaaaa\n'
	myfile.readline()
		''
注意：写入方法不会为我们添加行终止符('\n'),所以写入的时候程序必须包含它来严格地终止行。


python 3.0 中的文本和二进制文件：

	文件类型有open的第二个参数决定，模式字符串包含一个"b"表示二进制。python支持文本和二进制,
	但python3中，二者有区别：

		文本文件把内容表示为常规的str字符串，自动执行Unicode编码和解码，并且默认执行行末行转换。

		二进制文件把内容表示为一个特殊的bytes字符串类型，并且允许程序不修改地访问文件内容。


在文件中存储并解析python对象：

	注意：我们必须在写入的时候把对象转换成字符串，写入方法不会自动地替我们做任何像字符串格式转换的工作。

	x,y,z = 43,44,45
	s = 'spam'
	D = {'a':1,'b':2}
	L = [1,2,3]
	
	F = open('/home/zhangkun/myfile.txt','w')
	F.write(s+'\n')
	F.write('%s,%s,%s\n'%(x,y,z))
	F.write(str(L) + '$' +str(D)+'\n')
	F.close()


	chars = open('/home/zhangkun/myfile.txt','r').read()
		"spam\n43,44,45\n[1, 2, 3]${'a': 1, 'b': 2}\n"
	
	我们不得不使用转换工具，把文本文件中的字符串转换成真正的python对象。

	F = open('/home/zhangkun/myfile.txt','r')
	line = F.readline()
		'spam\n'
	line.rstrip() 
		'spam'
	
	使用字符串rstrip方法去掉多余的行终止符。

	想转换文件第三行所存储的列表和字典，可以使用eval内置函数，eval能够吧字符串当作可执行程序代码。

	line = F.readline()
		"[1, 2, 3]${'a': 1, 'b': 2}\n"
	parts = line.split('$')
		['[1, 2, 3]', "{'a': 1, 'b': 2}\n"]
	eval[parts[0]]
		[1, 2, 3]
	eval(parts[1])
		{'a': 1, 'b': 2}
	objects = [eval(p) for p in parts]
	objects
		[[1, 2, 3], {'a': 1, 'b': 2}]


用pickle存储python的原生对象

pickle模块能够让我们直接在文件中存储几乎任何python对象的高级工具，也并不要求我们把字符串转换来转换去。
它就像是超级通用的数据格式化和解析工具。例如，想在文件中存储字典

	存:
	D = {'a':1,'b':2}
	F = open('/home/zhangkun/myfile.pkl','wb')
	import pickle
	pickle.dump(D,F)
	F.close()

	
	取：
	F = open('/home/zhangkun/myfile.pkl','rb')
	E = pickle.load(F)
		{'a': 1, 'b': 2}

	pickle模块执行所谓的对象序列化，也就是对象和字节字符串之间的相互转换。
	open('/home/zhangkun/myfile.pkl','rb').read()
		b'\x80\x03}q\x00(X\x01\x00\x00\x00aq\x01K\x01X\x01\x00\x00\x00bq\x02K\x02u.'
	
	我们以二进制模式打开用来存储pickle化的对象的文件，二进制模式是必须的，因为pickle程序创建和使用一个
	bytes字符串对象，这些对象意味着二进制文件。

	F = open('/home/zhangkun/myfile.pkl','w')
	pickle.dump(D,F)
		TypeError: write() argument must be str, not bytes



文件山下文管理器：

	文件的上下文管理器比文件自身多了一个异常处理功能，它允许我们把文件代码包装到一个逻辑层，以确保退出后
	可自动关闭文件，而不是依赖垃圾收集。

	with open(r'C:\misc\data.txt') as myfile:
		for line in myfile:
			...use line here...

	
	myfile = open(r'C:\misc\data.txt')
	try:
		for line in myfile:
			...use line here...
	finally:
		myfile.close()


其他文件工具:

	标准流

	os 模块中的描述文件

	sockets 、pipes和FIFO文件

	通过键来存取的文件

	shell 命令流




重访类型分类:

python 核心内置类型，共有的一些属性，牢记下面几点：

	对象根据分类来共享操作：例如，字符串、列表、元组都共享诸如合并、长度和索引等序列操作。

	只有可变对象（列表，字典，集合）可以原处修改，不能修改数字、字符串、元组

	文件导出的唯一方法，因此可变性并不真的适用于它们--当处理文件的时候。它们的状态可能会修改，但是这与
	python的核心类型可变性限制不完全相同。

	"数字"包含了所有数字类型:整数、浮点数、复数、小数、分数。

	集合类似域一个无值的字典的键，但是，它们不能映射值，并且没有顺序；因此，集合不是一个映射类型或序列类型、
	frozenset是集合的一个不可变的版本。

	除了类型分类操作。所有的类型都有课调用的方法，这些方法通常特定于它们的类型。


对象类型      分类        是否可变
数字          数值          否
字符串        序列          否
列表          序列          是
字典          映射          是
元组          序列          否
文件          扩展          N/A
sets          集合          是
frozenset     集合          否
bytearray     序列          是


	

引用和拷贝：

你可以在程序范围内任何地方传递大型对象而不必在途中产生拷贝，然而，如果需要拷贝，那么可以明确要求：

	没有限制条件的分片表达式(L[:])能够复制序列。

	字典copy方法（X.copy()）能够复制字典。

	有些内置函数（list）能够生成拷贝（list(L)）
	
	copy标准库模块能够生成完整拷贝。

拷贝需要注意的是：无条件值的分片以及字典copy方法只能做顶层复制，也就是说。不能够复制嵌套的数据结构（如果有）
如果需要深层拷贝，使用标准copy模块，包括import copy语句，并编辑X = copy.deepcopy(Y)对任意嵌套对象Y做完整复制。


比较、相等性和真值：

一般来说，python中不同的类型的比较方法如下：
	
	数字通过相对大小进行比较。
	字符串是按照字典顺序，换一个字符接一个字符的对比进行比较("abc"<"ac")
	列表和元组从左到右对每部分的内容进行比较。
	字典通过排序之后的(键、值)列表进行比较。


python 中的真和假的含义：

真和假的概念是python中每个对象的固有属性：每个对象不是真就是假：
	
	数字如果非零，则为真
	其他对象如果非空，则为真

对象     值
"spam"   True

""       False

[]       False

{}       False

1        True

0.0      False

None     False


None 对象：

python还有一个特殊对象：None，总是被认为假，这是python中一种特殊数据类型的唯一值，一般都起到一个空的
占位符作用，与C语言的NULL指针类似。

记住：None不是意味着"未定义"，也就是说，None是某些内容，而不是没有内容（尽管起名字没有内容），他是一个真正的对象，
并且有一块内存，有python给定的一个内置名称。


bool类型：

python的布尔类型bool，只不过是扩展了python中真、假的概念。这样设计是为了让真值更为明显。

	当明确地用在真值测试时，Ture和False这些文字就变成1和0，但它们使得程序员意图更明确。
	交互模式下的布尔测试的结果打印成True和Flase的字样，而不是0和1，以使得程序的结果更明确。


Type 对象

python系统中的任何东西都是对象类型，而且可以有python程序来处理。

事实上，即使是类型本身在python中也是对象类型。

严格来说，内置函数type(x)能够返回对象X的类型对象。

有关类型名称需要提醒一下：python 2.2的每个核心类型都有个新的内置名来支持面向对象子类的类型定制：

dict、list、str、tuple、int、float、complex、byte、set和file。调用这些名称事实上是对这些对象
构造函数调用，而不仅仅是转换函数。

目前，python的类型也可以再分为子类，一般都建议使用isinstance


赋值生成引用，而不是拷贝：如下列：

	L = [1,2,3]
	M = ['X',L,'Y']M
		['X', [1, 2, 3], 'Y']

	L[1] = 0

	M
		['X', [1, 0, 3], 'Y']

如果不是这样，你可以明确地对它们进行拷贝以避免对象共享。就列表而言，你总能使用无限制条件的分片生产一个高级拷贝。

	L = [1,2,3]
	M = ['X',L[:],'Y']

	L[1]=0

	L
		[1,0,3]
	M:
		['X',L[1,2,3],'Y']


重复能够增加层次深度：

序列重复就好像多次将一个序列加到自己身上。下面例子中X赋值给重复四次的L,而Y赋值给包含重复四次的L的列表：

	L = [4,5,6]

	X = L * 4
		[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]

	Y = [L]*4
		[[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]

	L[1] = 0

	X
		[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]

	Y
		[[4, 0, 6], [4, 0, 6], [4, 0, 6], [4, 0, 6]]
	

留意循环数据结构：

如果遇到一个复合对象包含指向自身的引用，就称之为循环对象。无论何时python在对象中检查到循环，都会打印成[...],
而不会无限循环

	L = ['grail']
	L.append(L)
	
	L
		['grail',[...]]

	除了要了解方括号括起来的三个点代表对象中带有循环之外，循环结构可能导致程序陷入无法预期的循环当中。



不可变类型不可以在原处修改

	不可以在实地改变不可变对象，如果需要的话，你得通过分片、合并等操作来创建一个新对象，再向后赋值给原引用。
	T = (1,2,3)

	T[2]  = 4      error

	T = T[:2] + (4,)

	因为无法修改，就不会产生列表那种副作用。


本章小结：

	内置len函数会回传python中任何容器对象的长度(所含元素的数目)，这个是内置函数，而不是方法。
	内置函数和表达式可以跨越多种对象类型，方法特定于一种单一的对象类型，尽管通过某些方式可以
	在多种类型上使用(例如：索引在列表和元组中都有效)。

	pickle模块可以用于把python对象储存在文件中，而不用刻意转成字符串。struct模块也是相关的，但是，
	那是要把数据打包成为二进制格式，从而保存在文件中。

	分号用作语句分隔符，以把多条语句压缩成单独一行，表达式之间的逗号通常用来构建元组，即便没有包围圆括号。




"========================================================================="
						第三部分   语句和语法
"========================================================================="


"-------------------------------------------------------------------------"
	
							第十章 Python 语法简介					

"-------------------------------------------------------------------------"

	1、程序由模块构成
	2、模块包含语句
	3、语句包含表达式
	4、表达式建立并处理对象

python的语法实质上是由语句和表达式组成的。表达式处理对象并嵌套在语句中。语句编码实现程序操作中更大的逻辑关系。
此外语句还是对象生产的地方。

Python的语句：

	



	














