
学习手册

"---------------------------------------------------------------------------------------------------------"  
					第四章   python 对象类型  
"----------------------------------------------------------------------------------------------------------"

1、import 和 from 

import 语句将模块作为一个整体载入，并使用模块名后跟一个属性名来获取使用。
内置的dir函数，可以使用它获得模块内部的可用的变量名列表。

from 和import 很相似，只不过增加了对载入组件的变量名的额外的赋值，从技术上讲，from复制了模块的属性，以便属性能够成为接收者的直接变量。

from语句从某种意义上来说战胜了模块的名称空间分隔的目的，以为from把变量从一个文件复制到另一个文件，这可能导致在导入的文件中相同名称的变量被覆盖（不会警告）。这根本上回导致名称空间重叠在一起，至少会在复制变量上回重叠。



2、核心类型

python内置对象：数字、字符串、列表、字典、元组、文件、集合。

其他类型(类型、None、布尔型)、编程单元类型(函数、模块、类)、与现实相关的类型（编译的代码堆栈跟踪）

核心类型中，数字、字符串和元组是不可变的，列表和字典可以自由改变，字符串，列表、元组是序列，字典是映射。

集合:集合是最近增添到python语言中的类型，它不是映射也不是序列，相反他是唯一的不可变的无序集合，集合可以通过内置对象set函数而创建或使用python3中集合常量和表达式创建，集合更像是一个无值的字典的键。


字典：字典不是队列，而是一种映射。映射是一个其他对象的集合，但是他们是通过键而不是相对位置来存储的。
	  字典是python核心对象中唯一的一种映射类型，也具有可变性。

文件：文件对象是python代码对电脑上外部文件的主要接口。虽然文件是核心类型，但是它有些特殊：没有特定的常量语法创建文件。要创建一个文件对象，需要调用内置的open函数一字符串的形式传递给它一个外部的文件名以及一个处理模式的字符串。

Python还有额外的类文件工具:管道、先进先出队列（FIFO）、套接字、通过键访问文件、对象持久、基于描述符的文件、关系数据库和面向对象数据库接口等。例如，描述符文件支持文件锁定和其他的底层工具，问套接字提供网络和进程间通信接口。


Python3中类型已经和类结合起来了。

python中允许编写代码来检验它所处理的对象的类型，python中至少有三种方法可以做到:

1:
		if type(L) == type([]):   
			print('yes')

2:       
		if type(L) == list:  
			print('yes')

3:
		if isinstance(L,list):  
			print('yes')

核心python概念(可能是唯一一个)：在代码中检验了特定的类型，实际上是破坏了它的灵活性，即限制它使用一种类型工作。没有这样的检测，代码也许能使用整个范围的类型工作。

这与多太思想有些关联，它是由Python没有类型声明而发展出来的。在python中，我们编写对象接口而不是类型。不关注于特定的类型意味着代码会自动地适应它们中的很多类型：任何具有兼容接口的对象均能够工作,而不管它是什么对象类型。尽管支持类型检测（极少情况下，是必要的），但是它并不是一个“python式”的思维方法。事实上，多态也是使用Python的一个关键思想。

"多态"意味着一个操作符的意义取决于被操作的对象。这将变成使用好Python的关键思想之一：不要把代码限制在特定的类型上，使代码自动适应多种类型。


我们学的这些数字、字符串、列表、字典、集合类型，是对象仅是对象而已，并不一定是面向对象。面向对象是一种往往要求有继承和python类声明的概念。


"----------------------------------------------------------------------------------------------------------"  
						第五章  数字    
"----------------------------------------------------------------------------------------------------------"

在python中数字并不是一个真正的对象类型，而是一组类似类型的分类。

yield x                    生成器函数发送协议

lambda args:expression     生产匿名函数

x if y else z              三元选择表达式

x or y                     逻辑或（只有x 为假，才会计算y）

x and y                    逻辑与（只有x 为真，才会计算y）

not x                      逻辑非

x in y , x not in y        成员关系（可迭代对象、集合）

x is y , x is not y        对象实体测试

x | y                      位或

x ^ y                      位异或

x // y                     真除法

x[i:j:k]                   分片

x(...)                     调用（函数、方法、类及其他调用）

(...)                      元组、表达式、生成器表达式

[...]                      列表、列表解析

{...}                      字典、集合、集合和字典解析


列表解析：
	
	根据已有的列表，高效创建新列表的方式。列表解析是python迭代机制的一种应用。
	
	语法：
	
	[expression for iter_val in interable]
	
	[expression for iter_val in interable if cond_expr]

	例如：
	L = [ i**2 for i in range(1,11) if i >= 4 ]
	
	print L
	
	[16,25,36,49,64,81,100]



协程：

协程是一种用户级的轻量级线程。协程拥有自己的寄存器上下文和栈。

协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。

因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，

就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。

在并发编程中，协程与线程类似，每个协程表示一个执行单元，有自己的本地数据，与其它协程共享全局数据和其它资源。

目前主流语言基本上都选择了多线程作为并发设施，与线程相关的概念是抢占式多任务（Preemptive multitasking），

而与协程相关的是协作式多任务。



yield与send实现协程操作:

在函数内部含有yield语句即称为生成器。

def foo():

	while True:
	
		x = yield
			
		print("value:",x)

g = foo()        #g 是一个生产器

next(g)          #程序运行到yield就停住了，等待下一个next

g.send(1)        #我们给yield 发送值1，然后这个值就被赋值给了x,并且打印出来，然后继续下一次循环停在yield处

g.send(2)        #同上

next(g)          #没有给赋值，执行print语句，打印None,继续循环停在yield处


我们都知道，程序一旦执行到yield就会停在该处,并且将其返回值进行返回.上面的例子中，我们并没有设置返回值，

所有默认程序返回的是None。我们通过打印语句来查看一下第一次next的返回值：

print(next(g))

####输出结果#####
	
	None

正如我们所说的，程序返回None。接着程序往下执行，但是并没有看到next()方法。

为什么还会继续执行yield语句后面的代码呢？这是因为，send()方法具有两种功能：

第一，传值，send()方法，将其携带的值传递给yield，注意，是传递给yield，而不是x,然后再将其赋值给x；

第二，send()方法具有和next()方法一样的功能，也就是说，传值完毕后，会接着上次执行的结果继续执行，

知道遇到yield停止。这也就为什么在调用g.send()方法后，还会打印出x的数值。

有了上述的分析，我们可以总结出send()的两个功能：1.传值；2.next()。

既然send()方法有和next一样的作用，那么我们可不可以这样做：

def foo():
	    
	while True:
		        
		x = yield
		
		print("value:",x)
		   
g = foo()
	
g.send(1) #执行给yield传值,这样行不行呢?

执行结果：TypeError: can not send non-None value to a just-started generator

错误提示:不能传递一个非空值给一个未启动的生成器。

也就是说，在一个生成器函数未启动之前，是不能传递数值进去。必须先传递一个None进去或者调用一次next(g)方法，

才能进行传值操作。至于为什么要先传递一个None进去，可以看一下官方说法。

Because generator-iterators begin execution at the top of the
generator function body, there is no yield expression to receive
a value when the generator has just been created.  Therefore,
calling send() with a non-None argument is prohibited when the
generator iterator has just started, and a TypeError is raised if
this occurs (presumably due to a logic error of some kind).  Thus,
before you can communicate with a coroutine you must first call
next() or send(None) to advance its execution to the first yield
expression.

问题就来，既然在给yield传值过程中，会调用next()方法，那么是不是在调用一次函数的时候，

是不是每次都要给它传递一个空值？有没有什么简便方法来解决這个问题呢？答案，装饰器！！看下面代码:

def deco(func):  # 装饰器:用来开启协程
	
	def wrapper():

		res = func()

		next(res)

		return res    #返回一个已经执行了next的函数对象

	return wrapper

@deco

def foo():

	food_list = []

	while True:
		
		food = yield food_list    #返回添加food的列表

		food_list.append(food)

		print("elements in foodlist are:",food)

g = foo()

print(g.send('苹果'))

print(g.send('香蕉'))

print(g.send('菠萝'))

###########输出结果为######

elements in foodlist are: 苹果

['苹果']

elements in foodlist are: 香蕉

['苹果', '香蕉']

elements in foodlist are: 菠萝

['苹果', '香蕉', '菠萝']


这里我们要明确一点，yield的返回值和传给yield的值是两码事！！

yield的返回值就相当于return的返回值，这个值是要被传递出去的,而send()传递的值，是要被yield接受，

供函数内部使用的的，明确这一点很重要的。那么上面的打印，就应该打印出yield的返回值，

而传递进去的值则本保存在一个列表中。






装饰器：


装饰器本质上是一个Python函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外的功能，

装饰器的返回值也是一个函数或类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、

缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计。

有了装饰器，我们可以抽离大量与函数功能本身无关的雷同代码到装饰器中并继续使用。概括的将，装饰器的作用

就是为已经存在的对象添加额外的功能。


例子： 定义一个函数专门处理日志，日志处理完之后执行代码

def use_logging(func):
	
	logging.warn("%s is running"% func.__name__)
	
	func()

def foo():

	print('i am foo')

use_logging(foo)


这样做的逻辑没有问题，功能实现了，但是我们调用的时候不再试调用真正的业务逻辑函数foo，而是变成了use_logging函数

破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个 foo 函数作为参数传递给 use_logging 函数，

那么有没有更好的方式的呢？当然有，答案就是装饰器。


def use_logging(func):

	def wrapper():

		logging.warn("%s is running"% func.__name__)

		return func()

	return wrapper

def foo():
	print('i am foo')


foo = use_logging(foo) #因为装饰器use_logging(foo)返回的函数对象wrapper,这条语句相当于foo = wrapper

foo()                  # 执行foo()就相当于执行 wrapper()


@语法糖

@ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。

def use_logging(func):

	def wrapper():
	
		logging.warn("%s is running" % func.__name__)
		
		return func()
	return wrapper
							 

@use_logging

def foo():
	
	print("i am foo")
									 
foo()

如上所示，有了@，我们就可以省去foo = use_logging(foo)这一句了，直接调用 foo() 即可得到想要的结果。

装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，

可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。



*args、**kwargs:

可能有人问，如果我的业务逻辑函数 foo 需要参数怎么办？比如：

def foo(name):
	
	print("i am %s" % name)

我们可以在定义 wrapper 函数的时候指定参数：

def wrapper(name):
	        
		logging.warn("%s is running" % func.__name__)
			    
		return func(name)

	return wrapper


这样 foo 函数定义的参数就可以定义在 wrapper 函数中。这时，又有人要问了，如果 foo 函数接收两个参数呢？

三个参数呢？更有甚者，我可能传很多个。当装饰器不知道 foo 到底有多少个参数时，我们可以用 *args 来代替：

def wrapper(*args):
	
		logging.warn("%s is running" % func.__name__)
			        
		return func(*args)

	return wrapper





类装饰器：

没错，装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。

使用类装饰器主要依靠类的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。


class Foo(object):
	
	def __init__(self, func):
		
		self._func = func

		def __call__(self):
			
				print ('class decorator runing')
									        
				self._func()
				
				print ('class decorator ending')
											 
@Foo

def bar():
	
	print ('bar')
													 
bar()




在python中变量不需要声明，但是使用之前必须赋值，在混合类型的表达式中，python首先将被操作

的对象转换成其中最复杂的操作对象的类型，然后再对相同的类型的操作对象进行数字运算。

在python3中有3种方法计算平方根：使用一个模块函数、一个表达式或一个内置函数。

import math
math.sprt(144)

144**.5

pow(144,.5)

模块是外部组件，而内置函数位于一个隐形的命名空间内，python会自动搜索程序的变量名。

这个命名空间对应Python3中为builtins模块（python2.6中的__builtin__）。


小数：

from decimal import Decimal 

printf(Decimal('0.1') + Decimal('0.1') + Decimal('0.1') -Decimal('0.3'))

Decimal('0.0')


decimal.getcontext().prec = 4 (设置精度，小数点后4位)


分数：

from fractions  import Fraction

x = Fraction(1,3)

y = Fraction(4,6)

printf(x + y)

Fraction(1,1)


print(x - y)

Fraction(-1,3)


print(x * y)

Fraction(2,9)




集合：

集合(set)，这是一些唯一的，不可变的对象的一个无序集合（collection）.


集合对象支持与数学集合理论相对应的操作。

要创建一个集合对象，向内置的set函数传递一个序列或其他的可迭代的对象：

集合通过表达式操作符支持一般的数学集合运算。注意，不能在一般序列上应用这些表达式，

必须通过序列创建集合后才能使用。

x = set('abcde')

y = set('bdxyz')

print(x)

	set(['a', 'c', 'b', 'e', 'd'])

'e' in  x
	
	True

x - y
	
	set(['a','c','e'])

x | y

	set(['a','c','b','d','y','x','z'])

x & y
	
	set(['b','d'])

x ^ y

	set(['a','c','e','y','x','z'])

x > y ,x < y
	
	(False,False)


除了表达式，集合对象还提供了对应这些操作的方法。


"----------------------------------------------------------------------"

					第六章   动态类型简介
	
"----------------------------------------------------------------------"

动态类型以及它提供的多态性是python语言简洁性和灵活性的基础。


静态编译类型语言：C、C++、Java，Python是动态类型模型的领域，在python中，类型是在运行过程中自动决定的，

而不是通过代码声明。这意味着没有比要声明变量，这个概念实质上对变量、对象和他们之间的关系都适用。


变量、对象和引用：

当在Python中运行赋值语句a = 3 时，即使没有告诉Python将a作为一个变量来使用，或者没有告诉a应该作为一个整数类型

对象，但一样能工作，在python语言中，这些都会以一种非常自然的方式完成，就像下面这样：

变量创建：

	一个变量（也就是变量名），就像a，当代码第一次给它赋值时就创建了它。之后的赋值将会改变已创建的比变量名的值。

	从技术上讲，Python在代码运行之前先检查变量名，可以当成是最初的赋值创建变量。

变量类型：

	变量永远不会有任何的和它关联的类型信息或约束。类型的概念是存在于对象中而不是变量名中。变量原本是通用的，它只是

	在一个特定的时间点，简单地引用了一个特定的对象而已。

变量使用：

	当变量出现在表达式中时，它会马上被当前引用的对象所代替，无论这个对象是什么类型。此外，所有的变量必须在使用前明确地

	赋值，使用未赋值的变量会产生错误。

总而言之，变量在赋值的时候才创建，它可以引用任何类型的对象，并且必须在引用之前赋值。这意味着，不需要通过脚本声明所要

使用的名字，但是，必须初始化名字然后才能更新他们，例如：必须把计数器初始化为0，然后才能增加它。


对于动态类型应清楚的将变量名和对象划分开来

	例如： a = 3

	Python 将会执行三个不同步骤去完成这个请求，这个步骤反映了Python语言中的所有赋值操作：

	1、创建一个对象来代表值3
	
	2、创建一个比变量a,如果它还没有创建的话

	3、将变量与新的对象3相连接

变量和对象保存在内存中不同的部分，并通过连接相关联，变量总是链接到对象。

在运行a = 3后，变量a变成对象3的一个引用。在内部，比变量事实上是到对象内存空间的一个指针。

在python中从变量到对象的连接称为引用，也就是说，引用是一种关系，以内存中的指针的形式实现。

一旦变量被使用，Python自动跟随这个变量到对象的连接。
	
	变量是一个系统表的元素，拥有指向对象的连接的空间。

	对象是分配的一块内存，有足够的空间去代表它们所代表的值。

	引用是自动形成的从变量到对象的指针。

每一个对象都有两个标准的头部信息：一个类型标志符去标识这个对象的类型，以及一个引用的计数器，用来决定是不是

可以回收这个对象。


类型属于对象，而不是变量：



共享引用：

a = 3

b = a

变量a和b都引用了相同的对象（也就是指向了相同的内存空间）。在python中叫共享引用，多个变量名引用了同一个对象。

a = 3

b = a

a = 'spam'

变量a引用了由常量表达式'spam'所创建的新对象，但是变量b仍然引用原始对象3.因为这个赋值运算改变的不是对象3，

仅仅是变量a的引用。


a = 3

b = a 

a = a + 2

给一个变量赋一个新的值，并不是替换了原始的对象，而是让这个变量去引用完全不同的一个对象。实际的效果就是对一个变量赋值。

仅仅是影响那个被赋值的变量。



共享引用和相等：

由于Python的引用模型，在Python中有两种不同的方法去检查是否相等，例如：
L = [1,2,3]

M = L

pirnt(L == M)
	
	True

print(L is M)

	True

第一种技术"==操作符"，测试两个被引用的对象是否有相同的值。这种方法往往在python中用作相等的检查。

第二种方法"is操作符"，是检查对象的统一性。如果两个变量名精确地指向同一个对象，它会返回True,这是一种更严格形式的相等测试。

实际上，is只是比较实现引用的指针，所以如果必要的话是代码中检测共享引用的一种办法。如果变量名引用值相等，但是是不同的对象，

它的返回值将是Flase

L = [1,2,3]

M = [1,2,3]

pirnt(L == M)

	True

print(L is M)

	False

在sys模块中getrefcount函数返回对象引用的次数。例如查询整数对象1时：

import sys

sys.getrefcount(1)



"-----------------------------------------------------------------------------"

					第七章          字符串
		
"-----------------------------------------------------------------------------"

在python中，字符串变成了一个强大的处理工具集，没有单个字符的这种类型。


单双引号字符串是一样的：

在python字符串中，单引号和双引号可以互换。两种形式能够使用是因为你不使用反斜杠转义字符就可以实现在

一个字符串中包含其余种类的引号，即是你可以在一个双引号中嵌入一个单引号，反之亦然

str1 = 'knight"s'

str2 = "knight's"

此外，python自动在任意的表达式中合并相邻的字符串常量，尽管可以简单的在他们之间增加"+"操作符来明确的表示

这是一个合并操作。（这种形式放在园括号中，就可以允许跨越多行）

title = "Meaning "  'of ' "Life "

print(title)
		
	'Meaning of Life'
	
注意，在这些字符串中间增加逗号会创建一个元组，而不是一个字符串。

在Python中，零（空）字符不会像C语言那样去结束一个字符串。相反，Python在内存中保持了整个字符串的长度和文本。

事实上，Python中没有字符会结束一个字符串。


raw字符抑制转义：

如果字母r(大写或小写)出现在字符串的第一个引号前面，它将关闭转义机制。

注意：尽管有用，但一个raw字符串也不能以单个的反斜杠结尾，因为，反斜杠会转义后续引用的字符，仍然必须转义外围引号

字符以将其嵌入到该字符串中，也就是说，r"...\" 不是一个有效的字符串常量，一个raw字符串不能以奇数个反斜杠结束。



三重引号编写多行字符串块：

python 把所有在三重引号之内的文本收集到一个单独的多行字符串中，并在代码折行处嵌入了换行字符(\n).

三重引号字符串常用于文档字符串，当它出现在文件的特定地点时，被当作注释一样的字符串常量。



基本操作：

与C字符数组不同的是，使用python字符串时，不用分配或管理存储数组，只要在需要时创建字符串对象，

让python去管理底层的内存空间。


pyhton在执行"+","*"操作符是能根据数字和字符串正确的执行时因为它知道操作对象的类型。

python不允许你在"+"表达式中混数字和字符串：例如"abc" + 9 

字符串定义为字符的有序集合，所以我们能够通过其位置获得他们的元素。


索引和分片：

与C语言一样，Python偏移量从0开始的，并比字符串的长度小1.与c语言不同，

python支持类似在字符串中使用负偏移这样的方法从序列中获取元素。

一个负偏移与这个字符串的长度相加后得到这个字符串的正的偏移量。


当使用一对以冒号的偏移量来索引字符串的序列对象时，Python将返回一个新的对象，其中包含了以这对偏移

所标识的连续的内容。左边的偏移为下边界（包含下边界在内），而右边的为上边界（不包含上边界在内）的

所有元素的新的对象。如果被省略，上、下边界的默认值分别为0和分片的对象的长度。


扩展分片：第三个限制值

X[I:J:K]表示：索引X对象中的元素，从偏移为I直到偏移为J-1,每隔K元素索引一次。

第三个限制为-K，默认为1，这就是通常一个切片中从左至右提取每一个元素的原因。

负数作为步进。例如分片表达式"Hello" [::-1]返回新的字符串"olleH",步进-1表示

分片将从右至左进行而不是从左到右。实际效果就是讲序列进行反转。

通过一个负数步进，两个边界的意义实际上进行了反转。也就是说，

分片s[5:1:-1]以反转的顺序取从2到5的元素。



字符串转换工具：

Python的设计座右铭之一就是：拒绝猜的诱惑。

int函数将字符串转换成数字，而str函数将数字转换成字符串表达形式。float把字符串转换成浮点数。

int,float只能对数字字符串进行转换。


字符串代码转换：

单个字符串通过内置ord函数转换成对应的ASCII码，这个函数实际返回是这个字符在内存中对应的字符的二进制。

而chr函数将会执行相反的操作，获取的ASCII码转化为对应的字符：

>>> ord('s')

115

>>>chr(115)

's'

字符串方法实例：修改字符串

内置list函数（或一个对象构造函数调用）以任意序列中的元素创立一个新的列表。

>>>s = 'spammy'

>>>l = list(s)

>>>l

['s','p','a','m','m','y']


修改列表之后，需要将其变回一个字符串，可以用字符串方法join将列表"合成"一个字符串。

>>>s = ''.join(l)

>>>s

spammy


字符串方法实例：文本解析

>>> line='aaa bbb ccc'

>>>cols = line.split()

>>>cols

['aaa','bbb','ccc']

字符串的split方法将一个字符串分割为一个子字符串的列表，以分割符字符串为标准。


字符串格式化表达式，python中的字符串格式化可以两种形式实现：

字符串格式化表达式：

	基于c语言的"printf"模型。

字符串格式化方法调用：

	python中独有的方法，和字符串格式化表达式功能很大重叠。


python在对字符串操作的时候定义了%二进制操作符（%在数字中是除法取余数的操作符），当应用到字符串上，

%提供了简单的方法对字符串的值进行格式化，这一操作取决于格式化定义的字符串。


格式化字符串：

1.在%操作符的左侧放置一个需要进行格式化的字符串，这个字符串带有一个或多个嵌入的转换目标，都以%开头（例如%d）

2.在%操作符的右侧放置一个（或多个，嵌入到元组中）对象，这些对象将会插入到左侧想让python进行格式化字符串的一个

（或多个）转换目标的位置上。

例如：

>>> 'That is %d %s bird!' % (1,'dead')

That is 1 dead bird!

>>> exclamation = "Ni"

>>> "The knights who say %s!" % exclamation

The knights who say Ni!

>>> "%s ---%s---%s" %(42,3.14159,[1,2,3])

'42 ---3.14.159---[1,2,3]'

一个整数，一个浮点数和一个列表对象，但是目标左侧都是%s,这就表示要把他们转换成字符串。

由于每一个对象的每个类型都可以转换为字符串，每一个与%s一同参与操作的对象类型都可以转换代码。

另外，格式化总会返回一个新的字符串作为结果而不是对左侧的字符串进行修改。


基于字典的字符串格式化：

字符串的格式化同时也允许左边的转换目标来引用右边字典中的键来提取对应的值。

>>>"%(n)d %(x)s" %{"n":1,"x":"spam"}

'1 spam'


字符串格式化调用方法：format方法

字符串对象的format方法使用主体字符串作为模板，并且接受任意多个表示将要根据模板替换的值的参数。

在主体字符串中，花括号通过位置（例如{1}）或关键字指出替换目标及将要插入的参数。

例如：

>>> template = '{0},{1} and {2}'

>>> template.format('spam','ham','eggs')

'spam,ham and eggs'

>>>template = '{motto},{pork} and {food}'

>>>template.format(motto='spam',pork='ham',food='eggs')

'spam,ham and eggs'


就像%表达式和其他字符串方法一样，format创建并返回一个新的字符串对象。


添加键、属性和偏移量：

像%格式化表达式一样，格式化调用可以变的更复杂以支持更多高级用途。

>>>import sys

>>> 'My {config[spam]} runs {sys.platform}'.format(sys=sys,config={'spam':'laptop'})

'My laptop runs linux'


添加具体格式化：

对于格式化方法，我们在替换目标的标识之后使用一个冒号，后面跟着可以指定字段大小，

对齐方式和一个特定类型编码的格式化声明。如下是可以在一个格式字符串中作为替代目标出现的形式化结构：

{fieldanme!conversionflag:formatspec}

在这个替代目标语法中:

fieldname是指定参数的一个数字或关键字，后面跟着可选的".name"或"[index]"成分引用。

conversionflag可以是r、s、或者a分别是在该值上对repr、str或ascii内置函数的一次调用。

formatspec指定了如何表示该值，包括字段宽度、对齐方式、补零、小数点精度等

例子：

>>>'{0:10} = {1:10}'.format('spam',123.4567)

'spam       =   123.4567'

>>>'{0:.2f}'.format(1/3.0)

'0.33'



通常意义下的类型分类：


数字（整数、浮点数、二进制、分数等）

	支持加法和乘法等。

序列（字符串、列表、元组）

	支持索引、分片和合并等

	对于任意的序列对象X 和 Y：

	X + Y : 将会创建一个包含了两个操作对象的新的序列对象。

	X * N : 将会创建一个包含操作对象X内容N份拷贝的新的序列对象。


映射(字典)

	支持通过键的索引等。


可变类型能够在原处修改：

不可变类型（数字、字符串、元组、不可变集合）
	
	不支持在原处修改。

可变类型（列表、字典、可变集合）



字符串find方法能用于搜索列表吗？

不行，因为方法是类型特定的，只能用于单一数据类型上。像X+Y这样的表达式和len(X)这样的内置函数是通用的。

可以用在多种类型上。


在python，怎么修改字符串？

字符串无法被修改，字符串是不可改变的。但是可以通过切片运算、合并、格式化、方法调用创建新的字符串，将结果赋值

给最初的变量名，从而达到相似的效果。


