"---------------------------------------------------"
    
            面试中碰到的问题

"---------------------------------------------------"

"""python"""

1、python 测试工具以及区别
    

2、单元测试模块以及库
    
3、functools 库
    
4、python2 和 python3 的区别

5、协程
    
6、单例模式
    
7、装饰器


8、下面是什么函数？

    # 这是一个求质数函数，除了 1 和 本身之外没有别的约数。
    def g(n):
        for i in range(2,n):
            if n%i == 0:
                return False
        return True
        
    xlist = [x for x in range(1,20) if g(x)]
    print(xlist)
    #[1, 2, 3, 5, 7, 11, 13, 17, 19]
       
9、二叉树，通过前序遍历(ADCEFGHB)和中序遍历(CDFEGHAB)写出后序遍历：
    
    前序遍历: 根节点 --> 左子树 --> 右子树
    
    中序遍历: 左子树 --> 根节点 --> 右子树
    
    后序遍历: 左子树 --> 右子树 --> 根节点
    
    
             A
          D     B
        C    E
           F   G
                 H
    
    后序遍历的结果是: CFHGEDBA 
    
                 
"""MySQL"""

1、MySQL 查询优化:
    
    查询优化几个方向:
        
        a、尽量避免全文扫描，给相应字段增加索引，应用索引来查询
        b、删除不用或者重复的索引
        c、查询重写，等价转换（谓词、子查询、连接查询）
        d、删除内容重复不必要的语句，精简语句
        e、整合重复执行的语句
        f、缓存查询结果
        
    MYSQL查询语句优化:
        
        a、避免使用不兼容的数据类型。
            
            例如float和int、char和varchar、binary和varbinary是不兼容的。
            数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。    
            
        b、索引字段上进行运算会使索引失效。
                
            尽量避免在WHERE子句中对字段进行函数或表达式操作，这将导致引擎放弃使用索引而进行全表扫描。
            如： SELECT * FROM T1 WHERE F1/2=100 应改为: SELECT * FROM T1 WHERE F1=100*2    
            
        c、 避免使用!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符.
                
            因为这会使系统无法使用索引,而只能直接搜索表中的数据。
            例如: SELECT id FROM employee WHERE id != “B%” 
            优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。
            在in语句中能用exists语句代替的就用exists.   
            
        d、尽量使用数字型字段.
            
            一部分开发人员和数据库管理人员喜欢把包含数值信息的字段设计为字符型，
            这会降低查询和连接的性能，并会增加存储开销。
            这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，
            而对于数字型而言只需要比较一次就够了。
        
        e、能够用BETWEEN的就不要用IN
            
        f、能够用DISTINCT的就不用GROUP BY
            
        g、尽量不要用SELECT INTO语句。SELECT INTO 语句会导致表锁定，阻止其他用户访问该表。
            

2、MySQL 注入，代码层防止注入的原理：
        
    所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串。
    终于达到欺骗server运行恶意的SQL命令。

    详细来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎运行的能力，
    它能够通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的站点上的数据库。
    而不是依照设计者意图去运行SQL语句。   
        
    依据相关技术原理，SQL注入能够分为平台层注入和代码层注入。
        
        前者由不安全的数据库配置或数据库平台的漏洞所致；
        后者主要是因为程序猿对输入未进行仔细地过滤，从而运行了非法的数据查询。
        
    基于此，SQL注入的产生原因通常表如今下面几方面：
        ①不当的类型处理；
        ②不安全的数据库配置。
        ③不合理的查询集处理；
        ④不当的错误处理；
        ⑤转义字符处理不合适；
        ⑥多个提交处理不当。
        
    注入方法：

        1.猜表名。列名等

            先猜表名  
                And (Select count(*) from 表名)<>0
                
            猜列名
                And (Select count（列名） from 表名）<>0
                
            或者也能够这样 
                and exists (select * from 表名）            
                and exists (select 列名 from 表名）          
                返回正确的，那么写的表名或列名就是正确  

        2.后台身份验证绕过漏洞:
            
            验证绕过漏洞就是'or'='or'后台绕过漏洞，利用的就是AND和OR的运算规则，
            从而造成后台脚本逻辑性错误。
                
            比如管理员的账号password都是admin。那么再比方后台的数据库查询语句是

            user=request("user")
            passwd=request("passwd")                
            sql='select admin from adminbate where user='&'''&user&'''&' and passwd='&'''&passwd&'''              
            那么我使用'or 'a'='a来做usernamepassword的话，那么查询就变成了                
            select admin from adminbate where user=''or 'a'='a' and passwd=''or 'a'='a'               
            这种话，依据运算规则。这里一共同拥有4个查询语句，那么查询结果就是 假or真and假or真，
            先算and 再算or，终于结果为真。这样就能够进到后台了        
            
        3. 怎样预防 呢？归纳一下，主要有下面几点：
            
            a. 永远不要信任用户的输入。对用户的输入进行校验，能够通过正則表達式，
               或限制长度；对单引號和双"-"进行转换等。
                
            b.永远不要使用动态拼装sql，能够使用參数化的sql或者直接使用存储过程进行数据查询存取。
                
            c.永远不要使用管理员权限的数据库连接，为每一个应用使用单独的权限有限的数据库连接。
                
            d.不要把机密信息直接存放。加密或者hash掉password和敏感的信息。
                
            e. 应用的异常信息应该给出尽可能少的提示，
               最好使用自己定义的错误信息对原始错误信息进行包装。
                
            f.sql注入的检測方法一般採取辅助软件或站点平台来检測。
                软件一般採用sql注入检測工具jsky，站点平台就有亿思站点安全平台检測工具。
                MDCSOFT SCAN等。採用MDCSOFT-IPS能够有效的防御SQL注入。XSS攻击等。

    
3、MySQL 常用的引擎，及其区别：
    
    MyISAM:
        
        此引擎不支持事务，也不支持外键。
        
        锁级别为表锁，表锁的优点是开销小，加锁快；缺点是锁粒度大，发送锁冲突概率高，
        容纳并发能力低，这个引擎适合查询为主的业务。
        
        MyISAM 强调了快速读取操作。它存储表的行数，于是 SELECT COUNT(*) FROM TABLE 时
        只需要直接读取已经保存好的值而不需要进行全表扫描。    
        
    InnoDB:
        
        此引擎，支持事务，支持外键，支持回滚，支持 Hash/B-tree 索引类型。
        
        锁级别为行锁，行锁的优点是适用于高并发的频繁表修改，高并发的性能优于 MyISAM。
        缺点是系统消耗比较大，索引不仅缓存自身，也缓存数据，相比 MyISAM 需要更大的内存。
        
        InnoDB 中不保存表的具体行数，也就是说，执行 select count(*) from table 时，
        InnoDB 要扫描一遍整个表来计算有多少行。
        
    Memory:
    
        Memory 是内存级别的存储引擎，数据存储在内存中，所以他能够存储的数据量较小。
        
        因为内存特性，存储引擎对数据的一致性支持交差。但访问速度非常快，默认使用 hash 索引。
        
        锁级别为表锁，不支持事务。    


"""other"""

1、RESTful api:
    
        